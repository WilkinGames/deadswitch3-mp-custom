/**
 * Deadswitch 3 Game Logic
 * (c) 2022 Wilkin Games
 * https://xwilkinx.com
 */
const Settings = {
    BATCH_MAX: 8,
    FLAMES_MAX: 40,
    SCAVENGER_PACKS_MAX: 5,
    CRATES_MAX: 5,
    TURRETS_MAX: 2,
    INFECTED_INTERMISSION_TIMER: 3,
    SURVIVAL_WAVE_START: 0,
    SURVIVAL_MONEY_START: 0,
    SURVIVAL_MULTIPLIER_MAX: 5,
    SANDBOX_MAX_PAWNS_PER_TEAM: 8,
    SANDBOX_MAX_SPAWNERS: 6,
    LOG_PREFIX: "[GameInstance]",
    LOG_SUFFIX: "color: mediumslateblue"
};
const Battlezone = {    
    TEAM_AIRDROPS: 97,
    TEAM_ENEMIES: 98,
    TEAM_MERCENARIES: 99,    
    CRATE_INTERACT_TIME: 3,
    MAX_XP: 1000000,
    MAX_SHARDS: 10,
    MAX_MERCS: 5,
    MAX_HELIS: 2
};
const Rocket = {
    TYPE_DEFAULT: "TYPE_DEFAULT",
    TYPE_HELLFIRE: "TYPE_HELLFIRE",
    TYPE_NAPALM: "TYPE_NAPALM"
};
const GameServer = {
    INV_CLASS_DATA: 1,
    INV_CURRENT_INVENTORY_INDEX: 2,
    INV_FIRE: 3,
    INV_PERK_ADD: 4,
    INV_PERKS: 5,
    INV_PERKS_SET: 6,
    INV_MOD_SET: 7,
    INV_EQUIPMENT_SET: 8,
    INV_EQUIPMENT_ADD: 9,
    INV_AMMO: 10,
    INV_AMMO_ADD: 11,
    INV_MAG: 12,
    INV_MAG_ADD: 13,
    INV_BURSTS: 14,
    INV_BURSTS_ADD: 15,
    INV_ITEM: 16,
    INV_ITEM_ADD: 17,
    INV_ITEM_REPLACE: 18,
    INV_INVENTORY_REPLACE: 19,
    INV_INVENTORY: 21,
    INV_EQUIPMENT: 22,
    EVENT_ERROR: 99,
    EVENT_BATCH: 0,
    EVENT_GAME_INIT: 1,
    EVENT_GAME_TIMER: 2,
    EVENT_GAME_PRE_TIMER: 3,
    EVENT_GAME_START: 4,
    EVENT_GAME_END: 5,
    EVENT_GAME_UPDATE: 6,
    EVENT_STORE_BUY: 7,
    EVENT_GAME_MONEY_ADD: 8,
    EVENT_GAME_WAVE_START: 9,
    EVENT_GAME_WAVE_COMPLETE: 10,
    EVENT_GAME_PAUSE: 11,
    EVENT_REQUEST_RANKED_CHARACTER: 13,
    EVENT_CREATE_RANKED_CHARACTER: 14,
    EVENT_CREATE_GENERIC_CHARACTER: 15,
    EVENT_CREATE_INFESTOR: 16,
    EVENT_OBJECT_UPDATE: 17,
    EVENT_OBJECT_HIT: 18,
    EVENT_PAWN_DAMAGE: 19,
    EVENT_PAWN_DIE: 20,
    EVENT_PAWN_ACTION: 21,
    EVENT_SET_PLAYER_CONTROLLER_ID: 22,
    EVENT_CREATE_AI_CONTROLLER: 23,
    EVENT_PLAYER_JOIN: 24,
    EVENT_PLAYER_LEAVE: 25,
    EVENT_PLAYER_UPDATE: 26,
    EVENT_PLAYER_RESPAWN: 27,
    EVENT_PLAYER_EARN_KILLSTREAK: 28,
    EVENT_PLAYER_USE_KILLSTREAK: 29,
    EVENT_PLAYER_OPEN_WORLD_MENU: 30,
    EVENT_PLAYER_CLOSE_WORLD_MENU: 31,
    EVENT_PLAYER_SET_WORLD_POSITION: 32,
    EVENT_PLAYER_EXECUTE_KILLSTREAK: 33,
    EVENT_PLAYER_FLAG: 34,
    EVENT_PLAYER_MULTI_KILL: 35,
    EVENT_PLAYER_UPDATE_CONTROLLABLE: 36,
    EVENT_PLAYER_INPUT: 37,
    EVENT_PLAYER_INTERACT: 38,
    EVENT_PLAYER_UPDATE_INVENTORY: 39,
    EVENT_PLAYER_TRIGGER_WEAPON: 40,
    EVENT_PLAYER_TRIGGER_EQUIPMENT: 41,
    EVENT_PLAYER_TRIGGER_MELEE: 42,
    EVENT_KILLSTREAKS_UPDATE: 43,
    EVENT_ANNOUNCER_MESSAGE: 44,
    EVENT_KILLFEED_ADD: 45,
    EVENT_MESSAGE_ADD: 46,
    EVENT_SPAWN_OBJECT: 47,
    EVENT_SPAWN_BULLET: 48,
    EVENT_SPAWN_EXPLOSION: 49,
    EVENT_SPAWN_GRENADE: 50,
    EVENT_SPAWN_PROJECTILE: 51,
    EVENT_SPAWN_ROCKET: 52,
    EVENT_SPAWN_DROPPED_WEAPON: 53,
    EVENT_SPAWN_CRATE: 54,
    EVENT_SPAWN_FLAG: 55,
    EVENT_SPAWN_EQUIPMENT: 56,
    EVENT_SPAWN_HELICOPTER: 57,
    EVENT_SPAWN_TURRET: 58,
    EVENT_SPAWN_REVIVER: 59,
    EVENT_INTERACTABLE_USED: 60,
    EVENT_REMOVE_OBJECT: 61,
    EVENT_SANDBOX: 62,
    EVENT_ROUND_END: 63,
    EVENT_ROUND_START: 64,
    EVENT_BATTLEZONE: 65,
    EVENT_SWITCH_TEAMS: 66,
    PAWN_FIRE_WEAPON: 1,
    PAWN_HIT_SHIELD: 2,
    PAWN_START_REVIVE: 3,
    PAWN_END_REVIVE: 4,
    PAWN_SHARED_CRATE: 5,
    PAWN_STOLE_CRATE: 6,
    PAWN_START_INTERACTION: 7,
    PAWN_NO_AMMO: 8,
    PAWN_OPEN_LAPTOP: 9,
    PAWN_ON_FIRE: 10,
    PAWN_STUN: 11,
    PAWN_FLASH: 12,
    PAWN_FREEZE: 13,
    PAWN_SET_JAMMED: 14,
    PAWN_UPDATE_DOOR: 15,
    PAWN_INVESTIGATE: 16,
    PAWN_TROPHY_HIT: 17,
    PAWN_START_SHIELD_COOLDOWN: 18,
    PAWN_END_SHIELD_COOLDOWN: 19,
    PAWN_END_FIRE_DELAY: 20,
    PAWN_END_BOLT_DELAY: 21,
    PAWN_END_THROW_DELAY: 22,
    PAWN_END_EQUIPMENT_DELAY: 23,
    PAWN_END_MELEE_DELAY: 24,
    PAWN_RELOAD_COMPLETE: 25,
    PAWN_CLOSE_LAPTOP: 26,
    PAWN_START_FLAME: 27,
    PAWN_END_FLAME: 28,
    PAWN_RELOAD: 29,
    PAWN_PULL_BOLT: 30,
    PAWN_CANCEL_RELOAD: 31,
    PAWN_CANCEL_BOLT_PULL: 32,
    PAWN_THROW_GRENADE: 33,
    PAWN_USE_STIM: 34,
    PAWN_RECEIVE_STIM: 35,
    PAWN_PLACE_EQUIPMENT: 36,
    PAWN_MELEE_ATTACK: 37,
    PAWN_FIRE_MELEE: 38,
    PAWN_FIRE_ROCKET: 39,
    PAWN_TRIGGER_MINE: 40,
    PAWN_END_INTERACTION: 41,
    PAWN_JUMP: 42,
    PAWN_ON_BOOST: 43,
    PAWN_START_LADDER_CLIMB: 44,
    PAWN_LEAVE_LADDER: 45,
    PAWN_DROP_CRATE: 46,
    PAWN_FLAG: 47,
    PAWN_HIT: 48
};
const GameMode = {
    SANDBOX: "sandbox",
    BATTLEZONE: "battlezone",
    DEATHMATCH: "deathmatch",
    TEAM_DEATHMATCH: "team_deathmatch",
    DOMINATION: "domination",
    CAPTURE_THE_FLAG: "capture_the_flag",
    DEFENDER: "defender",
    DEMOLITION: "demolition",
    HEADQUARTERS: "headquarters",
    ASSASSINATION: "escort",
    RESCUE: "rescue",
    GUN_GAME: "gun_game",
    INFECTED: "infected",
    OP_ELIMINATION: "op_elimination",
    OP_BOMB: "op_bomb",
    OP_HOSTAGE: "op_hostage",
    SURVIVAL_BASIC: "survival_basic",
    SURVIVAL_UNDEAD: "survival_undead",
    SURVIVAL_CHAOS: "survival_chaos",
    SURVIVAL_STAKEOUT: "survival_stakeout",
    SURVIVAL_PRO: "survival_pro"
};
const Character = {
    HAIR_COLOUR_BROWN: "HAIR_COLOUR_BROWN",
    HAIR_COLOUR_BROWN_LIGHT: "HAIR_COLOUR_BROWN_LIGHT",
    HAIR_COLOUR_BLACK: "HAIR_COLOUR_BLACK",
    HAIR_COLOUR_BLONDE: "HAIR_COLOUR_BLONDE",
    HAIR_COLOUR_GINGER: "HAIR_COLOUR_GINGER",
    HAIR_COLOUR_GREY: "HAIR_COLOUR_GREY",
    HAIR_COLOUR_WHITE: "HAIR_COLOUR_WHITE",
    HAIR_COLOUR_RED: "HAIR_COLOUR_RED",
    HAIR_COLOUR_BLUE: "HAIR_COLOUR_BLUE",
    HAIR_COLOUR_GREEN: "HAIR_COLOUR_GREEN",
    FACE_DEFAULT: "face0000",
    FACE_FEMALE: "face0009",
    FACE_ZOMBIE_1: "face0001",
    FACE_ZOMBIE_2: "face0002",
    FACE_ZOMBIE_3: "face0003",
    FACE_ZOMBIE_4: "face0004",
    FACE_ZOMBIE_FAT: "face0005",
    FACE_ZOMBIE_EXPLODER: "face0006",
    FACE_ZOMBIE_SPITTER: "face0007",
    FACE_ZOMBIE_SPITTER_BOSS: "face0007",
    FACE_ZOMBIE_SPRINTER: "face0008",
    FACE_INFESTOR: "face00012",
    FACE_ZOMBIE_SPRINTER_BOSS: "face0013",
    HAIR_SHORT: "hair0000",
    HAIR_BALD: "hair0008",
    HAIR_LONG: "hair0002",
    HAIR_PONYTAIL: "hair0003",
    HAIR_UNDERCUT: "hair0006",
    HAIR_SPIKES: "hair0005",
    HAIR_BUZZED: "hair0004",
    HAIR_FLAT: "hair0001",
    HAIR_STYLED: "hair0007",
    HAIR_HORSESHOE: "hair0009",
    HAIR_MOHAWK: "hair0010",
    BEARD_NONE: "beard0000",
    BEARD_STUBBLE: "beard0001",
    BEARD_FULL: "beard0002",
    BEARD_CIRCLE: "beard0003",
    BEARD_GOATEE: "beard0004",
    BEARD_MOUSTACHE: "beard0005",
    BEARD_SIDEBURNS: "beard0006",
    EYEWEAR_NONE: "eyewear0000",
    EYEWEAR_SHADES: "eyewear0001",
    EYEWEAR_GLASSES: "eyewear0002",
    EYEWEAR_GOGGLES_YELLOW: "eyewear0003",
    EYEWEAR_GOGGLES_ORANGE: "eyewear0004",
    EYEWEAR_GOGGLES_WHITE: "eyewear0005",
    EYEWEAR_GOGGLES_BLACK: "eyewear0006",
    EYEWEAR_GOGGLES_RED: "eyewear0007",
    EYEWEAR_GOGGLES_GREEN: "eyewear0008",
    FACEWEAR_NONE: "facewear0000",
    FACEWEAR_MASK: "facewear0001",
    FACEWEAR_SKULLMASK: "facewear0002",
    FACEWEAR_GHILLIE: "facewear0003",
    FACEWEAR_SCARF_OPFOR: "facewear0004",
    FACEWEAR_BALACLAVA: "facewear0005",
    FACEWEAR_SCARF_SPETSNAZ: "facewear0006",
    FACEWEAR_BANDANA: "facewear0007",
    FACEWEAR_GAS_MASK: "facewear0008",
    FACEWEAR_BANDANA_GENERIC: "facewear0009",
    FACEWEAR_GAITER: "facewear0010",
    FACEWEAR_TWOPLAYER: "facewear0019",
    HEAD_ERIC_HELMET: "head0082",
    HEAD_AETIC: "head0089",
    HEAD_NONE: "head0000",
    HEAD_MASK: "head0001",
    HEAD_GAS_MASK: "head0002",
    HEAD_RADIO: "head0003",
    HEAD_USMC_MASK: "head0004",
    HEAD_USMC_CAP: "head0005",
    HEAD_USMC_CAP_BACKWARDS: "head0006",
    HEAD_USMC_SPEC_OPS: "head0007",
    HEAD_USMC_HELMET: "head0008",
    HEAD_USMC_HELMET_TACTICAL: "head0009",
    HEAD_USMC_BOONIE: "head0010",
    HEAD_USMC_GHILLIE: "head0011",
    HEAD_GIGN_HELMET: "head0012",
    HEAD_GIGN_HELMET_2: "head0013",
    HEAD_GIGN_CAP: "head0014",
    HEAD_GSG9_HELMET: "head0015",
    HEAD_GSG9_HELMET_2: "head0016",
    HEAD_GSG9_HELMET_3: "head0017",
    HEAD_OPFOR_SCARF: "head0018",
    HEAD_OPFOR_HELMET: "head0019",
    HEAD_OPFOR_HELMET_2: "head0020",
    HEAD_OPFOR_BERET: "head0021",
    HEAD_OPFOR_SHADES: "head0022",
    HEAD_OPFOR_COMMANDER: "head0023",
    HEAD_RUS_MASK: "head0024",
    HEAD_RUS_HAT: "head0025",
    HEAD_RUS_SCARF: "head0026",
    HEAD_RUS_TOQUE: "head0027",
    HEAD_RUS_BERET: "head0028",
    HEAD_RUS_CAP: "head0029",
    HEAD_RUS_RECON: "head0030",
    HEAD_RUS_HELMET: "head0031",
    HEAD_MILITIA_RADIO: "head0032",
    HEAD_MILITIA_BAND: "head0033",
    HEAD_MILITIA_BANDANA: "head0034",
    HEAD_MILITIA_CAP: "head0035",
    HEAD_MILITIA_SNIPER: "head0036",
    HEAD_JUGGERNAUT_HELMET: "head0037",
    HEAD_SANTA_HAT: "head0040",
    HEAD_RIOT_HELMET: "head0055",
    HEAD_RIOT_HELMET_VISOR_UP: "head0056",
    HEAD_UN_BERET: "head0057",
    HEAD_UN_HELMET: "head0058",
    HEAD_NIGHTVISION: "head0059",
    HEAD_ALTYN_HELMET: "head0060",
    HEAD_ALTYN_HELMET_VISOR_UP: "head0061",
    HEAD_HOOD: "head0062",
    HEAD_BALLISTIC_MASK_BLACK: "head0045",
    HEAD_BALLISTIC_MASK_WHITE: "head0046",
    BODY_VIP: "vip",
    BODY_AETIC: "aetic_1",
    BODY_AETIC_2: "aetic_2",
    BODY_HOSTAGE: "hostage",
    BODY_USMC_STANDARD: "usmc",
    BODY_USMC_GHILLIE: "usmc_ghillie",
    BODY_USMC_HEAVY: "usmc_heavy",
    BODY_USMC_PARA: "usmc_para",
    BODY_USMC_RECON: "usmc_recon",
    BODY_GIGN_STANDARD: "gign",
    BODY_GIGN_HEAVY: "gign_heavy",
    BODY_GIGN_PARA: "gign_para",
    BODY_GIGN_RECON: "gign_recon",
    BODY_GIGN_TACTICAL: "gign_tactical",
    BODY_GSG9_STANDARD: "gsg9",
    BODY_GSG9_HEAVY: "gsg9_heavy",
    BODY_GSG9_PARA: "gsg9_para",
    BODY_GSG9_RECON: "gsg9_recon",
    BODY_GSG9_TACTICAL: "gsg9_tactical",
    BODY_OPFOR_STANDARD: "opfor",
    BODY_OPFOR_ROCKETIER: "opfor_rocketier",
    BODY_OPFOR_HEAVY: "opfor_heavy",
    BODY_OPFOR_PARA: "opfor_para",
    BODY_OPFOR_RECON: "opfor_recon",
    BODY_OPFOR_BARE: "opfor_bare",
    BODY_RUS_STANDARD: "rus",
    BODY_RUS_BARE: "rus_bare",
    BODY_RUS_HEAVY: "rus_heavy",
    BODY_RUS_PARA: "rus_para",
    BODY_RUS_RECON: "rus_recon",
    BODY_RUS_ROCKETIER: "rus_rocketier",
    BODY_JUGGERNAUT: "rus_juggernaut",
    BODY_MILITIA_STANDARD: "militia",
    BODY_MILITIA_HEAVY: "militia_heavy",
    BODY_MILITIA_PARA: "militia_para",
    BODY_MILITIA_RECON: "militia_recon",
    BODY_MILITIA_TACTICAL: "militia_tactical",
    BODY_USMC_KEVLAR: "usmc_kevlar",
    BODY_GIGN_KEVLAR: "gign_kevlar",
    BODY_GSG9_KEVLAR: "gsg9_kevlar",
    BODY_OPFOR_KEVLAR: "opfor_kevlar",
    BODY_RUS_KEVLAR: "rus_kevlar",
    BODY_MILITIA_KEVLAR: "militia_kevlar",
    BODY_ZOMBIE: "zombie",
    BODY_ZOMBIE_2: "zombie_2",
    BODY_ZOMBIE_3: "zombie_3",
    BODY_ZOMBIE_FAT: "zombie_fat",
    BODY_ZOMBIE_EXPLODER: "zombie_exploder",
    BODY_ZOMBIE_EXPLODER_BOSS: "zombie_exploder_boss",
    BODY_ZOMBIE_SPITTER: "zombie_spitter",
    BODY_ZOMBIE_SPITTER_BOSS: "zombie_spitter_boss",
    BODY_ZOMBIE_SPRINTER: "zombie_sprinter",
    BODY_ZOMBIE_SPRINTER_BOSS: "zombie_sprinter_boss",
    BODY_C4_VEST: "c4_vest"
};
const MatchState = {
    STATE_ENTERING_MAP: "entering_map",
    STATE_PRE_GAME: "pre_game",
    STATE_IN_PROGRESS: "in_progress",
    STATE_POST_ROUND: "post_round",
    STATE_POST_GAME: "post_game",
    END_RESULT_WIN: "end_result_win",
    END_RESULT_LOSS: "end_result_loss",
    END_RESULT_DRAW: "end_result_draw",
    END_CONDITION_TIME: "end_condition_time",
    END_CONDITION_SCORE: "end_condition_score",
    END_CONDITION_BOMB: "end_condition_bomb",
    END_CONDITION_DEFUSE: "end_condition_defuse",
    END_CONDITION_DEAD: "end_condition_dead",
    END_CONDITION_DEAD_ALLY: "end_condition_dead_ally",
    END_CONDITION_DEAD_ALLY_CAMPAIGN: "end_condition_dead_ally_campaign",
    END_CONDITION_FORFEIT: "end_condition_forfeit",
    END_CONDITION_OBJECTIVE: "end_condition_objective",
    END_CONDITION_INFECTED: "end_condition_infected",
    END_CONDITION_NUKE: "end_condition_nuke",
    END_CONDITION_HEADQUARTERS: "end_condition_headquarters",
    END_CONDITION_VIP_KILLED: "end_condition_vip_killed",
    END_CONDITION_HOSTAGES_RESCUED: "end_condition_hostages_rescued",
    END_CONDITION_HOSTAGE_KILLED: "end_condition_hostage_killed"
};
const Perks = {
    PERK_TYPE_PLAYER: "PERK_TYPE_PLAYER",
    PERK_TYPE_WEAPON: "PERK_TYPE_WEAPON",
    PERK_PLAYER_LIGHTWEIGHT: "perk_lightweight",
    PERK_PLAYER_JUGGERNAUT: "perk_health",
    PERK_PLAYER_GHOST: "perk_ghost",
    PERK_PLAYER_COLD_BLOODED: "perk_cold_blooded",
    PERK_PLAYER_SPECIALIST: "perk_recovery",
    PERK_PLAYER_SITREP: "perk_sitrep",
    PERK_PLAYER_MARTYRDOM: "perk_martyrdom",
    PERK_PLAYER_HELMET: "perk_helmet",
    PERK_PLAYER_NINJA: "perk_ninja",
    PERK_PLAYER_SCAVENGER: "perk_scavenger",
    PERK_PLAYER_ANTI_SNIPER: "perk_anti_sniper",
    PERK_WEAPON_RELOAD: "perk_reload",
    PERK_WEAPON_QUICKDRAW: "perk_aim",
    PERK_WEAPON_ACCURACY: "perk_accuracy",
    PERK_WEAPON_AMMO: "perk_ammo",
    PERK_WEAPON_OVERKILL: "perk_overkill",
    PERK_WEAPON_AGGRESSION: "perk_power",
    PERK_WEAPON_RECON: "perk_recon",
    PERK_WEAPON_STOPPING_POWER: "perk_freeze",
    PERK_WEAPON_SHRAPNEL: "perk_shrapnel",
    PERK_WEAPON_VAMPIRE: "perk_vampire"
};
const Mods = {
    TYPE_BASE: "base",
    TYPE_AMMO: "ammo",
    TYPE_BARREL: "barrel",
    BASE_DEADEYE: "base_marksman",
    BASE_RAPID_FIRE: "base_rapid_fire",
    BASE_LOCK_ON: "base_lock_on",
    BASE_DAMPER: "base_damper",
    BASE_SPEED: "base_speed",
    BASE_RANGE: "base_range",
    BASE_BURST_FIRE: "base_burst_fire",
    BASE_MODE_SELECTOR: "base_mode_selector",
    BASE_FULL_AUTO: "base_full_auto",
    BASE_SINGLE_FIRE: "base_single_fire",
    BASE_SHIELD_DAMAGE: "base_shield_damage",
    BASE_SHIELD_RAPID_FIRE: "base_shield_alloy",
    AMMO_FMJ: "ammo_fmj",
    AMMO_PIERCING: "ammo_ap",
    AMMO_IMPACT: "ammo_impact",
    AMMO_EXTENDED: "ammo_extended",
    AMMO_HOLLOW_POINT: "ammo_hollow_point",
    AMMO_LAUNCHER_RADIUS: "ammo_radius",
    AMMO_LAUNCHER_EXPLOSIVE: "ammo_explosive",
    AMMO_SLUG: "ammo_slug",
    AMMO_SPEED_LOADER: "ammo_speed_loader",
    AMMO_HIGH_CALIBER: "ammo_range",
    AMMO_NAPALM: "ammo_napalm",
    BARREL_SILENCER: "barrel_silencer",
    BARREL_LASER: "barrel_laser",
    BARREL_GRIP: "barrel_grip",
    BARREL_COMPENSATOR: "barrel_compensator",
    BARREL_BOOSTER: "barrel_booster",
    BARREL_ACCELERATOR: "barrel_range",
    BARREL_M203: "barrel_m203",
    BARREL_GP25: "barrel_gp25",
    BARREL_MASTERKEY: "barrel_masterkey"
};
const DamageType = {
    DAMAGE_BULLET: 1, //"DAMAGE_BULLET",
    DAMAGE_MELEE: 2, //"DAMAGE_MELEE",
    DAMAGE_EXPLOSIVE: 3, //"DAMAGE_EXPLOSIVE",
    DAMAGE_FIRE: 4, //"DAMAGE_FIRE",
    DAMAGE_WORLD: 5 //"DAMAGE_WORLD"
};
const Weapon = {
    TYPE_MELEE: "TYPE_MELEE",
    TYPE_PISTOL: "TYPE_PISTOL",
    TYPE_MACHINE_PISTOL: "TYPE_MACHINE_PISTOL",
    TYPE_SMG: "TYPE_SMG",
    TYPE_SHOTGUN: "TYPE_SHOTGUN",
    TYPE_SNIPER: "TYPE_SNIPER",
    TYPE_RIFLE: "TYPE_RIFLE",
    TYPE_LMG: "TYPE_LMG",
    TYPE_LAUNCHER: "TYPE_LAUNCHER",
    TYPE_GRENADE: "TYPE_GRENADE",
    TYPE_EXPLOSIVE: "TYPE_EXPLOSIVE",
    TYPE_TACTICAL: "TYPE_TACTICAL",
    TYPE_WEAPON_TACTICAL: "TYPE_WEAPON_TACTICAL",
    MODE_AUTO: "MODE_AUTO",
    MODE_BURST: "MODE_BURST",
    MODE_SEMI: "MODE_SEMI"
};
const BotSkill = {
    SKILL_EASY: 0,
    SKILL_NORMAL: 1,
    SKILL_HARD: 2,
    SKILL_INSANE: 3,
    SKILL_GOD: 4
};
const Helicopter = {
    TYPE_MH6: "mh6",
    TYPE_MH6_ATTACK: "mh6_attack",
    TYPE_MH6_GRENADE: "mh6_grenade",
    TYPE_COBRA: "cobra",
    TYPE_COBRA_CONTROLLABLE: "cobra_controllable",
    TYPE_BLACKHAWK: "blackhawk",
    TYPE_BLACKHAWK_SNIPER: "blackhawk_sniper",
    TYPE_PAVE_LOW: "pavelow",
    TYPE_OSPREY: "osprey",
    TYPE_REAPER: "reaper",
    TYPE_DRAGONFIRE: "dragonfire",
    TYPE_SCOUT: "scout"
};
const Car = {
    TYPE_RCXD: "rcxd"
};
const Turret = {
    TYPE_SAM: "sam",
    TYPE_SENTRY: "sentry",
    TYPE_REMOTE: "remote_sentry",
    TYPE_BALLISTIC: "advanced_sentry",
    TYPE_GRENADE: "grenade_sentry"
};
const Crate = {
    CRATE_STORE: "CRATE_STORE",
    CRATE_AMMO: "CRATE_AMMO",
    CRATE_DECOY: "CRATE_DECOY",
    CRATE_KILLSTREAK: "CRATE_KILLSTREAK",
    CRATE_WEAPON: "CRATE_WEAPON",
    CRATE_PERK: "CRATE_PERK",
    CRATE_BOMB: "CRATE_BOMB",
    CRATE_BOMB_GENERIC: "CRATE_BOMB_GENERIC",
    CRATE_SHARD: "CRATE_SHARD",
    CRATE_XP: "CRATE_XP",
    CRATE_LIFE: "CRATE_LIFE"
};
const Zombie = {
    TYPE_DEFAULT: "zombie_default",
    TYPE_FAT: "zombie_fat",
    TYPE_EXPLODER: "zombie_exploder",
    TYPE_EXPLODER_BOSS: "zombie_exploder_boss",
    TYPE_SPITTER: "zombie_spitter",
    TYPE_SPITTER_BOSS: "zombie_spitter_boss",
    TYPE_SPRINTER: "zombie_sprinter",
    TYPE_SPRINTER_BOSS: "zombie_sprinter_boss"
};
const Heroes = {
    XWILKINX: "HERO_XWILKINX",
    MOUSSA: "HERO_MOUSSA",
    OBSV32: "HERO_OBSV32",
    GHOSTMIAMI: "HERO_GHOSTMIAMI",
    ARI: "HERO_ARI",
    AETIC: "HERO_AETIC",
    CARMELFIRE: "HERO_CARMELFIRE",
    VALIANT25: "HERO_VALIANT25",
    KARAMBITGUY: "HERO_KARAMBITGUY",
    CHRIST: "HERO_CHRIST",
    TWOPLAYER: "HERO_TWOPLAYER",
    ERIC: "HERO_ERIC",
    SANTA: "HERO_SANTA",
    ALEXSEI: "HERO_ALEXSEI",
    UPBOSS: "HERO_UPBOSS"
};
const SurvivalEnemyType = {    
    HELI_MH6: "HELI_MH6",
    HELI_COBRA: "HELI_COBRA",
    HELI_PAVE_LOW: "HELI_PAVE_LOW",
    HELI_SCOUT: "HELI_SCOUT",
    HELI_OSPREY: "HELI_OSPREY",
    HELI_CHOPPER_GUNNER: "HELI_CHOPPER_GUNNER",
    HELI_SNIPER: "HELI_SNIPER",
    HELI_DRAGONFIRE: "HELI_DRAGONFIRE",
    HELI_REAPER: "HELI_REAPER",
    INFESTOR: "INFESTOR",
    INFESTOR_KING: "INFESTOR_KING",
    ZOMBIE_DEFAULT: "ZOMBIE_DEFAULT",
    ZOMBIE_MELEE: "ZOMBIE_MELEE",
    ZOMBIE_SPRINTER: "ZOMBIE_SPRINTER",
    ZOMBIE_SPRINTER_MELEE: "ZOMBIE_SPRINTER_MELEE",
    ZOMBIE_SPRINTER_BOSS: "ZOMBIE_SPRINTER_BOSS",
    ZOMBIE_FLAMETHROWER: "ZOMBIE_FLAMETHROWER",
    ZOMBIE_FAT: "ZOMBIE_FAT",
    ZOMBIE_FAT_THUMPER: "ZOMBIE_FAT_THUMPER",
    ZOMBIE_JUGGERNAUT: "ZOMBIE_JUGGERNAUT",
    ZOMBIE_JUGGERNAUT_MERC: "ZOMBIE_JUGGERNAUT_MERC",
    JUGGERNAUT_MINIGUN: "JUGGERNAUT_MINIGUN",
    ZOMBIE_EXPLODER: "ZOMBIE_EXPLODER",
    ZOMBIE_EXPLODER_BOSS: "ZOMBIE_EXPLODER_BOSS",
    ZOMBIE_SPITTER: "ZOMBIE_SPITTER",
    ZOMBIE_SPITTER_BOSS: "ZOMBIE_SPITTER_BOSS",
    ZOMBIE_RPG: "ZOMBIE_RPG",
    ZOMBIE_RIFLE: "ZOMBIE_RIFLE",
    ZOMBIE_SHIELD: "ZOMBIE_SHIELD",
    OPFOR_PISTOL: "OPFOR_PISTOL",
    OPFOR_BASIC: "OPFOR_BASIC",
    OPFOR_HEAVY: "OPFOR_HEAVY",
    OPFOR_RPG: "OPFOR_RPG",
    RUS_BASIC: "RUS_BASIC",
    RUS_HARD: "RUS_HARD",
    RUS_EXPERT: "RUS_EXPERT",
    RUS_SNIPER: "RUS_SNIPER",
    RUS_CLAYMORE: "RUS_CLAYMORE",
    RUS_MERC: "RUS_MERC",
    RUS_CROSSBOW: "RUS_CROSSBOW",
    RUS_RPG: "RUS_RPG",
    RUS_SHIELD: "RUS_SHIELD",
    RUS_MELEE: "RUS_MELEE",
    RUS_C4: "RUS_C4",
    RUS_EXPLOSIVES: "RUS_EXPLOSIVES",
    USMC_BASIC: "USMC_BASIC",
    USMC_HARD: "USMC_HARD",
    USMC_HEAVY: "USMC_HEAVY",
    USMC_SNIPER: "USMC_SNIPER",
    GSG9_BASIC: "GSG9_BASIC",
    GSG9_HARD: "GSG9_HARD",
    GSG9_HEAVY: "GSG9_HEAVY",
    GSG9_SNIPER: "GSG9_SNIPER",
    GIGN_BASIC: "GIGN_BASIC",
    GIGN_HARD: "GIGN_HARD",
    GIGN_HEAVY: "GIGN_HEAVY",
    GIGN_SNIPER: "GIGN_SNIPER",
    JUGGERNAUT: "JUGGERNAUT",
    JUGGERNAUT_JAVELIN: "JUGGERNAUT_JAVELIN",
    JUGGERNAUT_COMMANDER: "JUGGERNAUT_COMMANDER",
    JUGGERNAUT_MERC: "JUGGERNAUT_MERC",
    TURRET_SENTRY: "TURRET_SENTRY",
    TURRET_SAM: "TURRET_SAM",
    HOSTAGE: "HOSTAGE",
    VIP: "VIP"
};
const SurvivalEnemyInfo = {
    HERO_XWILKINX: {
        pawnName: "Wilkin",
        health: 400,
        weapons: ["sr25"],
        mods: {
            base: Mods.BASE_RANGE,
            barrel: Mods.BARREL_LASER,
            ammo: Mods.AMMO_HOLLOW_POINT
        },
        secondaryWeapons: ["m202"],
        equipment: "frag",
        damageMultipliers: {
            2: 0.5,
            1: 0.1,
            3: 0.5,
            4: 0.5
        },
        perks: [
            Perks.PERK_PLAYER_SPECIALIST,
            Perks.PERK_WEAPON_RELOAD
        ],
        eyewear: Character.EYEWEAR_GOGGLES_ORANGE,
        facewear: Character.FACEWEAR_MASK,
        heads: [Character.HEAD_NIGHTVISION],
        body: Character.BODY_USMC_KEVLAR,
        botSkill: BotSkill.SKILL_GOD,
        killReward: 2000,
        bHero: true
    },
    HERO_ARI: {
        pawnName: "Ari",
        health: 400,
        damageMultipliers: {
            2: 1,
            1: 0.5,
            3: 1
        },
        weapons: ["pgm"],
        mods: {
            base: Mods.BASE_RANGE,
            barrel: Mods.BARREL_ACCELERATOR,
            ammo: Mods.AMMO_HIGH_CALIBER
        },
        secondaryWeapons: ["fal"],
        equipment: "knife",
        perks: [
            Perks.PERK_PLAYER_ANTI_SNIPER
        ],
        faces: [Character.FACE_FEMALE],
        heads: [Character.HEAD_RUS_TOQUE],
        body: Character.BODY_GIGN_STANDARD,
        hair: Character.HAIR_PONYTAIL,
        hairColour: Character.HAIR_COLOUR_BLUE,
        botSkill: BotSkill.SKILL_INSANE,
        killReward: 1000,
        bHero: true
    },
    HERO_AETIC: {
        pawnName: "AETIC",
        health: 400,
        damageMultipliers: {
            2: 1,
            1: 0.5,
            3: 1
        },
        weapons: ["railgun"],
        secondaryWeapons: ["melee_katana"],
        equipment: "kevlar",
        perks: [
            Perks.PERK_PLAYER_HELMET,
            Perks.PERK_PLAYER_SITREP,
            Perks.PERK_WEAPON_RELOAD
        ],
        faces: [Character.FACE_DEFAULT],
        heads: [Character.HEAD_AETIC],
        body: Character.BODY_USMC_KEVLAR,
        hair: Character.HAIR_SHORT,
        botSkill: BotSkill.SKILL_INSANE,
        killReward: 1000,
        bHero: true
    },
    HERO_MOUSSA: {
        pawnName: "Moussa",
        health: 400,
        damageMultipliers: {
            2: 1,
            1: 0.5,
            3: 1
        },
        weapons: ["acr"],
        mods: {
            base: Mods.BASE_RANGE,
            barrel: Mods.BARREL_LASER,
            ammo: Mods.AMMO_FMJ
        },
        secondaryWeapons: ["l115a3"],
        equipment: "knife",
        perks: [
            Perks.PERK_PLAYER_LIGHTWEIGHT
        ],
        heads: [Character.HEAD_GSG9_HELMET_2],
        body: Character.BODY_GSG9_HEAVY,
        botSkill: BotSkill.SKILL_INSANE,
        killReward: 1000,
        bHero: true
    },
    HERO_OBSV32: {
        pawnName: "Peacekeeper",
        health: 400,
        damageMultipliers: {
            2: 1,
            1: 0.5,
            3: 1
        },
        weapons: ["m60e4"],
        mods: {
            base: Mods.BASE_RAPID_FIRE,
            barrel: Mods.BARREL_GRIP,
            ammo: Mods.AMMO_HOLLOW_POINT
        },
        perks: [
            Perks.PERK_PLAYER_SPECIALIST,
            Perks.PERK_WEAPON_AGGRESSION
        ],
        secondaryWeapons: ["mgl"],
        equipment: "semtex",
        heads: [Character.HEAD_RADIO],
        body: Character.BODY_GIGN_HEAVY,
        botSkill: BotSkill.SKILL_INSANE,
        killReward: 1000,
        bHero: true
    },
    HERO_GHOSTMIAMI: {
        pawnName: "GhostMiami",
        health: 400,
        damageMultipliers: {
            2: 1,
            1: 0.5,
            3: 1
        },
        weapons: ["l115a3"],
        mods: {
            base: Mods.BASE_RANGE,
            barrel: Mods.BARREL_LASER,
            ammo: Mods.AMMO_HOLLOW_POINT
        },
        secondaryWeapons: ["tazer"],
        equipment: "stim",
        perks: [
            Perks.PERK_PLAYER_COLD_BLOODED,
            Perks.PERK_WEAPON_RECON
        ],
        heads: [Character.HEAD_MILITIA_SNIPER],
        body: Character.BODY_MILITIA_STANDARD,
        botSkill: BotSkill.SKILL_INSANE,
        killReward: 1000,
        hair: Character.HAIR_LONG,
        hairColour: Character.HAIR_COLOUR_BLONDE,
        bHero: true
    },
    HERO_CARMELFIRE: {
        pawnName: "Carmelfire",
        health: 400,
        damageMultipliers: {
            2: 1,
            1: 0.5,
            3: 1
        },
        weapons: ["hk416"],
        mods: {
            base: Mods.BASE_RANGE,
            barrel: Mods.BARREL_LASER,
            ammo: Mods.AMMO_FMJ
        },
        secondaryWeapons: ["p320"],
        equipment: "c4",
        perks: [
            Perks.PERK_PLAYER_MARTYRDOM,
            Perks.PERK_WEAPON_VAMPIRE
        ],
        heads: [Character.HEAD_GSG9_HELMET],
        body: Character.BODY_GSG9_RECON,
        botSkill: BotSkill.SKILL_INSANE,
        killReward: 1000,
        bHero: true
    },
    HERO_VALIANT25: {
        pawnName: "Touhou Hijack",
        health: 400,
        damageMultipliers: {
            2: 1,
            1: 0.5,
            3: 1
        },
        weapons: ["famas"],
        secondaryWeapons: ["mgl"],
        mods: {
            base: Mods.BASE_FULL_AUTO,
            barrel: Mods.BARREL_LASER,
            ammo: Mods.AMMO_FMJ
        },
        equipment: "semtex",
        heads: [Character.HEAD_RADIO],
        body: Character.BODY_GSG9_HEAVY,
        botSkill: BotSkill.SKILL_INSANE,
        killReward: 1000,
        bHero: true
    },
    HERO_KARAMBITGUY: {
        pawnName: "Yung Wulf",
        health: 400,
        damageMultipliers: {
            2: 1,
            1: 0.5,
            3: 1
        },
        weapons: ["fal"],
        secondaryWeapons: ["rhino"],
        mods: {
            base: Mods.BASE_RANGE,
            barrel: Mods.BARREL_LASER,
            ammo: Mods.AMMO_FMJ
        },
        equipment: "knife",
        perks: [
            Perks.PERK_PLAYER_JUGGERNAUT,
            Perks.PERK_WEAPON_VAMPIRE
        ],
        heads: [Character.HEAD_RUS_HAT],
        body: Character.BODY_RUS_STANDARD,
        botSkill: BotSkill.SKILL_INSANE,
        killReward: 1000,
        bHero: true
    },
    HERO_CHRIST: {
        pawnName: "Wild West Wrangler",
        health: 400,
        damageMultipliers: {
            2: 1,
            1: 0.5,
            3: 1
        },
        weapons: ["db"],
        secondaryWeapons: ["magnum"],
        mods: {
            base: Mods.BASE_SPEED,
            barrel: Mods.BARREL_LASER,
            ammo: Mods.AMMO_FMJ
        },
        equipment: "smoke",
        heads: [Character.HEAD_MILITIA_BANDANA],
        body: Character.BODY_MILITIA_STANDARD,
        botSkill: BotSkill.SKILL_INSANE,
        killReward: 1000,
        bHero: true
    },
    HERO_TWOPLAYER: {
        pawnName: "Arachnid",
        health: 400,
        damageMultipliers: {
            2: 1,
            1: 0.5,
            3: 1
        },
        weapons: ["intervention"],
        secondaryWeapons: ["deagle"],
        mods: {
            base: Mods.BASE_RANGE,
            barrel: Mods.BARREL_ACCELERATOR,
            ammo: Mods.AMMO_HIGH_CALIBER
        },
        perks: [
            Perks.PERK_PLAYER_JUGGERNAUT,
            Perks.PERK_WEAPON_VAMPIRE
        ],
        equipment: "stim",
        heads: [Character.HEAD_NONE],
        faces: [Character.FACE_DEFAULT],
        facewear: Character.FACEWEAR_TWOPLAYER,
        hair: Character.HAIR_STYLED,
        hairColour: Character.HAIR_COLOUR_BROWN,
        beard: Character.BEARD_NONE,
        body: Character.BODY_GSG9_STANDARD,
        botSkill: BotSkill.SKILL_INSANE,
        killReward: 1000,
        bHero: true
    },
    HERO_ERIC: {
        pawnName: "Eric",
        health: 400,
        damageMultipliers: {
            2: 1,
            1: 0.5,
            3: 1
        },
        weapons: ["sr25"],
        secondaryWeapons: ["stinger"],
        mods: {
            base: Mods.BASE_RANGE,
            barrel: Mods.BARREL_LASER,
            ammo: Mods.AMMO_FMJ
        },
        equipment: "trophy",
        heads: [Character.HEAD_ERIC_HELMET],
        faces: [Character.FACE_DEFAULT],
        perks: [
            Perks.PERK_PLAYER_SPECIALIST,
            Perks.PERK_WEAPON_SHRAPNEL
        ],
        hair: Character.HAIR_SHORT,
        hairColour: Character.HAIR_COLOUR_BLACK,
        beard: Character.BEARD_STUBBLE,
        body: Character.BODY_JUGGERNAUT,
        botSkill: BotSkill.SKILL_INSANE,
        killReward: 1000,
        bHero: true
    },
    HERO_SANTA: {
        pawnName: "Santa Claus",
        health: 400,
        weapons: ["melee_shovel"],
        mods: {
            ammo: Mods.AMMO_LAUNCHER_RADIUS
        },
        secondaryWeapons: ["none"],
        equipment: "tac_insert",
        damageMultipliers: {
            2: 1,
            1: 0.5,
            3: 1
        },
        perks: [
            Perks.PERK_PLAYER_JUGGERNAUT,
            Perks.PERK_WEAPON_VAMPIRE
        ],
        eyewear: Character.EYEWEAR_GOGGLES_BLACK,
        facewear: Character.FACEWEAR_NONE,
        hair: Character.HAIR_LONG,
        hairColour: Character.HAIR_COLOUR_WHITE,
        beard: Character.BEARD_FULL,
        heads: [Character.HEAD_SANTA_HAT],
        body: Character.BODY_ZOMBIE_FAT,
        botSkill: BotSkill.SKILL_INSANE,
        killReward: 1000,
        bHero: true
    },
    HERO_ALEXSEI: {
        pawnName: "Alexsei",
        health: 400,
        damageMultipliers: {
            2: 1,
            1: 0.5,
            3: 1
        },
        weapons: ["ak47"],
        secondaryWeapons: ["rpg"],
        mods: {
            base: Mods.BASE_RANGE,
            barrel: Mods.BARREL_LASER,
            ammo: Mods.AMMO_HOLLOW_POINT
        },
        melee: "melee_katana",
        perks: [
            Perks.PERK_PLAYER_NINJA,
            Perks.PERK_WEAPON_SHRAPNEL
        ],
        equipment: "napalm",
        heads: [Character.HEAD_RUS_HELMET],
        faces: [Character.FACE_DEFAULT],
        eyewear: Character.EYEWEAR_GOGGLES_RED,
        facewear: Character.FACEWEAR_SCARF_SPETSNAZ,
        hair: Character.HAIR_SHORT,
        hairColour: Character.HAIR_COLOUR_BROWN,
        beard: Character.BEARD_NONE,
        body: Character.BODY_JUGGERNAUT,
        voice: "ru",
        botSkill: BotSkill.SKILL_INSANE,
        killReward: 1000,
        bHero: true
    },
    HERO_UPBOSS: {
        pawnName: "UPBoss111",
        health: 400,
        damageMultipliers: {
            2: 1,
            1: 0.5,
            3: 1
        },
        weapons: ["ultimax"],
        secondaryWeapons: ["l115a3"],
        mods: {
            base: Mods.BASE_RANGE,
            barrel: Mods.BARREL_GRIP,
            ammo: Mods.AMMO_HOLLOW_POINT
        },
        equipment: "stim",
        heads: [Character.HEAD_NONE],
        faces: [Character.FACE_DEFAULT],
        perks: [
            Perks.PERK_PLAYER_SPECIALIST,
            Perks.PERK_WEAPON_VAMPIRE
        ],
        eyewear: Character.EYEWEAR_GOGGLES_GREEN,
        facewear: Character.FACEWEAR_GAITER,
        hair: Character.HAIR_SHORT,
        hairColour: Character.HAIR_COLOUR_BLACK,
        beard: Character.BEARD_NONE,
        body: Character.BODY_GIGN_PARA,
        botSkill: BotSkill.SKILL_INSANE,
        killReward: 1000,
        bHero: true
    },
    TURRET_SENTRY: {
        type: "turret",
        turretType: Turret.TYPE_SENTRY,
        killReward: 100
    },
    TURRET_SAM: {
        type: "turret",
        turretType: Turret.TYPE_SAM,
        killReward: 100
    },
    HELI_MH6: {
        type: "helicopter",
        helicopterType: Helicopter.TYPE_MH6_ATTACK,
        killReward: 250
    },
    HELI_MH6_UPGRADED: {
        type: "helicopter",
        helicopterType: Helicopter.TYPE_MH6_GRENADE,
        killReward: 500
    },
    HELI_COBRA: {
        type: "helicopter",
        helicopterType: Helicopter.TYPE_COBRA,
        killReward: 500
    },
    HELI_COBRA_UPGRADED: {
        type: "helicopter",
        helicopterType: Helicopter.TYPE_COBRA_CONTROLLABLE,
        killReward: 500
    },
    HELI_PAVE_LOW: {
        type: "helicopter",
        helicopterType: Helicopter.TYPE_PAVE_LOW,
        killReward: 1000
    },
    HELI_SCOUT: {
        type: "helicopter",
        helicopterType: Helicopter.TYPE_SCOUT,
        killReward: 500
    },
    HELI_OSPREY: {
        type: "helicopter",
        helicopterType: Helicopter.TYPE_OSPREY,
        killReward: 1000
    },
    HELI_CHOPPER_GUNNER: {
        type: "helicopter",
        helicopterType: Helicopter.TYPE_BLACKHAWK,
        killReward: 500
    },
    HELI_SNIPER: {
        type: "helicopter",
        helicopterType: Helicopter.TYPE_BLACKHAWK_SNIPER,
        killReward: 500
    },
    HELI_DRAGONFIRE: {
        type: "helicopter",
        helicopterType: Helicopter.TYPE_DRAGONFIRE,
        killReward: 200
    },
    HELI_REAPER: {
        type: "helicopter",
        helicopterType: Helicopter.TYPE_REAPER,
        killReward: 1000
    },
    INFESTOR: {
        type: "infestor",
        infestorType: "infestor",
        health: 300,
        botSkill: BotSkill.SKILL_HARD,
        killReward: 150,
        damageMultipliers: {
            1: 0.75,
            4: 0.5
        }
    },
    INFESTOR_KING: {
        type: "infestor",
        infestorType: "infestor_king",
        health: 1000,
        botSkill: BotSkill.SKILL_INSANE,
        killReward: 500,
        damageMultipliers: {
            1: 0.1,
            4: 0.5
        }
    },
    ZOMBIE_DEFAULT: {
        zombieType: Zombie.TYPE_DEFAULT,
        health: 80,
        weapons: ["zombie"],
        faces: [Character.FACE_ZOMBIE_1, Character.FACE_ZOMBIE_2, Character.FACE_ZOMBIE_3, Character.FACE_ZOMBIE_4],
        heads: [Character.HEAD_NONE],
        body: Character.BODY_ZOMBIE,
        botSkill: BotSkill.SKILL_NORMAL,
        killReward: 50,
        baseSpeedMultiplier: 0.6
    },
    ZOMBIE_MELEE: {
        zombieType: Zombie.TYPE_DEFAULT,
        health: 100,
        weapons: ["melee_machete", "melee_bowie", "melee_hatchet"],
        faces: [Character.FACE_ZOMBIE_1, Character.FACE_ZOMBIE_2, Character.FACE_ZOMBIE_3, Character.FACE_ZOMBIE_4],
        heads: [Character.HEAD_NONE],
        body: Character.BODY_ZOMBIE,
        botSkill: BotSkill.SKILL_INSANE,
        killReward: 100,
        baseSpeedMultiplier: 0.6
    },
    ZOMBIE_FLAMETHROWER: {
        zombieType: Zombie.TYPE_FAT,
        health: 150,
        weapons: ["flamethrower"],
        faces: [Character.FACE_ZOMBIE_FAT],
        heads: [Character.HEAD_NONE],
        body: Character.BODY_VIP,
        botSkill: BotSkill.SKILL_INSANE,
        killReward: 100,
        baseSpeedMultiplier: 0.6,
        damageMultipliers: {
            4: 0.5
        }
    },
    ZOMBIE_SPRINTER: {
        zombieType: Zombie.TYPE_SPRINTER,
        health: 50,
        weapons: ["zombie_sprinter"],
        faces: [Character.FACE_ZOMBIE_SPRINTER],
        heads: [Character.HEAD_NONE],
        body: Character.BODY_ZOMBIE_SPRINTER,
        botSkill: BotSkill.SKILL_HARD,
        killReward: 100
    },
    ZOMBIE_SPRINTER_MELEE: {
        zombieType: Zombie.TYPE_SPRINTER,
        health: 50,
        weapons: ["melee_knife", "melee_bowie", "melee_machete", "melee_katana"],
        faces: [Character.FACE_ZOMBIE_SPRINTER],
        heads: [Character.HEAD_NONE],
        body: Character.BODY_ZOMBIE_SPRINTER,
        botSkill: BotSkill.SKILL_INSANE,
        killReward: 200
    },
    ZOMBIE_SPRINTER_BOSS: {
        zombieType: Zombie.TYPE_SPRINTER_BOSS,
        health: 350,
        weapons: ["zombie_sprinter_boss"],
        faces: [Character.FACE_ZOMBIE_SPRINTER_BOSS],
        heads: [Character.HEAD_NONE],
        body: Character.BODY_ZOMBIE_SPRINTER_BOSS,
        botSkill: BotSkill.SKILL_INSANE,
        killReward: 200
    },
    ZOMBIE_FAT: {
        zombieType: Zombie.TYPE_FAT,
        health: 700,
        weapons: ["zombie_fat", "melee_machete", "melee_hatchet", "melee_shovel"],
        faces: [Character.FACE_ZOMBIE_FAT],
        heads: [Character.HEAD_NONE],
        body: Character.BODY_ZOMBIE_FAT,
        botSkill: BotSkill.SKILL_NORMAL,
        killReward: 200,
        baseSpeedMultiplier: 0.5,
        damageMultipliers: {
            2: 0.5
        }
    },
    ZOMBIE_FAT_THUMPER: {
        zombieType: Zombie.TYPE_FAT,
        health: 700,
        weapons: ["thumper", "m1014", "m3", "jackhammer"],
        faces: [Character.FACE_ZOMBIE_FAT],
        heads: [Character.HEAD_NONE],
        body: Character.BODY_ZOMBIE_FAT,
        botSkill: BotSkill.SKILL_INSANE,
        killReward: 200,
        baseSpeedMultiplier: 0.5,
        damageMultipliers: {
            2: 0.5
        }
    },
    ZOMBIE_JUGGERNAUT: {
        zombieType: Zombie.TYPE_FAT,
        health: 500,
        weapons: ["striker", "spas12", "m240", "m82"],
        secondaryWeapons: ["smaw"],
        equipment: "knife",
        heads: [Character.HEAD_NONE],
        faces: [Character.FACE_ZOMBIE_FAT],
        body: Character.BODY_JUGGERNAUT,
        botSkill: BotSkill.SKILL_INSANE,
        damageMultipliers: {
            1: 0.35,
            2: 0.5,
            4: 0.5
        },
        killReward: 500,
        maxSpeed: 150
    },
    ZOMBIE_EXPLODER: {
        zombieType: Zombie.TYPE_EXPLODER,
        health: 120,
        weapons: ["zombie_exploder"],
        faces: [Character.FACE_ZOMBIE_EXPLODER],
        heads: [Character.HEAD_NONE],
        body: Character.BODY_ZOMBIE_EXPLODER,
        botSkill: BotSkill.SKILL_INSANE,
        killReward: 100
    },
    ZOMBIE_EXPLODER_BOSS: {
        zombieType: Zombie.TYPE_EXPLODER_BOSS,
        health: 300,
        weapons: ["zombie_exploder_boss"],
        faces: [Character.FACE_ZOMBIE_EXPLODER],
        heads: [Character.HEAD_NONE],
        body: Character.BODY_ZOMBIE_EXPLODER_BOSS,
        botSkill: BotSkill.SKILL_INSANE,
        killReward: 250
    },
    ZOMBIE_SPITTER: {
        zombieType: Zombie.TYPE_SPITTER,
        health: 80,
        weapons: ["zombie_spitter"],
        faces: [Character.FACE_ZOMBIE_SPITTER],
        heads: [Character.HEAD_NONE],
        body: Character.BODY_ZOMBIE_SPITTER,
        botSkill: BotSkill.SKILL_NORMAL,
        killReward: 100
    },
    ZOMBIE_SPITTER_BOSS: {
        zombieType: Zombie.TYPE_SPITTER_BOSS,
        health: 400,
        weapons: ["zombie_spitter_boss"],
        faces: [Character.FACE_ZOMBIE_SPITTER_BOSS],
        heads: [Character.HEAD_NONE],
        body: Character.BODY_ZOMBIE_SPITTER_BOSS,
        botSkill: BotSkill.SKILL_HARD,
        killReward: 250,
        baseSpeedMultiplier: 0.7
    },
    ZOMBIE_RPG: {
        zombieType: Zombie.TYPE_DEFAULT,
        health: 100,
        weapons: ["rpg"],
        faces: [Character.FACE_ZOMBIE_1, Character.FACE_ZOMBIE_2, Character.FACE_ZOMBIE_3, Character.FACE_ZOMBIE_4],
        heads: [Character.HEAD_NONE],
        body: Character.BODY_ZOMBIE,
        botSkill: BotSkill.SKILL_INSANE,
        killReward: 100,
        baseSpeedMultiplier: 0.6
    },
    ZOMBIE_RIFLE: {
        zombieType: Zombie.TYPE_DEFAULT,
        health: 100,
        weapons: ["ak47", "rpk", "dragunov"],
        faces: [Character.FACE_ZOMBIE_1, Character.FACE_ZOMBIE_2, Character.FACE_ZOMBIE_3, Character.FACE_ZOMBIE_4],
        heads: [Character.HEAD_NONE],
        body: Character.BODY_ZOMBIE,
        botSkill: BotSkill.SKILL_NORMAL,
        killReward: 100,
        baseSpeedMultiplier: 0.6
    },
    ZOMBIE_SHIELD: {
        zombieType: Zombie.TYPE_DEFAULT,
        health: 200,
        weapons: ["riot_shield"],
        faces: [Character.FACE_ZOMBIE_1, Character.FACE_ZOMBIE_2, Character.FACE_ZOMBIE_3, Character.FACE_ZOMBIE_4],
        heads: [Character.HEAD_RIOT_HELMET],
        body: Character.BODY_ZOMBIE,
        botSkill: BotSkill.SKILL_INSANE,
        killReward: 200,
        baseSpeedMultiplier: 0.6
    },
    OPFOR_PISTOL: {
        health: 50,
        weapons: ["g17", "m9"],
        heads: [Character.HEAD_OPFOR_SCARF],
        body: Character.BODY_OPFOR_STANDARD,
        botSkill: BotSkill.SKILL_EASY,
        killReward: 50
    },
    OPFOR_BASIC: {
        health: 50,
        weapons: ["mp5", "mpa57", "ak74u", "g18", "mac11", "uzi"],
        heads: [Character.HEAD_OPFOR_SCARF],
        body: Character.BODY_OPFOR_RECON,
        botSkill: BotSkill.SKILL_EASY,
        killReward: 50
    },
    OPFOR_HEAVY: {
        health: 100,
        weapons: ["mg4", "rpk", "ak47", "m47", "m1014"],
        heads: [Character.HEAD_OPFOR_HELMET, Character.HEAD_OPFOR_HELMET_2],
        body: Character.BODY_OPFOR_HEAVY,
        botSkill: BotSkill.SKILL_NORMAL,
        killReward: 100
    },
    OPFOR_RPG: {
        health: 100,
        weapons: ["rpg"],
        heads: [Character.HEAD_OPFOR_COMMANDER],
        body: Character.BODY_OPFOR_ROCKETIER,
        botSkill: BotSkill.SKILL_INSANE,
        killReward: 200
    },
    RUS_BASIC: {
        health: 100,
        weapons: ["fiveseven", "fmg9", "mp9", "ak74u", "mp5", "uzi", "micro_uzi"],
        heads: [Character.HEAD_RUS_TOQUE],
        body: Character.BODY_RUS_STANDARD,
        botSkill: BotSkill.SKILL_EASY,
        killReward: 50
    },
    RUS_HARD: {
        health: 125,
        weapons: ["mp7", "ak47", "tar21", "pecheneg", "qbb95", "bizon", "m240"],
        heads: [Character.HEAD_RUS_MASK],
        body: Character.BODY_RUS_RECON,
        botSkill: BotSkill.SKILL_NORMAL,
        killReward: 100
    },
    RUS_EXPERT: {
        health: 150,
        weapons: ["scarh", "hk416", "aughbar", "msg90", "samr", "m16a4", "ak47", "hamr", "acr", "aug", "fal", "lvoa"],
        equipment: "stun",
        heads: [Character.HEAD_RUS_HELMET],
        body: Character.BODY_RUS_HEAVY,
        botSkill: BotSkill.SKILL_HARD,
        killReward: 150
    },
    RUS_SNIPER: {
        health: 100,
        weapons: ["m40a3"],
        heads: [Character.HEAD_RUS_RECON],
        facewear: Character.FACEWEAR_MASK,
        body: Character.BODY_RUS_PARA,
        botSkill: BotSkill.SKILL_INSANE,
        killReward: 200
    },
    RUS_CLAYMORE: {
        health: 100,
        weapons: ["usp45"],
        equipment: "claymore",
        heads: [Character.HEAD_RUS_SCARF],
        body: Character.BODY_RUS_STANDARD,
        botSkill: BotSkill.SKILL_HARD,
        killReward: 150
    },
    RUS_MERC: {
        health: 200,
        weapons: ["g36c", "an94", "pdr", "sg550", "sr25", "ultimax", "ak47", "rsass", "lvoa", "par4"],
        heads: [Character.HEAD_ALTYN_HELMET],
        facewear: Character.FACEWEAR_MASK,
        body: Character.BODY_RUS_HEAVY,
        botSkill: BotSkill.SKILL_INSANE,
        killReward: 200
    },
    RUS_CROSSBOW: {
        health: 200,
        weapons: ["crossbow"],
        heads: [Character.HEAD_BALLISTIC_MASK_BLACK],
        facewear: Character.FACEWEAR_MASK,
        body: Character.BODY_RUS_KEVLAR,
        botSkill: BotSkill.SKILL_INSANE,
        killReward: 200
    },
    RUS_RPG: {
        health: 200,
        weapons: ["rpg", "m202", "matador"],
        heads: [Character.HEAD_RUS_BERET],
        facewear: Character.FACEWEAR_BALACLAVA,
        body: Character.BODY_RUS_ROCKETIER,
        botSkill: BotSkill.SKILL_INSANE,
        killReward: 200
    },
    RUS_SHIELD: {
        health: 100,
        weapons: ["riot_shield"],
        heads: [Character.HEAD_RIOT_HELMET],
        facewear: Character.FACEWEAR_MASK,
        body: Character.BODY_RUS_STANDARD,
        botSkill: BotSkill.SKILL_INSANE,
        killReward: 200,
        damageMultipliers: {
            4: 0.5
        }
    },
    RUS_MELEE: {
        health: 300,
        weapons: ["melee_machete"],
        secondaryWeapons: ["melee_machete"],
        heads: [Character.HEAD_BALLISTIC_MASK_WHITE],
        facewear: Character.FACEWEAR_MASK,
        body: Character.BODY_RUS_BARE,
        botSkill: BotSkill.SKILL_INSANE,
        killReward: 200
    },
    RUS_C4: {
        health: 100,
        weapons: ["none"],
        heads: [Character.HEAD_NONE],
        facewear: Character.FACEWEAR_BALACLAVA,
        body: Character.BODY_C4_VEST,
        botSkill: BotSkill.SKILL_INSANE,
        killReward: 200
    },
    JUGGERNAUT_COMMANDER: {
        health: 600,
        weapons: ["r700", "msg90", "msr", "deagle", "magnum", "m82", "rhino", "intervention", "g3"],
        secondaryWeapons: ["smaw"],
        equipment: "flashbang",
        heads: [Character.HEAD_RUS_BERET],
        body: Character.BODY_JUGGERNAUT,
        botSkill: BotSkill.SKILL_INSANE,
        damageMultipliers: {
            1: 0.35,
            2: 0.5,
            4: 0.5
        },
        killReward: 500,
        maxSpeed: 150
    },
    RUS_EXPLOSIVES: {
        health: 200,
        weapons: ["xm25", "m202", "matador"],
        equipment: "frag",
        heads: [Character.HEAD_JUGGERNAUT_HELMET],
        body: Character.BODY_RUS_STANDARD,
        botSkill: BotSkill.SKILL_INSANE,
        killReward: 200
    },
    JUGGERNAUT: {
        health: 500,
        weapons: ["m60e4", "m1014", "m3", "l115a3", "m240"],
        secondaryWeapons: ["smaw"],
        equipment: "frag",
        heads: [Character.HEAD_JUGGERNAUT_HELMET],
        body: Character.BODY_JUGGERNAUT,
        botSkill: BotSkill.SKILL_HARD,
        damageMultipliers: {
            1: 0.35,
            2: 0.5,
            4: 0.5
        },
        killReward: 500,
        maxSpeed: 140
    },
    JUGGERNAUT_MERC: {
        health: 500,
        weapons: ["m60e4", "m249", "m240", "jackhammer", "m1014", "m3", "l115a3", "sr25", "rpk", "lvoa", "ameli"],
        secondaryWeapons: ["riot_shield"],
        equipment: "frag",
        heads: [Character.HEAD_JUGGERNAUT_HELMET],
        body: Character.BODY_JUGGERNAUT,
        botSkill: BotSkill.SKILL_INSANE,
        damageMultipliers: {
            1: 0.5,
            2: 1,
            4: 0.5
        },
        killReward: 1000,
        maxSpeed: 180
    },
    JUGGERNAUT_MINIGUN: {
        health: 500,
        weapons: ["minigun"],
        equipment: "frag",
        heads: [Character.HEAD_JUGGERNAUT_HELMET],
        body: Character.BODY_JUGGERNAUT,
        botSkill: BotSkill.SKILL_INSANE,
        damageMultipliers: {
            1: 0.5,
            2: 1,
            4: 0.5
        },
        killReward: 2000,
        maxSpeed: 180
    },
    ZOMBIE_JUGGERNAUT_MERC: {
        zombieType: Zombie.TYPE_FAT,
        health: 500,
        weapons: ["melee_katana"],
        heads: [Character.HEAD_NONE],
        faces: [Character.FACE_ZOMBIE_FAT],
        body: Character.BODY_JUGGERNAUT,
        botSkill: BotSkill.SKILL_INSANE,
        damageMultipliers: {
            1: 0.5,
            2: 1,
            4: 0.5
        },
        killReward: 1000,
        maxSpeed: 220
    },
    JUGGERNAUT_JAVELIN: {
        health: 500,
        weapons: ["javelin"],
        equipment: "trophy",
        heads: [Character.HEAD_JUGGERNAUT_HELMET],
        body: Character.BODY_JUGGERNAUT,
        botSkill: BotSkill.SKILL_HARD,
        damageMultipliers: {
            1: 0.35,
            2: 0.5,
            4: 0.5
        },
        killReward: 500,
        maxSpeed: 140
    },
    USMC_BASIC: {
        health: 100,
        weapons: ["m16a4", "m4a1", "tar21", "mp5", "m9", "p320", "m1911", "m93r"],
        heads: [Character.HEAD_USMC_HELMET_TACTICAL],
        body: Character.BODY_USMC_STANDARD,
        botSkill: BotSkill.SKILL_NORMAL,
        killReward: 100
    },
    USMC_HARD: {
        health: 150,
        weapons: ["acr", "samr", "sr25", "honeybadger", "arp"],
        heads: [Character.HEAD_RADIO],
        body: Character.BODY_USMC_RECON,
        botSkill: BotSkill.SKILL_HARD,
        killReward: 200
    },
    USMC_HEAVY: {
        health: 300,
        weapons: ["m249", "m60e4", "m1014", "ksg"],
        heads: [Character.HEAD_USMC_HELMET_TACTICAL],
        body: Character.BODY_USMC_HEAVY,
        botSkill: BotSkill.SKILL_HARD,
        killReward: 200
    },
    USMC_SNIPER: {
        health: 100,
        weapons: ["r700", "m40a3"],
        heads: [Character.HEAD_USMC_GHILLIE],
        body: Character.BODY_USMC_GHILLIE,
        botSkill: BotSkill.SKILL_INSANE,
        facewear: Character.FACEWEAR_MASK,
        killReward: 200
    },
    GSG9_BASIC: {
        health: 100,
        weapons: ["mp5", "ump45", "fiveseven", "g17", "usp45", "m9", "p320"],
        heads: [Character.HEAD_GSG9_HELMET, Character.HEAD_GSG9_HELMET_2, Character.HEAD_GSG9_HELMET_3],
        body: Character.BODY_GSG9_STANDARD,
        botSkill: BotSkill.SKILL_NORMAL,
        killReward: 100
    },
    GSG9_HARD: {
        health: 150,
        weapons: ["mp7", "evo3", "p90", "hk416", "scarh", "aug", "fal"],
        heads: [Character.HEAD_GSG9_HELMET, Character.HEAD_GSG9_HELMET_2, Character.HEAD_GSG9_HELMET_3],
        body: Character.BODY_GSG9_TACTICAL,
        botSkill: BotSkill.SKILL_HARD,
        killReward: 200
    },
    GSG9_HEAVY: {
        health: 300,
        weapons: ["m249", "m60e4", "m1014", "ksg"],
        heads: [Character.HEAD_GSG9_HELMET, Character.HEAD_GSG9_HELMET_2, Character.HEAD_GSG9_HELMET_3],
        body: Character.BODY_GSG9_HEAVY,
        botSkill: BotSkill.SKILL_HARD,
        killReward: 200
    },
    GSG9_SNIPER: {
        health: 100,
        weapons: ["msg90", "r700", "msr"],
        heads: [Character.HEAD_RADIO],
        body: Character.BODY_GSG9_RECON,
        botSkill: BotSkill.SKILL_INSANE,
        killReward: 200
    },
    GIGN_BASIC: {
        health: 100,
        weapons: ["mp5", "ump45", "fiveseven", "g17", "usp45", "m9", "p320", "famas"],
        heads: [Character.HEAD_GIGN_HELMET, Character.HEAD_GIGN_HELMET_2],
        body: Character.BODY_GIGN_STANDARD,
        botSkill: BotSkill.SKILL_NORMAL,
        killReward: 100
    },
    GIGN_HARD: {
        health: 150,
        weapons: ["mp7", "evo3", "p90", "hk416", "scarh", "aug", "fal", "famas"],
        heads: [Character.HEAD_GIGN_HELMET, Character.HEAD_GIGN_HELMET_2],
        body: Character.BODY_GIGN_TACTICAL,
        botSkill: BotSkill.SKILL_HARD,
        killReward: 200
    },
    GIGN_HEAVY: {
        health: 300,
        weapons: ["m249", "m60e4", "m1014", "spas12", "hamr"],
        heads: [Character.HEAD_GIGN_HELMET, Character.HEAD_GIGN_HELMET_2],
        body: Character.BODY_GIGN_HEAVY,
        botSkill: BotSkill.SKILL_HARD,
        killReward: 200
    },
    GIGN_SNIPER: {
        health: 100,
        weapons: ["l115a3", "r700", "msr"],
        heads: [Character.HEAD_RADIO],
        body: Character.BODY_GIGN_RECON,
        botSkill: BotSkill.SKILL_INSANE,
        killReward: 200
    },
    HOSTAGE: {
        health: 200,
        weapons: ["none"],
        heads: [Character.HEAD_NONE],
        body: Character.BODY_HOSTAGE,
        botSkill: BotSkill.SKILL_NORMAL,
        killReward: 0,
        bRegenHealth: true,
        bHostage: true,
        maxSpeed: 200
    },
    VIP: {
        pawnName: "VIP",
        health: 200,
        weapons: ["p320"],
        heads: [Character.HEAD_NONE],
        hairColour: Character.HAIR_COLOUR_BROWN,
        body: Character.BODY_VIP,
        botSkill: BotSkill.SKILL_HARD,
        killReward: 200,
        bRegenHealth: true
    },
    DUMMY: {
        pawnName: "Dummy",
        health: 200,
        weapons: ["m40a3", "m4a1", "mp5", "m9"],
        heads: [Character.HEAD_BALLISTIC_MASK_WHITE],
        body: Character.BODY_MILITIA_STANDARD,
        botSkill: BotSkill.SKILL_HARD,
        killReward: 100,
        bRegenHealth: true,
        bDummy: true
    },
    DUMMY_KEVLAR: {
        pawnName: "Dummy (Kevlar)",
        health: 200,
        weapons: ["m40a3", "m4a1", "mp5", "m9"],
        equipment: "kevlar",
        heads: [Character.HEAD_BALLISTIC_MASK_WHITE],
        body: Character.BODY_MILITIA_KEVLAR,
        botSkill: BotSkill.SKILL_HARD,
        killReward: 100,
        bRegenHealth: true,
        bDummy: true
    },
    DUMMY_JUGGERNAUT: {
        pawnName: "Dummy (Juggernaut)",
        health: 300,
        perks: [
            Perks.PERK_PLAYER_JUGGERNAUT
        ],
        weapons: ["m40a3", "m4a1", "mp5", "m9"],
        heads: [Character.HEAD_BALLISTIC_MASK_WHITE],
        body: Character.BODY_MILITIA_STANDARD,
        botSkill: BotSkill.SKILL_HARD,
        killReward: 100,
        bRegenHealth: true,
        bDummy: true
    },
    DUMMY_HELMET: {
        pawnName: "Dummy (Hard-Headed)",
        health: 200,
        perks: [
            Perks.PERK_PLAYER_HELMET
        ],
        weapons: ["m40a3", "m4a1", "mp5", "m9"],
        heads: [Character.HEAD_BALLISTIC_MASK_WHITE],
        body: Character.BODY_MILITIA_STANDARD,
        botSkill: BotSkill.SKILL_HARD,
        killReward: 100,
        bRegenHealth: true,
        bDummy: true
    },
    DUMMY_SPECIALIST: {
        pawnName: "Dummy (Specialist)",
        health: 200,
        perks: [
            Perks.PERK_PLAYER_SPECIALIST
        ],
        weapons: ["m40a3", "m4a1", "mp5", "m9"],
        heads: [Character.HEAD_BALLISTIC_MASK_WHITE],
        body: Character.BODY_MILITIA_STANDARD,
        botSkill: BotSkill.SKILL_HARD,
        killReward: 100,
        bRegenHealth: true,
        bDummy: true
    },
    DUMMY_ANTI_SNIPER: {
        pawnName: "Dummy (Anti-Sniper)",
        health: 200,
        perks: [
            Perks.PERK_PLAYER_ANTI_SNIPER
        ],
        weapons: ["m40a3", "m4a1", "mp5", "m9"],
        heads: [Character.HEAD_BALLISTIC_MASK_WHITE],
        body: Character.BODY_MILITIA_STANDARD,
        botSkill: BotSkill.SKILL_HARD,
        killReward: 100,
        bRegenHealth: true,
        bDummy: true
    },
    DUMMY_SITREP: {
        pawnName: "Dummy (SitRep)",
        health: 200,
        perks: [
            Perks.PERK_PLAYER_SITREP
        ],
        weapons: ["m40a3", "m4a1", "mp5", "m9"],
        heads: [Character.HEAD_BALLISTIC_MASK_WHITE],
        body: Character.BODY_MILITIA_STANDARD,
        botSkill: BotSkill.SKILL_HARD,
        killReward: 100,
        bRegenHealth: true,
        bDummy: true
    },
    DUMMY_SHIELD: {
        pawnName: "Dummy (Shield)",
        health: 200,
        weapons: ["riot_shield"],
        heads: [Character.HEAD_BALLISTIC_MASK_WHITE],
        body: Character.BODY_MILITIA_STANDARD,
        botSkill: BotSkill.SKILL_HARD,
        killReward: 100,
        bRegenHealth: true,
        bDummy: true
    }
};
const FeedItem = {
    TYPE_MESSAGE: "message",
    TYPE_KILL: "kill",
    TYPE_CHAT: "chat"
};
const Killstreaks = {
    TYPE_ASSAULT: "TYPE_ASSAULT",
    TYPE_SUPPORT: "TYPE_SUPPORT",
    TYPE_PERKS: "TYPE_SPECIALIST",
    KILLSTREAK_SAM_TURRET_PLACE: "sam_turret_place",
    KILLSTREAK_SENTRY_GUN_PLACE: "sentry_gun_place",
    KILLSTREAK_UAV: "uav",
    KILLSTREAK_UAV_SUPPORT: "uav_support",
    KILLSTREAK_COUNTER_UAV: "counter_uav",
    KILLSTREAK_CARE_PACKAGE: "care_package",
    KILLSTREAK_SUPPORT_AIRDROP: "support_airdrop",
    KILLSTREAK_WEAPON: "weapon",
    KILLSTREAK_WEAPON_M202: "weapon_m202",
    KILLSTREAK_WEAPON_MINIGUN: "weapon_minigun",
    KILLSTREAK_PERK: "perk",
    KILLSTREAK_AMMO: "ammo",
    KILLSTREAK_SENTRY_GUN: "sentry_gun",
    KILLSTREAK_SAM_TURRET: "sam_turret",
    KILLSTREAK_HELLFIRE: "hellfire",
    KILLSTREAK_RCXD: "rcxd",
    KILLSTREAK_AIRSTRIKE: "airstrike",
    KILLSTREAK_BOMBARDMENT: "airstrike_survival",
    KILLSTREAK_NAPALM: "airstrike_napalm",
    KILLSTREAK_REMOTE_TURRET: "remote_turret_place",
    KILLSTREAK_ADVANCED_TURRET: "advanced_turret_place",
    KILLSTREAK_GRENADE_TURRET: "grenade_turret_place",
    KILLSTREAK_COBRA: "cobra",
    KILLSTREAK_COBRA_CONTROLLABLE: "cobra_controllable",
    KILLSTREAK_MH6: "mh6",
    KILLSTREAK_MH6_GRENADE: "mh6_grenade",
    KILLSTREAK_PAVE_LOW: "pave_low",
    KILLSTREAK_CHOPPER_GUNNER: "chopper_gunner",
    KILLSTREAK_REAPER: "reaper",
    KILLSTREAK_DRAGONFIRE: "dragonfire",
    KILLSTREAK_SCOUT: "scout",
    KILLSTREAK_DECOY: "decoy",
    KILLSTREAK_HELI_SNIPER: "heli_sniper",
    KILLSTREAK_STEALTH_BOMBER: "stealth_bomber",
    KILLSTREAK_EMP: "emp",
    KILLSTREAK_ESCORT_AIRDROP: "escort_airdrop",
    KILLSTREAK_ESCORT_AIRDROP_SURVIVAL: "escort_airdrop_survival",
    KILLSTREAK_DEADSWITCH: "deadswitch",
    KILLSTREAK_JUGGERNAUT: "juggernaut",
    KILLSTREAK_JUGGERNAUT_RECON: "juggernaut_recon",
    KILLSTREAK_JUGGERNAUT_USE: "juggernaut_use",
    KILLSTREAK_JUGGERNAUT_RECON_USE: "juggernaut_recon_use",
};
const CollisionGroups = { 
    PAWN: Math.pow(2, 0),
    PAWN_AIR: Math.pow(2, 1),
    GROUND: Math.pow(2, 2),
    PROJECTILE: Math.pow(2, 3),
    PROJECTILE_AIR: Math.pow(2, 4),
    PLATFORM: Math.pow(2, 5),
    SHIELD: Math.pow(2, 6),
    DRONE: Math.pow(2, 7),
    FLAME: Math.pow(2, 8),
    CAR: Math.pow(2, 9)
};

class GameInstance
{
    init(_data, _onEventFunc, _p2)
    {
        this.log("Initialize");
        this.p2 = _p2;
        if (!this.p2)
        {
            console.warn("Invalid p2 reference", this.p2);
        }
        this.onEventFunc = _onEventFunc;
        this.lobbyId = _data["lobbyId"];
        this.data = _data["data"];
        this.batchData = [];
        var fps = 30; //Tick rate
        var updateTimer = 1; //Number of frames before update is sent to clients
        var fpsMult = fps / 60; //FPS multiplier
        this.localData = {
            settings: {
                fps: fps,
                fps_mult: fpsMult,
                fixed_timestep: 1 / fps,
                fixed_timestep_mult: fpsMult,
                update_counter_max: updateTimer
            },
            bPaused: false,
            bDebug: _data.settings["bDebug"] == true,
            bMultiplayer: _data["bMultiplayer"] ? true : false,
            bPrivate: _data["bPrivate"] ? true : false,
            bPerformanceMode: _data["bPerformanceMode"] ? true : false,
            bFriendlyFire: !_data["bSurvival"] && _data["gameModeId"] != GameMode.SANDBOX,
            bSurvival: _data["bSurvival"] ? true : false,
            bUseMoneyMultiplier: false,
            bRanked: _data["bRanked"] ? true : false,
            bOperation: _data["bOperation"] ? true : false,
            bModeGame: _data["bRanked"] && !_data["bOperation"] && _data["gameModeId"] != GameMode.BATTLEZONE,
            bSandbox: _data["gameModeId"] == GameMode.SANDBOX,
            bBattlezone: _data["gameModeId"] == GameMode.BATTLEZONE,
            bCustomGame: _data["bCustomGame"] ? true : false,
            bKillstreaks: _data.settings["bKillstreaks"] ? true : false,
            bAutoBalance: false, //_data.settings["bAutoBalance"] != null ? _data.settings["bAutoBalance"] : false,
            bAllowTeamSwitch: _data.settings["bAllowTeamSwitch"] != null ? _data.settings["bAllowTeamSwitch"] : true,
            bDroppedWeapons: _data.settings["bDroppedWeapons"] != null ? _data.settings["bDroppedWeapons"] : true,
            bNoSandbags: _data.settings["bNoSandbags"],
            factions: _data.settings["factions"],
            maxPlayers: _data["maxPlayers"],
            mapId: _data["mapId"],
            preGameTimer: _data.settings["preGameTimer"] !== undefined ? _data.settings["preGameTimer"] : 10,
            matchState: MatchState.STATE_PRE_GAME,
            playerStates: [],
            killstreaks: [],
            toRemove: [],
            objectsToUpdate: null,
            world: null,
            gameModeData: null
        };

        if (_data.settings.filterType == "random")
        {
            var worldTypes = [null, "dawn", "night"];
            _data.settings.filterType = worldTypes[this.Random(0, worldTypes.length - 1)];
        }

        //Adjust logic fps
        if (this.localData["bPerformanceMode"])
        {
            //this.setLogicFPS(30);
        }
        this.localData.settings.update_counter_max = Math.ceil(this.localData.settings.update_counter_max * this.localData.settings.fps_mult);
        console.log("GAME SETTINGS", this.localData.settings);

        //Initialize world
        this.createWorld();
        this.generateMapNodes();

        var localData = this.localData;

        //Initialize game mode
        var settings = _data["settings"];
        if (settings["bFriendlyFire"] !== undefined)
        {
            this.localData["bFriendlyFire"] = settings["bFriendlyFire"];
        }
        var gameModeData = {
            id: _data["gameModeId"],
            timeLimit: settings["timeLimit"] ? (settings["timeLimit"] * 60) : null,
            scoreLimit: settings["scoreLimit"],
            bUseRoundThreshold: settings["bUseRoundThreshold"],
            numRounds: settings["numRounds"],
            bAllowRespawns: settings["bAllowRespawns"],
            bNoClasses: settings["bNoClasses"],
            respawnTime: settings["respawnTime"] !== undefined ? settings["respawnTime"] : 3,
            bSpawnProtection: settings["bSpawnProtection"],
            bHardcore: settings["bHardcore"]
        };
        var map = this.getCurrentMapData();
        var operationData = _data.operation ? _data.operation.data : null;
        this.localData.gameModeData = gameModeData;
        switch (_data["gameModeId"])
        {
            case GameMode.INFECTED:
                gameModeData["survivorWeaponId"] = this.getRandomInfectedWeapon().id;
                var survivorEquipments = [
                    "frag",
                    "c4",
                    "claymore",
                    "betty"
                ];
                gameModeData["survivorEquipmentId"] = survivorEquipments[this.Random(0, survivorEquipments.length - 1)];
                gameModeData["infectedWeapon"] = {
                    id: "zombie_sprinter",
                    mods: {
                        base: Mods.BASE_RAPID_FIRE,
                        ammo: Mods.AMMO_FMJ
                    }
                };
                gameModeData["infectedEquipment"] = "tac_insert";
                gameModeData["infectedPerks"] = [
                    Perks.PERK_PLAYER_LIGHTWEIGHT,
                    Perks.PERK_PLAYER_JUGGERNAUT,
                    Perks.PERK_WEAPON_VAMPIRE
                ];
                break;

            case GameMode.GUN_GAME:
                gameModeData["killsPerGun"] = settings["killsPerGun"];
                gameModeData["weapons"] = [
                    {
                        id: this.RandomBoolean() ? "g17" : "m9"
                    },
                    {
                        id: this.RandomBoolean() ? "m1911" : "usp45"
                    },
                    {
                        id: this.RandomBoolean() ? "magnum" : "deagle"
                    },
                    {
                        id: this.RandomBoolean() ? "m93r" : "kard"
                    },
                    {
                        id: this.RandomBoolean() ? "g18" : "fmg9"
                    },
                    {
                        id: this.RandomBoolean() ? "mp5" : "mp7"
                    },
                    {
                        id: this.RandomBoolean() ? "ak74u" : "ump45"
                    },
                    {
                        id: this.RandomBoolean() ? "m4a1" : "ak47"
                    },
                    {
                        id: this.RandomBoolean() ? "famas" : "m16a4"
                    },                   
                    {
                        id: this.RandomBoolean() ? "r700" : "m40a3"
                    },
                    {
                        id: this.RandomBoolean() ? "rsass" : "sr25"
                    },
                    {
                        id: this.RandomBoolean() ? "m3" : "ksg"
                    },
                    {
                        id: this.RandomBoolean() ? "m1014" : "striker"
                    },
                    {
                        id: this.RandomBoolean() ? "m249" : "qbb95"
                    },
                    {
                        id: this.RandomBoolean() ? "m60e4" : "m240"
                    },
                    {
                        id: "thumper"
                    },
                    {
                        id: "rpg"
                    },
                    {
                        id: "riot_shield",
                        mods: {
                            base: Mods.BASE_SPEED
                        }
                    }
                ];
                if (settings["bReverse"])
                {
                    gameModeData["weapons"].reverse();
                }
                break;            

            case GameMode.TEAM_DEATHMATCH:
                gameModeData["scores"] = [0, 0];
                break;

            case GameMode.DOMINATION:
                gameModeData["scores"] = [0, 0];
                this.createFlagDomination(0, 5);
                this.createFlagDomination(1, 5);
                this.createFlagDomination(2, 5);
                break;

            case GameMode.CAPTURE_THE_FLAG:
                gameModeData["scores"] = [0, 0];
                this.createFlagCTF(0);
                this.createFlagCTF(1);
                break;

            case GameMode.DEFENDER:
                gameModeData["scores"] = [0, 0];
                gameModeData["flagTeam"] = null;
                this.createFlagDefender();
                break;

            case GameMode.DEMOLITION:
                gameModeData["round"] = 0;
                gameModeData["scores"] = [0, 0];
                gameModeData["scoreLimit"] = gameModeData["numRounds"];
                gameModeData["plantTime"] = this.localData.settings.fps * 3;
                gameModeData["defuseTime"] = this.localData.settings.fps * 6;
                gameModeData["bombTeam"] = 1;
                gameModeData["bBombPlanted"] = false;
                this.createBombCrate(gameModeData["bombTeam"]);
                gameModeData["bombTimerMax"] = settings["bombTimerMax"];
                break;

            case GameMode.HEADQUARTERS:
                gameModeData["round"] = 0;
                gameModeData["scores"] = [0, 0];
                gameModeData["hqTeam"] = null;
                this.createFlagDomination(1, 15);
                break;

            case GameMode.ASSASSINATION:
                gameModeData["round"] = 0;
                gameModeData["scores"] = [0, 0];
                gameModeData["scoreLimit"] = gameModeData["numRounds"];
                gameModeData["vipTeam"] = 0;
                break;

            case GameMode.RESCUE:
                gameModeData["round"] = 0;
                gameModeData["scores"] = [0, 0];
                gameModeData["scoreLimit"] = gameModeData["numRounds"];
                gameModeData["rescueTeam"] = 0;
                gameModeData["numHostages"] = 2;
                break;

            case GameMode.SURVIVAL_CHAOS:
                this.localData["bUseMoneyMultiplier"] = true;
                var weaponOffset = 100;
                var chaosWeapons = [
                    this.getWeaponData("magnum"),
                    this.getWeaponData("mp7"),
                    this.getWeaponData("m16a4"),
                    this.getWeaponData("m1014"),
                    this.getWeaponData("m40a3"),
                    this.getWeaponData("thumper", { ammo: 10 })
                ];
                this.shuffleArray(chaosWeapons);
                for (var i = 0; i < 3; i++)
                {
                    this.createDroppedWeapon(this.getRandomUniqueId(), [(map.spawn_store[0] - weaponOffset) - (i * weaponOffset), map.spawn_store[1] - 50], 0, this.RandomBoolean() ? 1 : -1, {
                        weaponData: chaosWeapons[i]
                    });
                }
                for (var i = 0; i < 3; i++)
                {
                    this.createDroppedWeapon(this.getRandomUniqueId(), [(map.spawn_store[0] + weaponOffset) + (i * weaponOffset), map.spawn_store[1] - 50], 0, this.RandomBoolean() ? 1 : -1, {
                        weaponData: chaosWeapons[i + 3]
                    });
                }
                break;

            case GameMode.SURVIVAL_PRO:
                this.localData["bUseMoneyMultiplier"] = true;
                var weaponOffset = 100;
                var chaosWeapons = [
                    this.getWeaponData("rhino", { mods: { barrel: Mods.BARREL_LASER } }),
                    this.getWeaponData("bizon", { mods: { ammo: Mods.AMMO_FMJ } }),
                    this.getWeaponData("aug", { mods: { ammo: Mods.AMMO_HOLLOW_POINT } }),
                    this.getWeaponData("saiga12", { mods: { ammo: Mods.AMMO_EXTENDED } }),
                    this.getWeaponData("intervention", { mods: { base: Mods.BASE_DEADEYE, ammo: Mods.AMMO_PIERCING } }),
                    this.getWeaponData("rpg", { ammo: 10, mods: { base: Mods.BASE_SPEED } })
                ];
                this.shuffleArray(chaosWeapons);
                for (var i = 0; i < 3; i++)
                {
                    this.createDroppedWeapon(this.getRandomUniqueId(), [(map.spawn_store[0] - weaponOffset) - (i * weaponOffset), map.spawn_store[1] - 50], 0, this.RandomBoolean() ? 1 : -1, {
                        weaponData: chaosWeapons[i]
                    });
                }
                for (var i = 0; i < 3; i++)
                {
                    this.createDroppedWeapon(this.getRandomUniqueId(), [(map.spawn_store[0] + weaponOffset) + (i * weaponOffset), map.spawn_store[1] - 50], 0, this.RandomBoolean() ? 1 : -1, {
                        weaponData: chaosWeapons[i + 3]
                    });
                }
                break;

            case GameMode.SURVIVAL_BASIC:
            case GameMode.SURVIVAL_UNDEAD:
                this.localData["bUseMoneyMultiplier"] = true;
                break;

            case GameMode.SURVIVAL_STAKEOUT:
                //...
                break;

            case GameMode.OP_ELIMINATION:
                var numEnemies = 0;
                var enemies = _data.operation.data.enemies;
                for (var i = 0; i < enemies.length; i++)
                {
                    if (enemies[i].team != 0)
                    {
                        numEnemies++;
                    }
                }
                gameModeData["enemiesRemaining"] = numEnemies; //_data.operation.data.enemies.length;
                break;

            case GameMode.OP_HOSTAGE:
                if (operationData)
                {
                    gameModeData["numHostages"] = 0;
                    var objects = operationData.objects;
                    if (objects)
                    {
                        for (var i = 0; i < objects.length; i++)
                        {
                            var curObject = objects[i];
                            switch (curObject.type)
                            {
                                case "hostage":
                                    gameModeData["numHostages"]++;
                                    break;
                            }
                        }
                    }
                }
                else
                {
                    gameModeData["numHostages"] = settings["numHostages"];
                }
                gameModeData["rescueZone"] = settings["rescueZone"];
                gameModeData["bHostageHeli"] = !settings["bSpawnHostageHeli"];
                break;

            case GameMode.OP_BOMB:  
                if (operationData)
                {
                    gameModeData["numBombs"] = 0;
                    var objects = operationData.objects;
                    if (objects)
                    {
                        for (var i = 0; i < objects.length; i++)
                        {
                            var curObject = objects[i];
                            switch (curObject.type)
                            {
                                case "crate_bomb":
                                    gameModeData["numBombs"]++;
                                    break;
                            }
                        }
                    }
                }
                else
                {
                    gameModeData["numBombs"] = settings["numBombs"];
                }
                break;

            case GameMode.SANDBOX:                
                this.createStoreCrate(map.spawn_store[0], map.spawn_store[1] + 24);
                break;            
        }

        if (localData["bSurvival"])
        {
            gameModeData["wave"] = Settings.SURVIVAL_WAVE_START;
            gameModeData["enemies"] = 0;
            gameModeData["enemiesRemaining"] = 0;
            gameModeData["kills"] = 0;
            gameModeData["waveHeadshots"] = 0;
            gameModeData["waveMelees"] = 0;
            gameModeData["waveKills"] = 0;
            if (_data["gameModeId"] !== GameMode.SURVIVAL_STAKEOUT)
            {
                var map = this.getCurrentMapData();
                this.createStoreCrate(map.spawn_store[0], map.spawn_store[1] + 24);
            }
        }
        else if (localData["bOperation"])
        {
            localData["operation"] = {
                data: _data.operation.data,
                info: _data.operation.info
            };
            localData.difficulty = settings["difficulty"] != null ? settings["difficulty"] : 1;
        }
        else
        {
            gameModeData["bFirstBlood"] = false;
        }

        //localData["gameModeData"] = gameModeData;
        this.onEvent({
            eventId: GameServer.EVENT_GAME_INIT,
            mapId: _data["mapId"],
            gameModeId: _data["gameModeId"],
            settings: this.localData.settings,
            shared: this.data.shared
        });

        if (localData.gameModeData["timeLimit"])
        {
            localData["gameTimer"] = localData.gameModeData["timeLimit"];
            var timer_game = setInterval(this.onGameTimer.bind(this), 1000);
            localData["timer_game"] = timer_game;
        }

        var players = _data["players"];
        if (players)
        {
            for (var i = 0; i < players.length; i++)
            {
                this.addPlayer(players[i]);
            }
            switch (localData.gameModeData["id"])
            {
                case GameMode.DEATHMATCH:
                case GameMode.INFECTED:
                case GameMode.GUN_GAME:
                    var map = this.getCurrentMapData();
                    var spawns = this.clone(map.spawns);
                    this.shuffleArray(spawns);
                    for (i = 0; i < players.length; i++)
                    {
                        var curPlayer = players[i];
                        var char = this.getObjectById(curPlayer["id"]);
                        if (char)
                        {
                            var newSpawn = spawns[i];
                            if (newSpawn)
                            {
                                char.position[0] = newSpawn[0];
                                char.position[1] = newSpawn[1];
                            }
                        }
                    }
                    break;
            }
        }

        //After players are added
        switch (_data["gameModeId"])
        {
            case GameMode.BATTLEZONE:
                //Battlezone start crates
                for (var i = 0; i < 2; i++)
                {
                    var items = [];
                    for (var j = 0; j < 3; j++)
                    {
                        var randomWeapon = this.getRandomWeapon(true);
                        var weaponMods = this.getRandomMods(randomWeapon);
                        this.applyWeaponMods(randomWeapon, weaponMods);
                        if (randomWeapon["ammo"] != null && randomWeapon["magSize"] != null)
                        {
                            //randomWeapon["ammo"] = randomWeapon["magSize"];
                        }
                        items.push(randomWeapon);
                    }
                    this.createItemCrate(this.Random(500, map.width - 500), 800, null, items, Battlezone.TEAM_AIRDROPS);
                }
                this.createXPCrate(this.Random(500, map.width - 500), 800, 25000);
                this.createShardCrate(this.Random(500, map.width - 500), 800, 1);                
                break;
        }

        if (localData["preGameTimer"] > 0)
        {
            var timer_preGame = setInterval(this.onPreGameTimer.bind(this), 1000);
            localData["timer_preGame"] = timer_preGame;
            this.onEvent({
                eventId: GameServer.EVENT_GAME_UPDATE,
                gameModeData: localData["gameModeData"]
            });
            this.onEvent({
                eventId: GameServer.EVENT_GAME_PRE_TIMER,
                timer: localData["preGameTimer"]
            });
        }
        else
        {
            this.localData["matchState"] = MatchState.STATE_IN_PROGRESS;
            this.requestEvent({
                eventId: GameServer.EVENT_GAME_START,
                timer: localData["gameTimer"]
            });
            this.onEvent({
                eventId: GameServer.EVENT_GAME_UPDATE,
                gameModeData: localData["gameModeData"]
            });
        }
        if (localData["bSurvival"])
        {
            this.startWaveIntermission();
        }
        localData["updateCounter"] = 1;
        localData["updateCounterMax"] = localData["bMultiplayer"] ? this.localData.settings.update_counter_max : 1;
        localData["interval"] = setInterval(this.updateContainer.bind(this), 1000 / this.localData.settings.fps);

        if (gameModeData.round != null)
        {
            this.onRoundStart();
        }

        this.bInit = true;
    }

    setLogicFPS(_val)
    {
        this.localData.settings.fps = _val;
        this.localData.settings.fps_mult = _val / 60;
        this.localData.settings.fixed_timestep = 1 / _val;
        this.localData.settings.fixed_timestep_mult = _val / 60;
    }

    addPlayer(_data)
    {
        var curPlayer = _data;
        if (!curPlayer["id"])
        {
            console.warn("Invalid player id", curPlayer);
        }
        if (curPlayer["bBot"])
        {
            curPlayer["bAutoRespawn"] = true;
            curPlayer["desiredClassData"] = this.GetBotDesiredClassData(curPlayer["botSkill"]);
            curPlayer["desiredKillstreaks"] = this.GetBotDesiredKillstreaks(curPlayer["botSkill"]);
        }
        else
        {
            var sharedClasses = this.clone(this.getSharedData("classes"));
            if (curPlayer["classes"])
            {
                if (!curPlayer.bAdmin || 1)
                {
                    for (var i = 0; i < curPlayer.classes.length; i++)
                    {
                        let curClass = curPlayer.classes[i];
                        switch (curClass.primary.id)
                        {
                            case "railgun":
                            case "minigun":
                                console.warn("Invalid primary", curClass.primary.id);
                                curClass.primary.id = "m16a4";
                                break;
                        }
                        switch (curClass.secondary.id)
                        {
                            case "railgun":
                            case "minigun":
                                console.warn("Invalid secondary", curClass.secondary.id);
                                curClass.secondary.id = "m16a4";
                                break;
                        }
                    }
                }
                curPlayer["allClasses"] = sharedClasses.concat(this.clone(curPlayer["classes"]));
            }
            else
            {
                console.warn("Invalid classes reference", _data);
                curPlayer["allClasses"] = sharedClasses;                
            }
            curPlayer["desiredClassData"] = curPlayer["allClasses"][0];
            curPlayer["desiredKillstreaks"] = curPlayer["killstreaks"];
        }
        curPlayer["bRanked"] = true;

        //Create player state from data
        var curPlayerState = this.addPlayerState(curPlayer);
        curPlayerState["bHasPawn"] = false;
        curPlayerState["bCanRespawn"] = false;
        curPlayerState["bWaitingToRespawn"] = this.localData.gameModeData["bAllowRespawns"];
        curPlayerState["respawnTimer"] = -1;
        curPlayerState["bSpawnProtection"] = false;
        if (this.localData["bSandbox"])
        {
            curPlayerState["money"] = 1000000;
        }
        else if (this.localData["bSurvival"])
        {
            if (this.localData["bUseMoneyMultiplier"])
            {
                curPlayerState["money"] = Settings.SURVIVAL_MONEY_START;
                curPlayerState["moneyMultiplier"] = 1;
            }
        }
        else
        {
            if (this.localData.bOperation)
            {
                if (!this.localData.operation.data.bTutorial && this.localData.difficulty < 3)
                {
                    curPlayerState.killstreaks = [Killstreaks.KILLSTREAK_UAV];
                }
            }
            else
            {
                curPlayerState["killedBy"] = [];
            }
            switch (this.localData["gameModeData"]["id"])
            {
                case GameMode.BATTLEZONE:
                    curPlayerState["lives"] = 3;
                    curPlayerState["shards"] = 0;
                    curPlayerState["xp"] = 0;
                    break;

                case GameMode.INFECTED:
                    curPlayerState["bInfected"] = this.matchInProgress() || curPlayerState["team"] == 1;                    
                    break;

                case GameMode.GUN_GAME:
                    curPlayerState["gunIndex"] = 0;
                    curPlayerState["gunKills"] = 0;
                    break;                

                case GameMode.HEADQUARTERS:
                case GameMode.DOMINATION:
                    curPlayerState["captures"] = 0;
                    break;

                case GameMode.CAPTURE_THE_FLAG:
                    curPlayerState["captures"] = 0;
                    curPlayerState["returns"] = 0;
                    break;

                case GameMode.ASSASSINATION:
                case GameMode.RESCUE:
                case GameMode.DEFENDER:
                case GameMode.OP_HOSTAGE:
                    curPlayerState["score"] = 0;
                    break;

                case GameMode.DEMOLITION:
                    curPlayerState["plants"] = 0;
                    curPlayerState["defuses"] = 0;
                    break;

                case GameMode.OP_BOMB:
                    curPlayerState["plants"] = 0;
                    break;
            }
        }

        this.localData["playerStates"].push(curPlayerState);        

        this.requestEvent({
            eventId: GameServer.EVENT_PLAYER_JOIN,
            playerId: curPlayerState["id"],
            data: curPlayerState
        });
        if (this.matchInProgress())
        {            
            //Player entered mid-game
            if (curPlayerState["bInfected"])
            {
                this.makePlayerInfected(curPlayerState["id"]);
            }
            var ps = curPlayerState;
            ps["bHasPawn"] = false;
            if (this.localData.gameModeData["bAllowRespawns"])
            {
                ps["bCanRespawn"] = false;
                ps["bWaitingToRespawn"] = true;
                if (ps["respawnTimer"] <= 0)
                {
                    if (ps["timer_respawn"] == undefined)
                    {
                        ps["respawnTimer"] = this.localData.gameModeData["respawnTime"];
                        ps["timer_respawn"] = this.localData.settings.fps; //timer_respawn;
                    }
                    this.onEvent({
                        eventId: GameServer.EVENT_PLAYER_UPDATE,
                        playerId: ps["id"],
                        data: {
                            bCanRespawn: ps["bCanRespawn"],
                            bWaitingToRespawn: ps["bWaitingToRespawn"],
                            bHasPawn: ps["bHasPawn"],
                            respawnTimer: ps["respawnTimer"]
                        }
                    });
                }
            }
            else if (this.localData["bSurvival"])
            {
                var equipment = "frag";
                var equipmentAmmo = 2;
                this.requestEvent({
                    eventId: GameServer.EVENT_REQUEST_RANKED_CHARACTER,
                    playerId: ps["id"],
                    avatarData: ps.avatarData,
                    data: {
                        x: 0,
                        y: 0,
                        inventory: this.getSurvivalInventory(),
                        perks: [],
                        equipment: equipment,
                        equipmentAmmo: equipmentAmmo
                    }
                });
            }
            else
            {
                this.requestEvent({
                    eventId: GameServer.EVENT_REQUEST_RANKED_CHARACTER,
                    playerId: ps["id"],
                    avatarData: ps.avatarData,
                    data: {
                        x: 0,
                        y: 0,
                        inventory: [{ id: "m9" }],
                        perks: []
                    }
                });
            }
        }
        else
        {
            if (this.localData["bBattlezone"])
            {
                for (var i = 0; i < this.localData.playerStates.length; i++)
                {
                    var curPlayer = this.localData.playerStates[i];
                    this.onEvent({
                        eventId: GameServer.EVENT_PLAYER_UPDATE,
                        playerId: curPlayer.id,
                        data: {
                            shards: curPlayer.shards,
                            xp: curPlayer.xp,
                            lives: curPlayer.lives
                        }
                    });
                }
            }
            if (this.localData.gameModeData["bAllowRespawns"])
            {
                this.requestEvent({
                    eventId: GameServer.EVENT_PLAYER_RESPAWN,
                    playerId: curPlayer["id"]
                });
            }
        }
    }

    isTutorial()
    {
        if (this.localData.bOperation)
        {
            return this.localData.operation.data.bTutorial;
        }
        return false;
    }

    getSurvivalInventory()
    {
        switch (this.localData.gameModeData.id)
        {
            case GameMode.SURVIVAL_STAKEOUT:
                return [
                    {
                        id: "mp5",
                        ammo: 300
                    },
                    {
                        id: "m9",
                        ammo: 150
                    }
                ];
            default:
                return [
                    {
                        id: "m9",
                        ammo: 150
                    }
                ];                
        }        
    }

    setEndCallback(_func)
    {
        this.onEndCallback = _func;
    }

    onEvent(_data)
    {
        if (this.lobbyId)
        {
            _data["lobbyId"] = this.lobbyId;
        }
        /*
        var clientTime = _data["clientTime"];
        if (clientTime)
        {
            var delta = Date.now() - clientTime;
            _data["delta"] = delta;
        }
        */
        this.batchData.push(_data);
    }

    requestEvent(_data)
    {        
        if (_data)
        {
            var localData = this.localData;
            var eventId = _data["eventId"];
            switch (eventId)
            {
                case GameServer.EVENT_SANDBOX:
                    if (_data)
                    {
                        if (this.localData.bSandbox)
                        {
                            this.handleSandboxEvent(_data["data"]);
                        }
                    }
                    break;

                case GameServer.EVENT_SWITCH_TEAMS:
                    _data["bResult"] = this.switchTeam(_data.playerId);
                    break;

                case GameServer.EVENT_BATTLEZONE:
                    if (this.localData["bBattlezone"])
                    {
                        var ps = this.getPlayerStateById(_data["playerId"]);
                        if (ps)
                        {
                            switch (_data.data["type"])
                            {
                                case "respawn":
                                    ps["bHasPawn"] = true;
                                    ps.lives = 3; //Buy respawns
                                    this.onEvent({
                                        eventId: GameServer.EVENT_PLAYER_UPDATE,
                                        playerId: ps.id,
                                        data: {
                                            lives: ps.lives
                                        }
                                    });
                                    break;
                            }
                        }
                    }
                    break;

                case GameServer.EVENT_GAME_START:
                    //Special events
                    if (!this.localData.bCustomGame && !this.localData.bOperation && !this.localData.bSurvival)
                    {
                        var date = new Date();
                        var timeout = setTimeout(() =>
                        {
                            if (date.getMonth() == 11 && date.getDate() >= 25)
                            {
                                //Christmas
                                var randMax = date.getDate() == 25 ? 50 : 200;
                                if (this.Random(1, randMax) == 1)
                                {
                                    this.requestEvent({
                                        eventId: GameServer.EVENT_SANDBOX,
                                        data: {
                                            type: "christmas"
                                        }
                                    });
                                }
                            }
                            else if (date.getMonth() == 9 && date.getDate() == 31)
                            {
                                //Halloween
                                if (this.Random(1, 100) == 1)
                                {
                                    this.requestEvent({
                                        eventId: GameServer.EVENT_SANDBOX,
                                        data: {
                                            type: "halloween"
                                        }
                                    });
                                }
                            }
                        }, 3000);
                    }
                    //Op stuff
                    if (this.localData["bOperation"])
                    {
                        var players = localData["playerStates"];
                        var operationData = localData.operation.data;
                        var objects = operationData.objects;
                        if (objects)
                        {
                            for (var i = 0; i < objects.length; i++)
                            {
                                var curObj = objects[i];
                                var useId = curObj.id ? curObj.id : this.getRandomUniqueId();
                                switch (curObj["type"])
                                {
                                    case "spawner":
                                        this.createSpawner(curObj.position[0], curObj.position[1], { spawnerId: curObj.spawnerId, team: curObj.team });
                                        break;

                                    case "hostage":
                                        this.createSandboxUnit({
                                            unitId: SurvivalEnemyType.HOSTAGE,
                                            pos: curObj.position,
                                            team: curObj.team,
                                            health: curObj.health,
                                            pawnName: curObj.pawnName,
                                            heroId: curObj.heroId
                                        });
                                        break;

                                    case "arrow_marker":
                                        this.requestEvent({
                                            eventId: GameServer.EVENT_SPAWN_OBJECT,
                                            data: {
                                                id: this.getRandomUniqueId(),
                                                type: curObj.type,
                                                rotation: curObj.rotation,
                                                position: curObj.position
                                            }
                                        });
                                        break;

                                    case "helicopter":
                                        var heli = this.createHelicopter(curObj.position, curObj.team, curObj.heliData);
                                        if (curObj.heliData)
                                        {
                                            if (curObj.heliData.defendTimer !== undefined)
                                            {
                                                heli.data.dropTimerMax = this.localData.settings.fps * curObj.heliData.dropTimerMax;
                                            }
                                            if (curObj.heliData.defendTimer !== undefined)
                                            {
                                                heli.data.defendTimer = this.localData.settings.fps * curObj.heliData.defendTimer;
                                            }
                                        }
                                        if (curObj.team == 0)
                                        {
                                            heli.data.ammo = 0;
                                        }
                                        break;

                                    case "info":
                                        this.createInfo(curObj.position, curObj.messageData);                                        
                                        break;

                                    case "equipment":
                                        this.createEquipment(curObj.position, curObj.team, curObj.scale, null, this.getWeaponData(curObj.weaponId));
                                        break;

                                    case "destructableObject":
                                        switch (curObj["destructableType"])
                                        {
                                            case "box_small":
                                                this.createSmallBox(useId, curObj.position);
                                                break;

                                            case "box_large":
                                                this.createLargeBox(useId, curObj.position);
                                                break;
                                        }
                                        break;

                                    case "obstacle":
                                        this.createObstacle(curObj);
                                        break;

                                    case "droppedWeapon":
                                        var weaponData = this.getWeaponData(curObj["weaponId"], curObj["options"]);
                                        if (weaponData.mods)
                                        {
                                            this.applyWeaponMods(weaponData, weaponData.mods);
                                        }
                                        if (weaponData)
                                        {
                                            var dropped = this.createDroppedWeapon(useId, curObj.position, 0, 1, {
                                                weaponData: weaponData
                                            });
                                            if (curObj.bPersistant)
                                            {
                                                dropped.data.bPersistant = true;
                                            }
                                        }
                                        break;

                                    case "turret":
                                        this.createTurret(useId, curObj.position, curObj.scale, curObj.team, curObj.turretData);
                                        break;

                                    case "crate_ammo":
                                        this.createAmmoCrate(curObj.position[0], curObj.position[1], null, curObj.team ? curObj.team : 0);
                                        break;

                                    case "crate_bomb":
                                        this.createGenericBombCrate(curObj.id, curObj.position[0], curObj.position[1], curObj.team, curObj.interactTeam);
                                        break;

                                    case "crate_xp":
                                        this.createXPCrate(curObj.position[0], curObj.position[1], 5000);
                                        break;

                                    case "crate_shard":
                                        this.createShardCrate(curObj.position[0], curObj.position[1], 1);
                                        break;

                                    case "crate_store":
                                        this.createStoreCrate(curObj.position[0], curObj.position[1]);
                                        break;

                                    case "crate_item":
                                        if (curObj.items)
                                        {
                                            var items = [];
                                            for (var j = 0; j < curObj.items.length; j++)
                                            {
                                                var wpn = this.getWeaponData(curObj.items[j].id, curObj.items[j].options);
                                                this.applyWeaponMods(wpn, curObj.items[j].mods);
                                                items.push(wpn);
                                            }
                                        }
                                        else
                                        {
                                            items = [this.getWeaponData(curObj.itemId)];
                                        }
                                        this.createItemCrate(curObj.position[0], curObj.position[1], null, items, curObj.team ? curObj.team : 0);
                                        break;

                                    case "crate_killstreak":
                                        this.createKillstreakCrate(curObj.position[0], curObj.position[1], curObj.killstreakId, null, curObj.team ? curObj.team : 0);
                                        break;

                                    case "crate_perk":
                                        this.createPerkCrate(curObj.position[0], curObj.position[1], null, curObj.perkId, curObj.team ? curObj.team : 0);
                                        break;
                                }
                            }
                        }
                        var player = operationData.player;
                        for (var i = 0; i < players.length; i++)
                        {
                            var ps = players[i];
                            var maxEquipmentAmmo = 4;
                            if (this.localData["difficulty"] == 3)
                            {
                                maxEquipmentAmmo = 1;
                            }
                            this.requestEvent({
                                eventId: GameServer.EVENT_REQUEST_RANKED_CHARACTER,
                                playerId: ps["id"],
                                avatarData: ps.avatarData,
                                data: {
                                    x: player.position[0] + (i * 50),
                                    y: player.position[1],
                                    inventory: player.inventory,
                                    equipment: player.equipment,
                                    equipmentAmmo: Math.min(player.equipmentAmmo, maxEquipmentAmmo),
                                    perks: []
                                }
                            });
                        }
                        var enemies = operationData.enemies;
                        if (enemies)
                        {
                            var botSkill = 0;                            
                            for (var i = 0; i < enemies.length; i++)
                            {
                                switch (localData.difficulty)
                                {
                                    case 1:
                                        botSkill = 0;
                                        break;
                                    case 2:
                                        botSkill = 2;
                                        break;
                                    case 3:
                                        botSkill = 3;
                                        break;
                                }
                                var bZombie = false;
                                var enemy = this.clone(enemies[i]);
                                var enemyTeam = enemy.team != null ? enemy.team : 1;
                                var useId = enemy.id ? enemy.id : this.getRandomUniqueId();
                                switch (enemy.type)
                                {
                                    case "car":
                                        var car = this.createCar(enemy.position, enemyTeam, enemy);
                                        car.data.bBot = true;
                                        break;

                                    case "helicopter":
                                        var heli = this.createHelicopter(enemy.position, enemyTeam, {
                                            type: enemy.helicopterType,
                                            destination: enemy.destination ? enemy.destination : enemy.position
                                        });
                                        heli.data["health"] += 250 * botSkill;
                                        heli.data["maxHealth"] = heli.data.health;
                                        heli.data["maxRange"] += 300 * botSkill;
                                        heli.data["bControllable"] = false;
                                        heli.data["bBot"] = true;
                                        heli.data["bPlayerControlled"] = false;
                                        heli.data["bAirdrop"] = false;
                                        heli.data["bUnlimitedAmmo"] = true;
                                        break;

                                    case "turret":
                                        this.createTurret(useId, enemy.position, enemy.scale, enemy.team, enemy.turretData);
                                        break;

                                    case "infestor":
                                    case "character":
                                        if (enemy.team === 0)
                                        {
                                            botSkill++; //Operation allies
                                        }
                                        var enemyAI = {
                                            bLOS: true,
                                            bUseActivityTimer: false,
                                            bObjectiveTakesPriority: false,
                                            bIgnoreOutOfSight: true,
                                            bCanCamp: false,
                                            bCanInteract: false,
                                            hearRange: 1500 + (botSkill * 150),
                                            maxRange: 1200 + (botSkill * 250),
                                            bCanInvestigate: true
                                        };
                                        if (enemy.ai)
                                        {
                                            if (enemy.ai["bCanInvestigate"] != undefined)
                                            {
                                                enemyAI["bCanInvestigate"] = enemy.ai["bCanInvestigate"];
                                            }
                                            if (enemy.ai["bCampUntilLOS"] != undefined)
                                            {
                                                enemy.ai["bCamp"] = true;
                                                enemyAI["bCampUntilLOS"] = enemy.ai["bCampUntilLOS"];
                                            }
                                            if (enemy.ai["bCamp"] != undefined)
                                            {
                                                enemyAI["bCamp"] = enemy.ai["bCamp"];
                                                enemyAI["campPosition"] = this.clone(enemy.position);
                                            }
                                            if (enemy.ai["bCanInvestigate"] != undefined)
                                            {
                                                enemyAI["bCanInvestigate"] = enemy.ai["bCanInvestigate"];
                                            }
                                            if (enemy.ai["patrolPoints"] != undefined)
                                            {
                                                enemyAI["bPatrol"] = true;
                                                enemyAI["patrolPoints"] = this.clone(enemy.ai.patrolPoints);
                                            }
                                            if (enemy.ai["bDisabled"] != undefined)
                                            {
                                                enemyAI["bDisabled"] = enemy.ai["bDisabled"];
                                            }
                                            if (enemy.ai.bLOS != null)
                                            {
                                                enemyAI.bLOS = enemy.ai.bLOS;
                                            }
                                            if (enemy.ai.bStayPatrol != null)
                                            {
                                                enemyAI.bStayPatrol = enemy.ai.bStayPatrol;
                                            }
                                            enemyAI.bIgnoreOutOfSight = enemyAI.bLOS == true;
                                        }
                                        var enemyDamageMultipliers = null;
                                        if (enemy.heroId)
                                        {
                                            var heroData = SurvivalEnemyInfo[enemy.heroId];
                                            if (heroData)
                                            {
                                                var curWeapon = heroData.weapons[this.Random(0, heroData.weapons.length - 1)];
                                                var curWeaponData = this.getWeaponData(curWeapon);
                                                var inventory = [
                                                    {
                                                        id: curWeapon,
                                                        mods: heroData.bHero ? heroData.mods : this.getRandomMods(curWeaponData)
                                                    }
                                                ];
                                                if (heroData.secondaryWeapons)
                                                {
                                                    inventory.push(
                                                        { id: heroData.secondaryWeapons[this.Random(0, heroData.secondaryWeapons.length - 1)] }
                                                    );
                                                }
                                                var heroKeys = Object.keys(heroData);
                                                for (var j = 0; j < heroKeys.length; j++)
                                                {
                                                    enemy[heroKeys[j]] = heroData[heroKeys[j]];
                                                }
                                                enemy.inventory = inventory;
                                                enemy.health *= 2;                                                
                                                enemy.style = "hero";
                                                enemy.type = "character";
                                                enemyDamageMultipliers = enemy.damageMultipliers;
                                                if (this.localData.bOperation && enemy.team == 0)
                                                {
                                                     //Campaign allies
                                                    enemyDamageMultipliers[DamageType.DAMAGE_BULLET] = 0.15 + ((this.localData.difficulty - 1) * 0.05);
                                                    enemyDamageMultipliers[DamageType.DAMAGE_MELEE] = 0.4 + (this.localData.difficulty * 0.1);
                                                    enemyDamageMultipliers[DamageType.DAMAGE_EXPLOSIVE] = 0.4 + (this.localData.difficulty * 0.1);
                                                    enemyDamageMultipliers[DamageType.DAMAGE_FIRE] = 0.4 + (this.localData.difficulty * 0.1);
                                                    enemy.baseSpeedMultiplier = 0.5 + (this.localData.difficulty * 0.05);
                                                    enemy.regenAmount = 5;
                                                }                                                
                                            }
                                            else
                                            {
                                                console.warn("Invalid hero id:", enemy.heroId);
                                            }
                                        }
                                        else if (enemy.preset)
                                        {
                                            switch (enemy.preset)
                                            {
                                                case "infestor":
                                                    enemy.health = 500;
                                                    enemy.inventory = ["infestor"];
                                                    enemy.infestorType = "infestor";
                                                    break;

                                                case "infestor_king":
                                                    enemy.health = 2500;
                                                    enemy.inventory = ["infestor_king"];
                                                    enemy.infestorType = "infestor_king";
                                                    break;

                                                case "juggernaut":
                                                    enemy.style = "juggernaut";
                                                    enemy.maxSpeed = 150;
                                                    enemy.health = 1000;
                                                    enemyDamageMultipliers = {
                                                        1: 0.3,
                                                        2: 0.5
                                                    };
                                                    enemy.equipment = "frag";
                                                    break;

                                                case "militia_generic":
                                                    enemy.style = "militia_generic";
                                                    enemy.health = 200;
                                                    enemy.equipment = "frag";
                                                    break;

                                                case "militia_heavy":
                                                    enemy.style = "militia_heavy";
                                                    enemy.health = 500;
                                                    enemy.equipment = "frag";
                                                    break;

                                                case "opfor_generic":
                                                    enemy.style = "opfor_generic";
                                                    break;

                                                case "rus_elite":
                                                    enemy.style = "rus_generic";
                                                    enemy.health = 300;
                                                    enemy.equipment = "stun";
                                                    break;

                                                case "rus_rocketier":
                                                    enemy.style = "rus_rocketier";
                                                    enemy.health = 200;
                                                    enemy.equipment = "frag";
                                                    break;

                                                case "opfor_heavy":
                                                    enemy.style = "opfor_heavy";
                                                    enemy.health = 400;
                                                    enemy.equipment = "frag";
                                                    break;

                                                case "gign_generic":
                                                    enemy.style = "gign_generic";
                                                    enemy.health = 300;
                                                    enemy.equipment = "stun";
                                                    break;

                                                case "gign_sniper":
                                                    enemy.style = "gign_sniper";
                                                    enemy.health = 300;
                                                    enemy.equipment = "smoke";
                                                    break;

                                                case "un_generic":
                                                    enemy.style = "un_generic";
                                                    enemy.health = 300;
                                                    break;

                                                case "gsg9_generic":
                                                    enemy.style = "gsg9_generic";
                                                    enemy.health = 300;
                                                    enemy.equipment = "stun";
                                                    break;

                                                case "gsg9_heavy":
                                                    enemy.style = "gsg9_heavy";
                                                    enemy.health = 500;
                                                    enemy.equipment = "flashbang";
                                                    break;

                                                case "gsg9_sniper":
                                                    enemy.style = "gsg9_sniper";
                                                    enemy.health = 300;
                                                    enemy.equipment = "flashbang";
                                                    break;

                                                case "gsg9_commander":
                                                    enemy.style = "gsg9_commander";
                                                    enemy.health = 500;
                                                    break;

                                                case "usmc_sniper":
                                                    enemy.style = "usmc_sniper";
                                                    enemy.equipment = "smoke";
                                                    break;

                                                case "usmc_heavy":
                                                    enemy.style = "usmc_heavy";
                                                    enemy.health = 600;
                                                    enemy.equipment = "frag";
                                                    break;

                                                case "usmc_generic":
                                                    enemy.style = "usmc_generic";
                                                    enemy.health = 300;
                                                    enemy.equipment = "flashbang";
                                                    break;

                                                case "zombie_generic":
                                                    enemy.style = "zombie_generic";
                                                    enemy.health = 320;
                                                    break;

                                                case "zombie_sprinter":
                                                    enemy.style = "zombie_sprinter";
                                                    enemy.health = 150;
                                                    break;

                                                case "zombie_sprinter_boss":
                                                    enemy.style = "zombie_sprinter_boss";
                                                    enemy.health = 350;
                                                    break;

                                                case "zombie_fat":
                                                    enemy.style = "zombie_fat";
                                                    enemy.health = 1200;
                                                    enemy.maxSpeed = 120;
                                                    break;

                                                case "zombie_spitter":
                                                    enemy.style = "zombie_spitter";
                                                    enemy.health = 200;
                                                    break;

                                                case "zombie_exploder":
                                                    enemy.style = "zombie_exploder";
                                                    enemy.health = 400;
                                                    break;

                                                case "zombie_exploder_boss":
                                                    enemy.style = "zombie_exploder_boss";
                                                    enemy.health = 800;
                                                    break;

                                                case "zombie_spitter_boss":
                                                    enemy.style = "zombie_spitter_boss";
                                                    enemy.health = 600;
                                                    break;
                                            }
                                        }
                                        if (enemy.type == "infestor")
                                        {
                                            this.requestEvent({
                                                eventId: GameServer.EVENT_CREATE_INFESTOR,
                                                data:
                                                {
                                                    id: enemy.id ? enemy.id : this.getRandomUniqueId(),
                                                    x: enemy.position[0],
                                                    y: enemy.position[1],
                                                    team: enemyTeam,
                                                    infestorType: enemy.infestorType,
                                                    health: enemy.health,
                                                    botSkill: botSkill,
                                                    damageMultipliers: enemyDamageMultipliers,
                                                    ai: enemyAI
                                                }
                                            });
                                        }
                                        else if (enemy.type == "character")
                                        {
                                            var zombieType = null;
                                            switch (enemy.style)
                                            {
                                                case "hero":
                                                    enemyAvatarData = {
                                                        hairColour: enemy.hairColour ? enemy.hairColour : this.getRandomHairColour(),
                                                        hair: enemy.hair ? enemy.hair : (enemy.zombieType != undefined ? Character.HAIR_BALD : Character.HAIR_SHORT),
                                                        beard: enemy.beard ? enemy.beard : Character.BEARD_NONE,
                                                        face: enemy.faces ? enemy.faces[this.Random(0, enemy.faces.length - 1)] : undefined,
                                                        head: enemy.heads[this.Random(0, enemy.heads.length - 1)],
                                                        body: enemy.body,
                                                        facewear: enemy.facewear,
                                                        eyewear: enemy.eyewear
                                                    };
                                                    break;

                                                case "usmc_sniper":
                                                    enemyAvatarData = {
                                                        hairColour: Character.HAIR_COLOUR_BROWN,
                                                        hair: Character.HAIR_BUZZED,
                                                        beard: Character.BEARD_NONE,
                                                        face: Character.FACE_DEFAULT,
                                                        head: Character.HEAD_USMC_GHILLIE,
                                                        body: Character.BODY_USMC_GHILLIE,
                                                        facewear: Character.FACEWEAR_MASK
                                                    };
                                                    break;

                                                case "usmc_generic":
                                                    var heads = [
                                                        Character.HEAD_USMC_HELMET,
                                                        Character.HEAD_USMC_HELMET_TACTICAL
                                                    ];
                                                    enemyAvatarData = {
                                                        hairColour: Character.HAIR_COLOUR_BROWN,
                                                        hair: Character.HAIR_BUZZED,
                                                        beard: Character.BEARD_NONE,
                                                        face: Character.FACE_DEFAULT,
                                                        head: heads[this.Random(0, heads.length - 1)],
                                                        body: Character.BODY_USMC_STANDARD
                                                    };
                                                    break;

                                                case "usmc_heavy":
                                                    enemyAvatarData = {
                                                        hairColour: Character.HAIR_COLOUR_BROWN,
                                                        hair: Character.HAIR_BUZZED,
                                                        beard: Character.BEARD_NONE,
                                                        face: Character.FACE_DEFAULT,
                                                        head: Character.HEAD_USMC_SPEC_OPS,
                                                        body: Character.BODY_USMC_HEAVY
                                                    };
                                                    break;

                                                case "opfor_generic":
                                                    enemyAvatarData = {
                                                        hairColour: Character.HAIR_COLOUR_BLACK,
                                                        hair: Character.HAIR_SHORT,
                                                        beard: Character.BEARD_NONE,
                                                        face: Character.FACE_DEFAULT,
                                                        head: Character.HEAD_OPFOR_SCARF,
                                                        body: Character.BODY_OPFOR_STANDARD
                                                    };
                                                    break;

                                                case "opfor_sniper":
                                                    var enemyAvatarData = {
                                                        hairColour: Character.HAIR_COLOUR_BLACK,
                                                        hair: Character.HAIR_SHORT,
                                                        beard: Character.BEARD_NONE,
                                                        face: Character.FACE_DEFAULT,
                                                        head: Character.HEAD_RADIO,
                                                        body: Character.BODY_OPFOR_RECON,
                                                        facewear: Character.FACEWEAR_SCARF_OPFOR
                                                    };
                                                    break;

                                                case "opfor_heavy":
                                                    enemyAvatarData = {
                                                        hairColour: Character.HAIR_COLOUR_BLACK,
                                                        hair: Character.HAIR_SHORT,
                                                        beard: Character.BEARD_NONE,
                                                        face: Character.FACE_DEFAULT,
                                                        head: Character.HEAD_OPFOR_HELMET_2,
                                                        body: Character.BODY_OPFOR_HEAVY,
                                                        facewear: Character.FACEWEAR_SCARF_OPFOR
                                                    };
                                                    break;

                                                case "militia_generic":
                                                    enemyAvatarData = {
                                                        hairColour: Character.HAIR_COLOUR_BROWN,
                                                        hair: Character.HAIR_LONG,
                                                        beard: Character.BEARD_STUBBLE,
                                                        face: Character.FACE_DEFAULT,
                                                        head: Character.HEAD_MILITIA_BANDANA,
                                                        body: Character.BODY_MILITIA_STANDARD
                                                    };
                                                    break;

                                                case "militia_heavy":
                                                    enemyAvatarData = {
                                                        hairColour: Character.HAIR_COLOUR_BROWN,
                                                        hair: Character.HAIR_LONG,
                                                        beard: Character.BEARD_FULL,
                                                        face: Character.FACE_DEFAULT,
                                                        head: Character.HEAD_MILITIA_BANDANA,
                                                        body: Character.BODY_MILITIA_HEAVY
                                                    };
                                                    break;

                                                case "rus_generic":
                                                    enemyAvatarData = {
                                                        hairColour: Character.HAIR_COLOUR_BLACK,
                                                        hair: Character.HAIR_SHORT,
                                                        beard: Character.BEARD_STUBBLE,
                                                        face: Character.FACE_DEFAULT,
                                                        head: Character.HEAD_NONE,
                                                        facewear: Character.FACEWEAR_MASK,
                                                        body: Character.BODY_RUS_STANDARD
                                                    };
                                                    break;

                                                case "rus_rocketier":
                                                    enemyAvatarData = {
                                                        hairColour: Character.HAIR_COLOUR_BLACK,
                                                        hair: Character.HAIR_SHORT,
                                                        beard: Character.BEARD_STUBBLE,
                                                        face: Character.FACE_DEFAULT,
                                                        head: Character.HEAD_RUS_HELMET,
                                                        body: Character.BODY_RUS_ROCKETIER
                                                    };
                                                    break;

                                                case "rus_heavy":
                                                    enemyAvatarData = {
                                                        hairColour: Character.HAIR_COLOUR_BLACK,
                                                        hair: Character.HAIR_SHORT,
                                                        beard: Character.BEARD_NONE,
                                                        face: Character.FACE_DEFAULT,
                                                        head: Character.HEAD_RUS_HELMET,
                                                        body: Character.BODY_RUS_HEAVY
                                                    };
                                                    break;

                                                case "rus_sniper":
                                                    var enemyAvatarData = {
                                                        hairColour: Character.HAIR_COLOUR_BLACK,
                                                        hair: Character.HAIR_SHORT,
                                                        beard: Character.BEARD_NONE,
                                                        face: Character.FACE_DEFAULT,
                                                        head: Character.HEAD_RADIO,
                                                        body: Character.BODY_RUS_RECON,
                                                        facewear: Character.FACEWEAR_MASK
                                                    };
                                                    break;

                                                case "rus_commander":
                                                    var enemyAvatarData = {
                                                        hairColour: Character.HAIR_COLOUR_BLACK,
                                                        hair: Character.HAIR_BALD,
                                                        beard: Character.BEARD_NONE,
                                                        face: Character.FACE_DEFAULT,
                                                        head: Character.HEAD_OPFOR_BERET,
                                                        body: Character.BODY_RUS_STANDARD
                                                    };
                                                    break;

                                                case "juggernaut":
                                                    var enemyAvatarData = {
                                                        hairColour: Character.HAIR_COLOUR_BLACK,
                                                        hair: Character.HAIR_BALD,
                                                        beard: Character.BEARD_NONE,
                                                        face: Character.FACE_DEFAULT,
                                                        head: Character.HEAD_JUGGERNAUT_HELMET,
                                                        body: Character.BODY_JUGGERNAUT
                                                    };
                                                    break;

                                                case "gign_generic":
                                                    enemyAvatarData = {
                                                        hairColour: Character.HAIR_COLOUR_BLACK,
                                                        hair: Character.HAIR_SHORT,
                                                        beard: Character.BEARD_NONE,
                                                        face: Character.FACE_DEFAULT,
                                                        head: Character.HEAD_GIGN_HELMET,
                                                        body: Character.BODY_GIGN_STANDARD
                                                    };
                                                    break;

                                                case "gign_sniper":
                                                    enemyAvatarData = {
                                                        hairColour: Character.HAIR_COLOUR_BLACK,
                                                        hair: Character.HAIR_SHORT,
                                                        beard: Character.BEARD_NONE,
                                                        face: Character.FACE_DEFAULT,
                                                        head: Character.HEAD_RADIO,
                                                        body: Character.BODY_GIGN_TACTICAL,
                                                        facewear: Character.FACEWEAR_MASK
                                                    };
                                                    break;

                                                case "un_generic":
                                                    enemyAvatarData = {
                                                        hairColour: Character.HAIR_COLOUR_BLACK,
                                                        hair: Character.HAIR_SHORT,
                                                        beard: Character.BEARD_NONE,
                                                        face: Character.FACE_DEFAULT,
                                                        head: Character.HEAD_UN_HELMET,
                                                        body: Character.BODY_GIGN_TACTICAL
                                                    };
                                                    break;

                                                case "gsg9_generic":
                                                    var heads = [
                                                        Character.HEAD_GSG9_HELMET,
                                                        Character.HEAD_GSG9_HELMET_2,
                                                        Character.HEAD_GSG9_HELMET_3
                                                    ];
                                                    enemyAvatarData = {
                                                        hairColour: Character.HAIR_COLOUR_BLACK,
                                                        hair: Character.HAIR_SHORT,
                                                        beard: Character.BEARD_NONE,
                                                        face: Character.FACE_DEFAULT,
                                                        head: heads[this.Random(0, heads.length - 1)],
                                                        body: Character.BODY_GSG9_STANDARD
                                                    };
                                                    break;

                                                case "gsg9_heavy":
                                                    enemyAvatarData = {
                                                        hairColour: Character.HAIR_COLOUR_BLACK,
                                                        hair: Character.HAIR_SHORT,
                                                        beard: Character.BEARD_NONE,
                                                        face: Character.FACE_DEFAULT,
                                                        head: Character.HEAD_GSG9_HELMET_3,
                                                        body: Character.BODY_GSG9_HEAVY
                                                    };
                                                    break;

                                                case "gsg9_sniper":
                                                    enemyAvatarData = {
                                                        hairColour: Character.HAIR_COLOUR_BLACK,
                                                        hair: Character.HAIR_SHORT,
                                                        beard: Character.BEARD_NONE,
                                                        face: Character.FACE_DEFAULT,
                                                        head: Character.HEAD_RADIO,
                                                        body: Character.BODY_GSG9_TACTICAL,
                                                        facewear: Character.FACEWEAR_MASK
                                                    };
                                                    break;

                                                case "gsg9_commander":
                                                    enemyAvatarData = {
                                                        hairColour: Character.HAIR_COLOUR_BLACK,
                                                        hair: Character.HAIR_SHORT,
                                                        beard: Character.BEARD_GOATEE,
                                                        face: Character.FACE_DEFAULT,
                                                        head: Character.HEAD_RUS_BERET,
                                                        body: Character.BODY_GSG9_PARA
                                                    };
                                                    break;

                                                case "zombie_generic":
                                                    bZombie = true;
                                                    zombieType = Zombie.TYPE_DEFAULT;
                                                    var faces = [
                                                        Character.FACE_ZOMBIE_1,
                                                        Character.FACE_ZOMBIE_2,
                                                        Character.FACE_ZOMBIE_3,
                                                        Character.FACE_ZOMBIE_4,
                                                    ];
                                                    enemyAvatarData = {
                                                        hairColour: Character.HAIR_COLOUR_BLACK,
                                                        hair: Character.HAIR_BALD,
                                                        beard: Character.BEARD_NONE,
                                                        face: faces[this.Random(0, faces.length - 1)],
                                                        head: Character.HEAD_NONE,
                                                        body: Character.BODY_ZOMBIE
                                                    };
                                                    if (!enemy.inventory)
                                                    {
                                                        enemy.inventory = [
                                                            {
                                                                id: "zombie"
                                                            }
                                                        ];
                                                    }
                                                    break;

                                                case "zombie_sprinter":
                                                    bZombie = true;
                                                    zombieType = Zombie.TYPE_SPRINTER;
                                                    enemyAvatarData = {
                                                        hairColour: Character.HAIR_COLOUR_BLACK,
                                                        hair: Character.HAIR_BALD,
                                                        beard: Character.BEARD_NONE,
                                                        face: Character.FACE_ZOMBIE_SPRINTER,
                                                        head: Character.HEAD_NONE,
                                                        body: Character.BODY_ZOMBIE_SPRINTER
                                                    };
                                                    if (!enemy.inventory)
                                                    {
                                                        enemy.inventory = [
                                                            {
                                                                id: "zombie_sprinter"
                                                            }
                                                        ];
                                                    }
                                                    break;

                                                case "zombie_sprinter_boss":
                                                    bZombie = true;
                                                    zombieType = Zombie.TYPE_SPRINTER_BOSS;
                                                    enemyAvatarData = {
                                                        hairColour: Character.HAIR_COLOUR_BLACK,
                                                        hair: Character.HAIR_BALD,
                                                        beard: Character.BEARD_NONE,
                                                        face: Character.FACE_ZOMBIE_SPRINTER_BOSS,
                                                        head: Character.HEAD_NONE,
                                                        body: Character.BODY_ZOMBIE_SPRINTER_BOSS
                                                    };
                                                    if (!enemy.inventory)
                                                    {
                                                        enemy.inventory = [
                                                            {
                                                                id: "zombie_sprinter_boss"
                                                            }
                                                        ];
                                                    }
                                                    break;

                                                case "zombie_fat":
                                                    bZombie = true;
                                                    zombieType = Zombie.TYPE_FAT;
                                                    enemyAvatarData = {
                                                        hairColour: Character.HAIR_COLOUR_BLACK,
                                                        hair: Character.HAIR_BALD,
                                                        beard: Character.BEARD_NONE,
                                                        face: Character.FACE_ZOMBIE_FAT,
                                                        head: Character.HEAD_NONE,
                                                        body: Character.BODY_ZOMBIE_FAT
                                                    };
                                                    if (!enemy.inventory)
                                                    {
                                                        enemy.inventory = [
                                                            {
                                                                id: "zombie_fat"
                                                            }
                                                        ];
                                                    }
                                                    break;

                                                case "zombie_spitter":
                                                    bZombie = true;
                                                    zombieType = Zombie.TYPE_SPITTER;
                                                    enemyAvatarData = {
                                                        hairColour: Character.HAIR_COLOUR_BLACK,
                                                        hair: Character.HAIR_BALD,
                                                        beard: Character.BEARD_NONE,
                                                        face: Character.FACE_ZOMBIE_SPITTER,
                                                        head: Character.HEAD_NONE,
                                                        body: Character.BODY_ZOMBIE_SPITTER
                                                    };
                                                    enemy.inventory = [
                                                        {
                                                            id: "zombie_spitter"
                                                        }
                                                    ];
                                                    break;

                                                case "zombie_exploder":
                                                    bZombie = true;
                                                    zombieType = Zombie.TYPE_EXPLODER;
                                                    enemyAvatarData = {
                                                        hairColour: Character.HAIR_COLOUR_BLACK,
                                                        hair: Character.HAIR_BALD,
                                                        beard: Character.BEARD_NONE,
                                                        face: Character.FACE_ZOMBIE_EXPLODER,
                                                        head: Character.HEAD_NONE,
                                                        body: Character.BODY_ZOMBIE_EXPLODER
                                                    };
                                                    enemy.inventory = [
                                                        {
                                                            id: "zombie_exploder"
                                                        }
                                                    ];
                                                    break;

                                                case "zombie_exploder_boss":
                                                    bZombie = true;
                                                    zombieType = Zombie.TYPE_EXPLODER_BOSS;
                                                    enemyAvatarData = {
                                                        hairColour: Character.HAIR_COLOUR_BLACK,
                                                        hair: Character.HAIR_BALD,
                                                        beard: Character.BEARD_NONE,
                                                        face: Character.FACE_ZOMBIE_EXPLODER,
                                                        head: Character.HEAD_NONE,
                                                        body: Character.BODY_ZOMBIE_EXPLODER_BOSS
                                                    };
                                                    enemy.inventory = [
                                                        {
                                                            id: "zombie_exploder_boss"
                                                        }
                                                    ];
                                                    break;

                                                case "zombie_spitter_boss":
                                                    bZombie = true;
                                                    zombieType = Zombie.TYPE_SPITTER_BOSS;
                                                    enemyAvatarData = {
                                                        hairColour: Character.HAIR_COLOUR_BLACK,
                                                        hair: Character.HAIR_BALD,
                                                        beard: Character.BEARD_NONE,
                                                        face: Character.FACE_ZOMBIE_SPITTER_BOSS,
                                                        head: Character.HEAD_NONE,
                                                        body: Character.BODY_ZOMBIE_SPITTER_BOSS
                                                    };
                                                    enemy.inventory = [
                                                        {
                                                            id: "zombie_spitter_boss"
                                                        }
                                                    ];
                                                    break;

                                                default:
                                                    console.warn("No character style defined:", enemy);
                                                    enemyAvatarData = {
                                                        hairColour: Character.HAIR_COLOUR_BLACK,
                                                        hair: Character.HAIR_SHORT,
                                                        beard: Character.BEARD_NONE,
                                                        face: Character.FACE_DEFAULT,
                                                        head: Character.HEAD_OPFOR_SCARF,
                                                        body: Character.BODY_OPFOR_STANDARD
                                                    };
                                                    break;
                                            }
                                            var hairColours = [Character.HAIR_COLOUR_BLACK, Character.HAIR_COLOUR_BROWN, Character.HAIR_COLOUR_BLONDE];
                                            enemyAvatarData.hairColour = hairColours[this.Random(0, hairColours.length - 1)];
                                            if (!bZombie && botSkill >= 3)
                                            {
                                                if (!enemy.equipment)
                                                {
                                                    enemy.equipment = "stim";
                                                }
                                                if (!enemy.inventory[0].mods)
                                                {
                                                    enemy.inventory[0].mods = {
                                                        base: Mods.BASE_RANGE
                                                    }
                                                }
                                            }
                                            this.requestEvent({
                                                eventId: GameServer.EVENT_CREATE_GENERIC_CHARACTER,
                                                data:
                                                {
                                                    id: enemy.id ? enemy.id : this.getRandomUniqueId(),
                                                    x: enemy.position[0],
                                                    y: enemy.position[1],
                                                    team: enemyTeam,
                                                    health: enemy.health ? enemy.health : 200,
                                                    inventory: enemy.inventory,
                                                    equipment: enemy.equipment,
                                                    avatarData: enemyAvatarData,
                                                    botSkill: botSkill,
                                                    ai: enemyAI,
                                                    bUnlimitedAmmo: true,
                                                    maxSpeed: enemy.maxSpeed,
                                                    damageMultipliers: enemyDamageMultipliers,
                                                    bZombie: bZombie,
                                                    zombieType: zombieType,
                                                    baseSpeedMultiplier: enemy.baseSpeedMultiplier,
                                                    bRegenHealth: enemy.bHero || this.localData["difficulty"] >= 3,
                                                    regenAmont: enemy.regenAmount,
                                                    pawnName: enemy.pawnName,
                                                    bHero: enemy.bHero,
                                                    perks: enemy.perks,
                                                    bFailIfKilled: enemy.bFailIfKilled
                                                }
                                            });
                                        }
                                        break;

                                    default:
                                        console.warn("Unhandled enemy type:", enemy.type);
                                        break;
                                }
                            }
                        }
                    }
                    else if (localData["bSurvival"])
                    {
                        var players = localData["playerStates"];
                        var spawn = this.getCurrentMapData()["spawn_store"];
                        var maxSpawnAreaWidth = 400;
                        for (var i = 0; i < players.length; i++)
                        {
                            var ps = players[i];
                            if (!ps.avatarData)
                            {
                                ps.avatarData = this.getRandomAvatarData();
                            }
                            var inventory = this.getSurvivalInventory();
                            var equipment = "frag";
                            var equipmentAmmo = 2;
                            this.requestEvent({
                                eventId: GameServer.EVENT_REQUEST_RANKED_CHARACTER,
                                playerId: ps["id"],
                                avatarData: ps.avatarData,
                                data: {
                                    x: (spawn[0] + (i * (maxSpawnAreaWidth / players.length))) - (maxSpawnAreaWidth * (0.5 / players.length)),
                                    y: spawn[1],
                                    inventory: inventory,
                                    equipment: equipment,
                                    equipmentAmmo: equipmentAmmo,
                                    perks: []
                                    //bGodMode: false,
                                    //bUnlimitedAmmo: false
                                },
                            });
                        }
                    }
                    else
                    {
                        switch (localData.gameModeData["id"])
                        {
                            case GameMode.INFECTED:
                                this.startInfectedIntermission();
                                break;
                        }
                        this.checkAutoTeamBalance();
                    }
                    break;

                case GameServer.EVENT_PLAYER_UPDATE:
                    var ps = this.getPlayerStateById(_data["playerId"]);
                    if (ps)
                    {
                        var data = _data.data;
                        if (data)
                        {
                            if (data["bAutoRespawn"] != undefined)
                            {
                                ps["bAutoRespawn"] = data["bAutoRespawn"];
                                if (!ps["bHasPawn"] && ps["bAutoRespawn"] && ps["bCanRespawn"])
                                {
                                    this.requestEvent({
                                        eventId: GameServer.EVENT_PLAYER_RESPAWN,
                                        playerId: ps["id"]
                                    });
                                }
                            }
                            if (data["desiredClassData"] != undefined)
                            {
                                if (!this.localData.gameModeData["bNoClasses"] && !ps.bVIP)
                                {
                                    var prevDesiredClassData = this.clone(ps["desiredClassData"]);
                                    ps["desiredClassData"] = data["desiredClassData"];
                                    if (ps.desiredClassData["killstreak"] == Killstreaks.TYPE_ASSAULT && this.matchInProgress())
                                    {
                                        ps["currentKillstreak"] = 0;
                                    }
                                    if (!this.matchInProgress() && prevDesiredClassData && prevDesiredClassData.killstreak != ps.desiredClassData.killstreak)
                                    {
                                        ps["currentKillstreak"] = 0;
                                    }
                                    data["currentKillstreak"] = ps["currentKillstreak"];
                                }
                            }
                            if (data.battlezone != undefined)
                            {
                                if (this.localData["bBattlezone"])
                                {
                                    ps.battlezone = data.battlezone;
                                }
                            }
                            if (data["level"] != undefined)
                            {
                                ps["level"] = data["level"];
                            }
                            if (data["name"] != undefined)
                            {
                                ps["name"] = data["name"];
                            }
                            if (data["clan"] !== undefined)
                            {
                                ps["clan"] = data["clan"];
                            }
                        }
                    }
                    break;

                case GameServer.EVENT_PLAYER_CLOSE_WORLD_MENU:
                    var char = this.getObjectById(_data["playerId"]);
                    if (char)
                    {
                        this.endCharacterUseDelay(char);
                    }
                    break;

                case GameServer.EVENT_PLAYER_SET_WORLD_POSITION:
                    var char = this.getObjectById(_data["playerId"]);
                    if (char)
                    {
                        if (char.data.weapon["bUseDelay"])
                        {
                            this.triggerPlayerCurrentKillstreak(char.data["id"], _data.position[0], _data.position[1]);
                            this.endCharacterUseDelay(char);
                        }
                    }
                    break;

                case GameServer.EVENT_ROUND_END:
                    var gameModeData = this.localData.gameModeData;
                    this.localData["matchState"] = MatchState.STATE_POST_ROUND;
                    break;

                case GameServer.EVENT_GAME_END:
                    console.log(_data);
                    if (_data["condition"] == MatchState.END_CONDITION_FORFEIT)
                    {
                        _data["winningTeam"] = -1; //Draw
                    }
                    this.localData.gameModeData["winner"] = _data["winningTeam"];
                    this.endGame();
                    break;

                case GameServer.EVENT_SPAWN_BULLET:
                    var result = this.raycast(_data["startX"], _data["startY"], _data["endX"], _data["endY"]);
                    if (result)
                    {
                        var impactEffects = [];
                        if (_data["bMelee"])
                        {
                            var causer = this.getObjectById(_data["causerId"]);
                            if (causer)
                            {
                                var pawns = this.getPawns().concat(this.getEquipment());
                                for (var i = 0; i < pawns.length; i++)
                                {
                                    let curPawn = pawns[i];
                                    if (curPawn.getAABB().overlaps(causer.getAABB()))
                                    {
                                        result.push({
                                            body: curPawn,
                                            point: { x: curPawn.position[0], y: curPawn.position[1] },
                                            distance: 1
                                        });
                                    }
                                }
                            }
                        }
                        var weaponData = _data["weaponData"] ? _data["weaponData"] : this.getWeaponData(_data["weaponId"]);
                        var penetration = 0;
                        var penetrationMax = 0;
                        switch (_data["weaponId"])
                        {
                            case Killstreaks.KILLSTREAK_HELI_SNIPER:
                                penetrationMax = this.localData["bSurvival"] ? 10 : 5;
                                break;

                            case Killstreaks.KILLSTREAK_COBRA_CONTROLLABLE:
                            case Killstreaks.KILLSTREAK_SCOUT:
                                penetrationMax = 3;
                                break;

                            case Killstreaks.KILLSTREAK_CHOPPER_GUNNER:
                                penetrationMax = this.localData["bSurvival"] ? 2 : 1;
                                break;

                            case Killstreaks.KILLSTREAK_ADVANCED_TURRET:
                                penetrationMax = this.localData["bSurvival"] ? 2 : 1;
                                break;

                            default:
                                penetrationMax = weaponData ? weaponData["penetration"] : 1;
                                break;
                        }
                        var impactType = "default";
                        var bHit = false;
                        var hitIds = {};
                        var penetrationMult = 0.8;
                        var angle = this.Angle(_data["endX"], _data["endY"], _data["startX"], _data["startY"]);
                        for (var i = 0; i < result.length; i++)
                        {
                            bHit = false;
                            var cur = result[i];
                            if (cur)
                            {
                                var body = cur["body"];
                                if (body.data && !body.data["bInvisible"])
                                {
                                    impactType = body.data["material"] ? body.data["material"] : "default";
                                    if (body.data.bHostage && body.data.bGodMode)
                                    {
                                        continue;
                                    }
                                    if (body.data["type"] == "character")
                                    {
                                        ps = this.getPlayerStateById(body.data["id"]);
                                        if (ps && ps["bSpawnProtection"])
                                        {
                                            continue;
                                        }
                                        if (this.characterHasEquipment(body, "kevlar"))
                                        {
                                            //bHit = true;
                                        }
                                    }
                                    else if (body.data["type"] == "ground")
                                    {
                                        penetration = penetrationMax;
                                        bHit = true;
                                    }
                                    else if (body.data["type"] == "door")
                                    {
                                        if (body.data["bClosed"])
                                        {
                                            if (body.data["material"] == "metal")
                                            {
                                                penetration = penetrationMax;
                                            }
                                            else
                                            {
                                                //Open doors on bullet impact
                                                if (penetrationMax >= 5 && penetration == 0)
                                                {
                                                    this.setDoorClosed(body, false, this.getObjectById(_data["causerId"]));
                                                }
                                                else if (weaponData && weaponData.type == Weapon.TYPE_SHOTGUN && cur.distance < 100)
                                                {
                                                    this.setDoorClosed(body, false, this.getObjectById(_data["causerId"]));
                                                }
                                            }
                                            bHit = true;
                                        }
                                    }
                                    else if (body.data["type"] == "shield")
                                    {
                                        if (body.data["bActive"] && body.data["playerId"] != _data["causerId"])
                                        {
                                            var causer = this.getObjectById(_data["causerId"]);
                                            var causerTeam = causer ? causer.data["team"] : -1;
                                            //Don't block with shield if melee or survival enemy
                                            var bBlock = !_data["bMelee"] || this.localData["bSurvival"];
                                            if (bBlock && causerTeam == body.data["team"])
                                            {
                                                if (this.localData["bSurvival"] || this.localData["bSandbox"] || this.localData["bBattlezone"])
                                                {
                                                    bBlock = false;
                                                }
                                                else if (this.localData["bOperation"] && causerTeam == 1)
                                                {
                                                    bBlock = false;
                                                }
                                            }
                                            if (bBlock)
                                            {
                                                penetration = penetrationMax;
                                                bHit = true;
                                                var shield = body;
                                            }
                                        }
                                    }
                                    else if (body.data["type"] == "obstacle")
                                    {
                                        if (_data["bIgnoreObstacles"] && !body.data["health"])
                                        {
                                            continue;
                                        }
                                        else
                                        {
                                            //Check if within obstacle
                                            var obsDist = 60;
                                            var causer = this.getObjectById(_data["causerId"]);
                                            if (causer)
                                            {
                                                if (causer.data["type"] == "turret")
                                                {
                                                    obsDist = 100;
                                                }
                                                else if (causer.data["bBot"])
                                                {
                                                    obsDist = 100;
                                                }
                                            }
                                            if (!body.data["bBlock"] && this.Dist(cur.point.x, cur.point.y, _data["startX"], _data["startY"]) < obsDist)
                                            {
                                                continue;
                                            }
                                            penetration = penetrationMax;
                                            bHit = true;
                                        }
                                    }
                                    else if (body.data["type"] == "destructableObject")
                                    {
                                        if (body.data.destructableData["type"] == "deployable_cover")
                                        {
                                            if (_data["bIgnoreObstacles"])
                                            {
                                                continue;
                                            }
                                            else
                                            {
                                                //Check if within deployable cover
                                                if (this.Dist(cur.point.x, cur.point.y, _data["startX"], _data["startY"]) < 15)
                                                {
                                                    continue;
                                                }
                                                _data["damageAmount"] *= penetrationMax;
                                                penetration = penetrationMax;
                                                bHit = true;                                                
                                            }
                                        }
                                    }
                                    if (!hitIds[body.data.id])
                                    {
                                        if (body.data["health"])
                                        {
                                            switch (body.data["type"])
                                            {
                                                case "grenade":
                                                    if (body.data["team"] != _data["team"] || _data["controllerId"] == body.data.grenadeData.playerId)
                                                    {
                                                        if (!_data["bMelee"])
                                                        {
                                                            this.detonate(body); //C4
                                                        }
                                                    }
                                                    break;

                                                default:         
                                                    var bCollide = body.data["team"] != _data["team"];
                                                    if (body.data["type"] == "equipment")
                                                    {
                                                        if (_data["controllerId"] == body.data["ownerId"])
                                                        {
                                                            bCollide = true;
                                                        }
                                                    }
                                                    if (bCollide)
                                                    {
                                                        if (body.data["type"] == "door" || body.data["type"] == "obstacle")
                                                        {
                                                            penetrationMult = Math.max(0.1, penetrationMult * 0.35);
                                                        }           
                                                        else if (body.data["type"] == "equipment")
                                                        {
                                                            //if (!_data["bMelee"] || body.data["bCanMelee"])
                                                            if ((!this.localData["bOperation"] && _data["controllerId"] == body.data["ownerId"]) || body.data["team"] != _data["team"])
                                                            {
                                                                hitIds[body.data.id] = true;
                                                                bHit = true;
                                                                if (body.data.weaponData["bMine"])
                                                                {
                                                                    body.data["ownerId"] = _data["controllerId"] ? _data["controllerId"] : _data["causerId"];
                                                                    this.detonate(body);
                                                                }
                                                            }
                                                        }

                                                        hitIds[body.data.id] = true;
                                                        var damageAmount = _data["damageAmount"];
                                                        if (penetration > 0)
                                                        {
                                                            var mult = (1 - (penetration / penetrationMax)) * penetrationMult;
                                                            if (penetration != penetrationMax)
                                                            {
                                                                damageAmount = Math.ceil(damageAmount * mult);
                                                            }
                                                            //damageAmount = damageAmount / (penetration + 2);
                                                        }
                                                        var bHeadshot = cur["bHeadshot"];
                                                        var bLegshot = cur["bLegshot"];
                                                        var bKevlar = false;
                                                        if (weaponData && this.isMeleeWeapon(weaponData))
                                                        {
                                                            bHeadshot = false;
                                                            bLegshot = false;
                                                        }
                                                        if (bHeadshot)
                                                        {
                                                            var hsMult = 1;
                                                            if (weaponData)
                                                            {
                                                                hsMult = weaponData["headshotMultiplier"] ? weaponData["headshotMultiplier"] : 1;
                                                            }
                                                            var bHelmet = this.characterHasPerk(body, Perks.PERK_PLAYER_HELMET);
                                                            if (bHelmet)
                                                            {
                                                                var maxHelmetDamage = this.getCharacterHealth() * 0.75;
                                                                if (weaponData)
                                                                {
                                                                    /*
                                                                    if (this.hasMod(weaponData, Mods.AMMO_IMPACT))
                                                                    {
                                                                        damageAmount = damageAmount * (1.2 * hsMult);
                                                                    }
                                                                    else if (this.hasMod(weaponData, Mods.AMMO_PIERCING) || this.hasMod(weaponData, Mods.BARREL_BOOSTER))
                                                                    {
                                                                        damageAmount = damageAmount * (1.2 * hsMult);
                                                                    }
                                                                    else
                                                                    {
                                                                        damageAmount = damageAmount * (1.1 * hsMult);
                                                                    }
                                                                    */                                                                    
                                                                }
                                                                damageAmount = damageAmount * (1.1 * hsMult);
                                                                damageAmount = Math.min(maxHelmetDamage, damageAmount);
                                                            }
                                                            else
                                                            {
                                                                damageAmount = damageAmount * (1.4 * hsMult);
                                                            }
                                                        }
                                                        else if (bLegshot)
                                                        {
                                                            var legMult = 0.8;
                                                            if (weaponData)
                                                            {
                                                                switch (weaponData["type"])
                                                                {
                                                                    case Weapon.TYPE_SNIPER:
                                                                        legMult = 0.5;
                                                                        break;
                                                                }
                                                                if (weaponData["bImpact"])
                                                                {
                                                                    //legMult = Math.min(1, legMult + 0.2);
                                                                }
                                                            }
                                                            damageAmount = damageAmount * legMult;
                                                        }
                                                        var bMelee = this.isMeleeWeapon(weaponData);
                                                        var bLongshot = false;
                                                        var bNearshot = false;
                                                        var bAntiSniper = this.characterHasPerk(body, Perks.PERK_PLAYER_ANTI_SNIPER);
                                                        if (weaponData && !bMelee)
                                                        {
                                                            var dist = this.Dist(_data["startX"], _data["startY"], _data["endX"], _data["endY"]);
                                                            var hitDist = cur["distance"];
                                                            var longshotMult = 0.65;
                                                            switch (weaponData["type"])
                                                            {
                                                                case Weapon.TYPE_SHOTGUN:
                                                                    longshotMult = 0.4;
                                                                    break;
                                                            }
                                                            var dropDist = dist * longshotMult;
                                                            bLongshot = hitDist >= dropDist;
                                                            bNearshot = hitDist <= Math.min(400, dist * 0.3);
                                                            var highCaliberVal = 0.85;
                                                            var dropMult = 1;
                                                            if (bLongshot)
                                                            {
                                                                switch (weaponData["type"])
                                                                {
                                                                    case Weapon.TYPE_SHOTGUN:
                                                                        var minVal = 0.1;
                                                                        break;

                                                                    case Weapon.TYPE_MACHINE_PISTOL:
                                                                        minVal = weaponData["bHighCaliber"] && !bAntiSniper ? highCaliberVal : 0.15;
                                                                        break;

                                                                    case Weapon.TYPE_SMG:
                                                                    case Weapon.TYPE_PISTOL:
                                                                        minVal = weaponData["bHighCaliber"] && !bAntiSniper ? highCaliberVal : 0.25;
                                                                        break;

                                                                    case Weapon.TYPE_SNIPER:
                                                                        minVal = weaponData["bHighCaliber"] && !bAntiSniper ? highCaliberVal : 0.45;
                                                                        break;

                                                                    default:
                                                                        minVal = weaponData["bHighCaliber"] && !bAntiSniper ? highCaliberVal : 0.35;
                                                                        break;
                                                                }
                                                                dropMult = Math.max(1 - ((hitDist - dropDist) / (dist - dropDist)), minVal);
                                                                damageAmount *= dropMult;
                                                            }
                                                            else if (bNearshot)
                                                            {
                                                                if (weaponData["type"] != Weapon.TYPE_SHOTGUN && weaponData["bImpact"])
                                                                {
                                                                    damageAmount *= this.localData["bSurvival"] ? 2 : 1.5;
                                                                }
                                                                if (this.characterHasEquipment(body, "kevlar") && !bHeadshot && !bLegshot)
                                                                {
                                                                    bKevlar = true;                                                                    
                                                                    damageAmount = damageAmount * 0.5;
                                                                }
                                                                else 
                                                                {
                                                                    if (weaponData["type"] == Weapon.TYPE_SHOTGUN)
                                                                    {
                                                                        damageAmount *= 1.5;
                                                                    }
                                                                }
                                                            }
                                                            if (bAntiSniper)
                                                            {
                                                                if (weaponData["type"] == Weapon.TYPE_SNIPER || _data["weaponId"] == Killstreaks.KILLSTREAK_HELI_SNIPER)
                                                                {
                                                                    var curItem = this.getCurrentCharacterInventoryItem(body);
                                                                    if (curItem && curItem["type"] == Weapon.TYPE_SNIPER)
                                                                    {
                                                                        damageAmount = damageAmount * (dropMult * 0.65); //Make Anti-Sniper less effective
                                                                    }
                                                                    else
                                                                    {
                                                                        damageAmount = damageAmount * (dropMult * 0.5);
                                                                        if (!bNearshot)
                                                                        {
                                                                            damageAmount = Math.min(damageAmount, this.getCharacterHealth() * 0.5);
                                                                        }
                                                                    }
                                                                    var bSniper = true;
                                                                }
                                                                else if (weaponData["bHighCaliber"] && bLongshot)
                                                                {
                                                                    bSniper = true;
                                                                }
                                                            }
                                                        }
                                                        var attacker = this.getObjectById(_data["controllerId"]);
                                                        if (attacker)
                                                        {
                                                            switch (body.data["type"])
                                                            {
                                                                case "turret":
                                                                case "helicopter":
                                                                    if (this.characterHasPerk(attacker, Perks.PERK_WEAPON_SHRAPNEL))
                                                                    {
                                                                        damageAmount *= 2;
                                                                    }
                                                                    if (weaponData)
                                                                    {
                                                                        if (weaponData["vehicleMultiplier"] != undefined)
                                                                        {
                                                                            damageAmount *= weaponData["vehicleMultiplier"];
                                                                        }
                                                                        if (weaponData.penetration > 1)
                                                                        {
                                                                            damageAmount += 3 * (weaponData.penetration - 1);
                                                                        }
                                                                    }
                                                                    if (this.localData["bModeGame"])
                                                                    {
                                                                        if (_data["weaponId"] == Killstreaks.KILLSTREAK_ADVANCED_TURRET)
                                                                        {
                                                                            damageAmount *= 3;
                                                                        }
                                                                    }
                                                                    break;

                                                                case "character":
                                                                    if (weaponData)
                                                                    {
                                                                        if (body.data["bZombie"])
                                                                        {
                                                                            if (weaponData["zombieMultiplier"] != undefined)
                                                                            {
                                                                                damageAmount *= weaponData["zombieMultiplier"];
                                                                            }
                                                                        }
                                                                    }
                                                                    let ps = this.getPlayerStateById(body.data["id"]);
                                                                    if (ps && ps["bJuggernaut"])
                                                                    {
                                                                        if (this.characterHasPerk(attacker, Perks.PERK_WEAPON_SHRAPNEL))
                                                                        {
                                                                            damageAmount *= 2;
                                                                        }
                                                                        if (weaponData)
                                                                        {
                                                                            if (weaponData["vehicleMultiplier"] != undefined)
                                                                            {
                                                                                damageAmount *= weaponData["vehicleMultiplier"];
                                                                            }
                                                                            if (this.hasMod(weaponData, Mods.AMMO_PIERCING) || this.hasMod(weaponData, Mods.BARREL_BOOSTER))
                                                                            {
                                                                                damageAmount *= 1.5;
                                                                            }
                                                                            if (weaponData.penetration > 1)
                                                                            {
                                                                                damageAmount += 3 * (weaponData.penetration - 1);
                                                                            }
                                                                        }
                                                                        if (this.localData["bModeGame"])
                                                                        {
                                                                            if (_data["weaponId"] == Killstreaks.KILLSTREAK_ADVANCED_TURRET)
                                                                            {
                                                                                damageAmount *= 3;
                                                                            }
                                                                        }
                                                                    }
                                                                    break;
                                                            }
                                                        }
                                                        var damageType = DamageType.DAMAGE_BULLET;
                                                        if (bMelee)
                                                        {
                                                            damageType = DamageType.DAMAGE_MELEE;
                                                        }
                                                        else if (_data.weaponId == "railgun")
                                                        {
                                                            damageType = DamageType.DAMAGE_EXPLOSIVE;
                                                        }
                                                        this.requestEvent({
                                                            eventId: GameServer.EVENT_PAWN_DAMAGE,
                                                            damageType: damageType,
                                                            damageAmount: damageAmount,
                                                            pawnId: body.data["id"],
                                                            attackerId: _data["controllerId"],
                                                            causerId: _data["causerId"],
                                                            weaponId: _data["weaponId"],
                                                            bHeadshot: bHeadshot,
                                                            bLongshot: bLongshot,
                                                            bNearshot: bNearshot,
                                                            bSniper: bSniper,
                                                            bMelee: bMelee,
                                                            bKevlar: bKevlar,
                                                            bDirectlyCausedByPlayer: _data["bDirectlyCausedByPlayer"]
                                                        });
                                                        bHit = true;
                                                    }
                                                    break;
                                            }
                                        }
                                    }
                                    if (bHit)
                                    {
                                        if (shield)
                                        {
                                            var shieldPawn = this.getObjectById(shield.data["playerId"]);
                                            if (shieldPawn && shieldPawn.data["health"])
                                            {
                                                this.requestEvent({
                                                    eventId: GameServer.EVENT_PAWN_ACTION,
                                                    pawnId: shieldPawn.data["id"],
                                                    type: GameServer.PAWN_HIT_SHIELD,
                                                    damage: damageAmount ? damageAmount : _data["damageAmount"],
                                                    causerId: _data["causerId"]
                                                });
                                            }
                                        }
                                        this.emitAISound([cur.point.x, cur.point.y], undefined, 300);
                                        //this.createImpactEffect(cur.point.x, cur.point.y, angle, impactType, damageAmount ? damageAmount : _data["damageAmount"]);
                                        impactEffects.push({
                                            x: Math.round(cur.point.x),
                                            y: Math.round(cur.point.y),
                                            rotation: angle,
                                            impactType: impactType,
                                            damageAmount: damageAmount ? damageAmount : _data["damageAmount"]
                                        });
                                        penetration++;
                                        if (penetration >= penetrationMax)
                                        {
                                            _data["endX"] = cur.point.x;
                                            _data["endY"] = cur.point.y;
                                            break;
                                        }
                                    }
                                }
                            }
                        }
                    }
                    //Adjust keys for client
                    _data["rotation"] = this.RoundDecimal(_data["rotation"]);
                    _data.endX = Math.round(_data.endX);
                    _data.endY = Math.round(_data.endY);
                    delete _data.bIgnoreObstacles;
                    delete _data.bDirectlyCausedByPlayer;
                    delete _data.weaponData;
                    delete _data.team;
                    delete _data.damageAmount;
                    delete _data.causerId;
                    /*
                    switch (_data.weaponId)
                    {
                        case "railgun":
                            break;
                        default:
                            delete _data.weaponId;
                            break;
                    }
                    */
                    if (impactEffects)
                    {
                        this.createImpactEffects(impactEffects);
                    }
                    if (this.localData.bMultiplayer && this.batchData.length >= Settings.BATCH_MAX)
                    {
                        _data.bServerSideOnly = true;
                    }
                    break;

                case GameServer.EVENT_SPAWN_EXPLOSION:
                    if (_data["damage"])
                    {
                        this.checkExplosion(Math.round(_data["x"]), Math.round(_data["y"]), _data["radius"], _data["damage"], _data["playerId"], _data["causerId"], _data["weaponId"], _data["bLOS"], _data["directHitId"]);
                    }
                    break;

                case GameServer.EVENT_STORE_BUY:
                    this.purchaseStoreItem(_data["playerId"], _data["data"]);
                    _data.bServerSideOnly = true;
                    break;

                case GameServer.EVENT_GAME_MONEY_ADD:
                    var val = this.localData["bSandbox"] ? 0 : _data["value"];
                    if (val != null)
                    {
                        this.addPlayerMoney(_data["playerId"], val);
                    }
                    break;

                case GameServer.EVENT_GAME_PAUSE:
                    this.localData["bPaused"] = _data["bPaused"];
                    break;

                case GameServer.EVENT_PLAYER_RESPAWN:
                    if (this.roundHasEnded())
                    {
                        console.warn("Player respawning when round is ended!");
                        break;
                    }
                    ps = this.getPlayerStateById(_data["playerId"]);
                    if (ps)
                    {
                        if (ps["bJuggernaut"])
                        {
                            ps["avatarData"] = ps["desiredAvatarData"];
                            ps["bJuggernaut"] = false;
                            this.onEvent({
                                eventId: GameServer.EVENT_PLAYER_UPDATE,
                                playerId: _data["playerId"],
                                data: {
                                    bJuggernaut: ps["bJuggernaut"],
                                    avatarData: ps["avatarData"]
                                }
                            });
                        }
                        if (ps["bVIP"])
                        {
                            ps["avatarData"] = ps["desiredAvatarData"];
                            ps["bVIP"] = false;
                            this.onEvent({
                                eventId: GameServer.EVENT_PLAYER_UPDATE,
                                playerId: _data["playerId"],
                                data: {
                                    bVIP: ps["bVIP"],
                                    avatarData: ps["avatarData"]
                                }
                            });
                        }
                        var tacInsert = this.getEquipmentByPlayerId(ps["id"], "tac_insert");
                        if (tacInsert[0] && !tacInsert[0].data.bJammed)
                        {
                            var tacPos = this.clone(tacInsert[0].position);
                        }
                        this.removeEquipmentByPlayerId(ps["id"]);
                        var covers = this.getDeployableCovers(ps["id"]);
                        if (covers && covers.length > 0)
                        {
                            for (var i = 0; i < covers.length; i++)
                            {
                                this.removeNextStep(covers[i]);
                            }
                        }
                        var grenades = this.getGrenades(ps["id"]);
                        if (grenades && grenades.length > 0)
                        {
                            for (var i = 0; i < grenades.length; i++)
                            {
                                if (grenades[i].data["bRemoteDetonation"])
                                {
                                    this.removeNextStep(grenades[i]);
                                }
                            }
                        }
                        var classData = ps["desiredClassData"];
                        var inventory = [
                            classData.primary,
                            classData.secondary
                        ];
                        var equipment = classData.equipment;
                        var perks = [
                            classData.playerPerk,
                            classData.weaponPerk
                        ];
                        switch (this.localData.gameModeData["id"])
                        {
                            case GameMode.BATTLEZONE:
                                //Battlezone inventory
                                if (ps.battlezone)
                                {
                                    var bz = this.clone(ps.battlezone);
                                    inventory = [
                                        bz.primary,
                                        bz.secondary
                                    ];
                                    equipment = bz.equipment;
                                    perks = [bz.playerPerk, bz.weaponPerk];
                                }
                                else
                                {
                                    inventory = [
                                        {
                                            id: "g17",
                                            ammo: 20
                                        },
                                        {
                                            id: "none"
                                        }
                                    ];
                                    equipment = "smoke";
                                    perks = [Perks.PERK_PLAYER_SCAVENGER];
                                }
                                break;

                            case GameMode.SANDBOX:
                                //Sandbox inventory
                                inventory = [
                                    {
                                        id: "m16a4"
                                    },
                                    {
                                        id: "m9"
                                    }
                                ];
                                equipment = "frag";
                                var equipmentAmmo = 2;
                                perks = [];
                                break;

                            case GameMode.GUN_GAME:
                                var curGun = this.localData.gameModeData.weapons[ps["gunIndex"]];
                                inventory = [
                                    curGun
                                ];
                                equipment = null;
                                perks = [];
                                break;

                            case GameMode.INFECTED:
                                if (ps["bInfected"])
                                {
                                    inventory = [
                                        this.localData.gameModeData["infectedWeapon"]
                                    ];
                                    equipment = this.localData.gameModeData["infectedEquipment"];
                                    perks = this.localData.gameModeData["infectedPerks"];
                                    var bZombie = true;
                                    var zombieType = Zombie.TYPE_SPRINTER;
                                }
                                else
                                {
                                    inventory = [
                                        {
                                            id: this.localData.gameModeData["survivorWeaponId"]
                                        }
                                    ];
                                    equipment = this.localData.gameModeData["survivorEquipmentId"];
                                    equipmentAmmo = 2;
                                    perks = [];
                                }
                                break;

                            default:
                                if (this.localData.gameModeData.inventory)
                                {
                                    inventory = this.localData.gameModeData.inventory;
                                }
                                if (this.localData.gameModeData.equipment)
                                {
                                    equipment = this.localData.gameModeData.equipment;
                                }
                                if (this.localData.gameModeData.perks)
                                {
                                    perks = this.localData.gameModeData.perks;
                                }
                                break;
                        }
                        this.requestEvent({
                            eventId: GameServer.EVENT_REQUEST_RANKED_CHARACTER,
                            playerId: ps["id"],
                            bBot: ps["bBot"],
                            botSkill: ps["botSkill"],
                            avatarData: ps["avatarData"],
                            data: {
                                id: ps["id"],
                                inventory: inventory,
                                equipment: equipment,
                                equipmentAmmo: equipmentAmmo,
                                perks: perks,
                                bZombie: bZombie,
                                zombieType: zombieType,
                                bJuggernaut: ps["bJuggernaut"],
                                bTacticalInsertion: tacPos != null,
                                x: tacPos ? tacPos[0] : null,
                                y: tacPos ? tacPos[1] - 30 : null
                            }
                        });
                    }
                    break;

                case GameServer.EVENT_PLAYER_EARN_KILLSTREAK:
                    this.onPlayerEarnKillstreak(_data["playerId"], _data["killstreakId"]);
                    break;

                case GameServer.EVENT_PLAYER_USE_KILLSTREAK:
                    this.onPlayerUseKillstreak(_data["playerId"], _data["worldX"], _data["worldY"]);
                    _data.bServerSideOnly = true;
                    break;

                case GameServer.EVENT_PLAYER_UPDATE_CONTROLLABLE:
                    ps = this.getPlayerStateById(_data["playerId"]);
                    if (ps)
                    {
                        var controllable = this.getObjectById(ps["controllableId"]);
                        if (controllable)
                        {
                            switch (controllable.data["type"])
                            {
                                case "rocket":
                                    var rad = this.Angle(controllable.position[0], controllable.position[1], _data["worldX"], _data["worldY"]);                                    
                                    controllable.angle = rad;
                                    break;

                                case "helicopter":
                                    var muzzlePos = this.getMuzzlePosition(controllable);
                                    rad = this.WrapAngle(this.Angle(muzzlePos[0], muzzlePos[1], _data["worldX"], _data["worldY"]), true);
                                    controllable.data["desiredAimRotation"] = rad;
                                    controllable.data["aimPos"][0] = _data["worldX"];
                                    controllable.data["aimPos"][1] = _data["worldY"];
                                    break;

                                case "turret":
                                    controllable.data["aimPos"][0] = _data["worldX"];
                                    controllable.data["aimPos"][1] = _data["worldY"];
                                    break;
                            }
                        }
                    }
                    _data.bServerSideOnly = true;
                    break;

                case GameServer.EVENT_PLAYER_INPUT:
                    var keyInfo = _data["keyInfo"];
                    if (keyInfo)
                    {
                        ps = this.getPlayerStateById(_data["playerId"]);
                        var keys = Object.keys(keyInfo);
                        for (var i = 0; i < keys.length; i++)
                        {
                            var curKey = keys[i];
                            var sendData = {
                                keyId: curKey,
                                value: keyInfo[curKey]
                            };
                            if (ps && ps["controllableId"])
                            {
                                var controllablePawn = this.getObjectById(ps["controllableId"]);
                                this.handleControllableInput(controllablePawn, sendData);
                            }
                            else
                            {
                                var pawn = this.getObjectById(_data["playerId"]);
                                this.handlePlayerInput(pawn, sendData);
                            }
                        }
                    }
                    _data.bServerSideOnly = true;
                    break;

                case GameServer.EVENT_PLAYER_INTERACT:
                    if (!this.matchInProgress())
                    {
                        return;
                    }
                    ps = this.getPlayerStateById(_data["playerId"]);
                    pawn = this.getObjectById(_data["playerId"]);
                    if (ps && ps["controllableId"])
                    {
                        if (ps["bBot"])
                        {
                            break;
                        }
                        controllable = this.getObjectById(ps["controllableId"]);
                        if (controllable)
                        {
                            switch (controllable.data["type"])
                            {
                                case "helicopter":
                                    controllable.data["ammo"] = 0;
                                    this.pushObjectDataUpdate(controllable.data.id, ["ammo"]);
                                    break;

                                case "turret":
                                    this.clearPlayerControllable(ps);
                                    if (pawn)
                                    {
                                        pawn.wakeUp();
                                    }
                                    break;

                                case "car":
                                    switch (controllable.data.carType)
                                    {
                                        case Car.TYPE_RCXD:
                                            controllable.data["bWantsToFire"] = true;
                                            break;
                                    }
                                    break;
                            }
                        }
                    }
                    else
                    {
                        if (pawn)
                        {
                            //If no interactable to interact with
                            if (!_data["interactableId"])
                            {
                                var bC4 = false;
                                var equipment = pawn.data.equipment;
                                if (equipment)
                                {
                                    switch (equipment["id"])
                                    {
                                        case "c4":
                                            var grenades = this.getGrenades(pawn.data["id"], "c4");
                                            for (var i = 0; i < grenades.length; i++)
                                            {
                                                this.detonate(grenades[i]);
                                                bC4 = true;
                                            }
                                            break;
                                    }
                                }
                                if (!bC4)
                                {
                                    var turret = this.getPlayerControllableTurret(pawn.data.id);
                                    if (turret)
                                    {
                                        this.executeInteractable(turret, pawn.data.id);
                                    }
                                }
                            }
                            else
                            {
                                if (!pawn.data["bBot"] && pawn.data["bWantsToInteract"])
                                {
                                    this.stopCharacterInteract(pawn);
                                }
                                else
                                {
                                    var interactable = this.getObjectById(_data["interactableId"]);
                                    if (interactable && this.characterCanInteract(pawn, interactable))
                                    {
                                        if (interactable.data["bLimitInteractions"])
                                        {
                                            interactable.data["currentPawnId"] = pawn.data["id"];
                                        }
                                        var interactData = interactable.data["interactData"];
                                        var interactTime = interactData ? interactData["interactTime"] : 0;
                                        if (interactable.data.type == "crate" && interactable.data.interactData.type == Crate.CRATE_STORE)
                                        {
                                            if (ps && ps.money == null)
                                            {
                                                ps.money = 100000;
                                                this.onEvent({
                                                    eventId: GameServer.EVENT_PLAYER_UPDATE,
                                                    playerId: ps["id"],
                                                    data: {
                                                        money: ps.money
                                                    }
                                                });
                                            }
                                        }
                                        if (interactTime > 0)
                                        {
                                            switch (interactable.data.type)
                                            {
                                                case "crate":
                                                    if (this.localData["bBattlezone"])
                                                    {
                                                        interactTime = this.localData.settings.fps * Battlezone.CRATE_INTERACT_TIME;
                                                    }
                                                    else 
                                                    {
                                                        if (interactData["ownerId"] && interactData["ownerId"] != pawn.data["id"])
                                                        {
                                                            interactTime = this.localData.settings.fps * 3;
                                                        }
                                                    }
                                                    break;

                                                case "reviver":
                                                    this.onEvent({
                                                        eventId: GameServer.EVENT_PAWN_ACTION,
                                                        pawnId: pawn.data.id,
                                                        type: GameServer.PAWN_START_REVIVE
                                                    });
                                                    break;
                                            }
                                            this.cancelCharacterBoltPull(pawn);
                                            this.cancelCharacterReload(pawn);
                                            pawn.velocity = [0, 0];
                                            pawn.data["bWantsToInteract"] = true;
                                            pawn.data["interactTimer"] = interactTime;
                                            pawn.data["interactableId"] = _data["interactableId"];
                                            this.requestEvent({
                                                eventId: GameServer.EVENT_PAWN_ACTION,
                                                pawnId: pawn.data["id"],
                                                type: GameServer.PAWN_START_INTERACTION,
                                                timer: interactTime
                                            });
                                        }
                                        else
                                        {
                                            this.executeInteractable(interactable, _data["playerId"]);
                                        }
                                    }
                                }
                            }
                        }
                    }
                    _data.bServerSideOnly = true;
                    break;

                case GameServer.EVENT_PLAYER_UPDATE_INVENTORY:
                    var pawn = this.getObjectById(_data["pawnId"]);
                    if (pawn)
                    {                        
                        var inventory = pawn.data["inventory"];
                        if (_data["bRemoveEquipment"])
                        {
                            pawn.data.equipment = null;
                            _data["equipment"] = null;
                        }
                        if (typeof _data.type !== "number")
                        {
                            console.warn("Invalid type:", _data.type);
                        }
                        switch (_data["type"])
                        {
                            case GameServer.INV_PERK_ADD:
                                var perks = pawn.data["perks"];
                                if (perks)
                                {
                                    if (perks.indexOf(_data["perkId"]) == -1)
                                    {
                                        perks.push(_data["perkId"]);
                                    }
                                }
                                this.updateCharacterPerks(pawn);
                                _data["perks"] = perks;
                                break;

                            case GameServer.INV_PERKS:
                                var perks = pawn.data["perks"];
                                this.updateCharacterPerks(pawn);
                                _data["perks"] = perks;
                                break;

                            case GameServer.INV_PERKS_SET:
                                pawn.data["perks"] = _data["perks"];
                                this.updateCharacterPerks(pawn);
                                break;

                            case GameServer.INV_FIRE:
                                var curItem = inventory[_data["index"]];
                                if (_data["bBarrel"])
                                {
                                    _data["item"] = curItem;
                                }
                                else
                                {
                                    if (!this.isMeleeWeapon(curItem))
                                    {
                                        curItem["mag"]--;
                                        if (curItem["bBoltAction"])
                                        {
                                            curItem["bNeedsBoltPull"] = true;
                                        }
                                        _data["item"] = curItem;
                                    }
                                }
                                break;

                            case GameServer.INV_CLASS_DATA:
                                if (!this.localData.gameModeData["bNoClasses"] && this.localData["bModeGame"])
                                {
                                    var ps = this.getPlayerStateById(_data["pawnId"]);
                                    if (ps && ps.bVIP)
                                    {
                                        _data = {};
                                    }
                                    else
                                    {
                                        var primary = this.getWeaponData(_data["primary"]["id"]);
                                        this.applyWeaponMods(primary, _data["primary"]["mods"], pawn ? pawn.data.id : null);
                                        var secondary = this.getWeaponData(_data["secondary"]["id"]);
                                        this.applyWeaponMods(secondary, _data["secondary"]["mods"], pawn ? pawn.data.id : null);
                                        var newEquipment = this.getWeaponData(_data["equipment"]);
                                        pawn.data["inventory"] = [primary, secondary];
                                        pawn.data["equipment"] = newEquipment;
                                        delete pawn.data["bBandolier"];
                                        this.setCharacterCurrentInventoryItem(pawn, 0);
                                        _data["inventory"] = pawn.data["inventory"];
                                        _data["equipment"] = pawn.data["equipment"];
                                        _data["currentInventoryIndex"] = 0;
                                        var perks = [
                                            _data["playerPerk"],
                                            _data["weaponPerk"]
                                        ];
                                        pawn.data.perks = perks;
                                        this.updateCharacterPerks(pawn);
                                        _data["perks"] = perks;
                                    }
                                }
                                else
                                {
                                    _data = {};
                                }
                                break;

                            case GameServer.INV_MOD_SET:
                                var weapon = pawn.data["inventory"][_data["index"]];
                                if (weapon)
                                {
                                    var mods = weapon["mods"] ? weapon["mods"] : {};
                                    mods[_data["modType"]] = _data["modId"];
                                    this.applyWeaponMods(weapon, mods);
                                    _data["inventory"] = pawn.data["inventory"];
                                }
                                break;

                            case GameServer.INV_EQUIPMENT_SET:
                                var equipmentData = this.getWeaponData(_data["value"]);
                                if (equipmentData)
                                {
                                    if (_data["ammo"] != undefined)
                                    {
                                        equipmentData["ammo"] = _data["ammo"];
                                    }
                                    pawn.data["equipment"] = equipmentData;                                
                                    _data["equipment"] = pawn.data["equipment"];
                                }
                                break;

                            case GameServer.INV_EQUIPMENT_ADD:
                                var equipment = pawn.data["equipment"];
                                if (equipment)
                                {
                                    equipment["ammo"] += _data["value"];
                                    equipment["ammo"] = Math.min(equipment["ammo"], equipment["ammoMax"]);
                                }
                                _data["equipment"] = equipment;
                                break;

                            case GameServer.INV_AMMO:
                                inventory[_data["index"]]["ammo"] = _data["value"];
                                _data["item"] = inventory[_data["index"]];
                                break;

                            case GameServer.INV_AMMO_ADD:
                                inventory[_data["index"]]["ammo"] += _data["value"];
                                inventory[_data["index"]]["ammo"] = Math.min(inventory[_data["index"]]["ammo"], 999);
                                if (_data["barrelAmmo"] > 0 && inventory[_data["index"]]["barrelId"])
                                {
                                    inventory[_data["index"]]["barrelAmmo"] = Math.min(inventory[_data["index"]]["barrelAmmo"] + 1, inventory[_data["index"]]["barrelAmmoMax"]);
                                }
                                _data["item"] = inventory[_data["index"]];
                                break;

                            case GameServer.INV_MAG:
                                inventory[_data["index"]]["mag"] = _data["value"];
                                _data["item"] = inventory[_data["index"]];
                                break;

                            case GameServer.INV_MAG_ADD:
                                inventory[_data["index"]]["mag"] += _data["value"];
                                _data["item"] = inventory[_data["index"]];
                                break;

                            case GameServer.INV_BURSTS:
                                inventory[_data["index"]]["bursts"] = _data["value"];
                                _data["item"] = inventory[_data["index"]];
                                break;

                            case GameServer.INV_BURSTS_ADD:
                                inventory[_data["index"]]["bursts"] += _data["value"];
                                _data["item"] = inventory[_data["index"]];
                                break;

                            case GameServer.INV_ITEM:
                                _data["item"] = inventory[_data["index"]];
                                break;

                            case GameServer.INV_ITEM_ADD:
                                if (inventory.length == 2)
                                {
                                    inventory.splice(0, 1);
                                }
                                inventory.push(_data["item"]);
                                this.setCharacterCurrentInventoryItem(pawn, 1);
                                _data["currentInventoryIndex"] = 1;
                                _data["inventory"] = inventory;
                                break;

                            case GameServer.INV_ITEM_REPLACE:     
                                inventory[_data["index"]] = _data["item"];
                                if (_data["index"] == pawn.data["currentInventoryIndex"])
                                {
                                    this.setCharacterCurrentInventoryItem(pawn, _data["index"]);
                                }
                                _data["inventory"] = inventory;
                                break;

                            case GameServer.INV_INVENTORY_REPLACE:
                                pawn.data["inventory"] = _data["inventory"];
                                this.setCharacterCurrentInventoryItem(pawn, 0);
                                _data["currentInventoryIndex"] = 0;
                                _data["inventory"] = _data["inventory"];
                                break;

                            case GameServer.INV_CURRENT_INVENTORY_INDEX:
                                if (!pawn.data.weapon["bFireDelay"] && !pawn.data["bWantsToInteract"] && !pawn.data["bShieldCooldown"])
                                {
                                    this.setCharacterCurrentInventoryItem(pawn, _data["value"]);
                                    _data["currentInventoryIndex"] = _data["value"];
                                    var curItem = pawn.data.inventory[_data["value"]];
                                    if (pawn.data["bIsReloading"])
                                    {
                                        _data["bReload"] = true;
                                    }
                                }
                                break;

                            case GameServer.INV_INVENTORY:
                                _data["inventory"] = inventory;
                                break;

                            case GameServer.INV_EQUIPMENT:
                                _data["equipment"] = pawn.data["equipment"];
                                break;
                        }
                    }
                    break;

                case GameServer.EVENT_PLAYER_TRIGGER_WEAPON:
                    var value = _data["value"];
                    ps = this.getPlayerStateById(_data["playerId"]);
                    controllable = ps ? this.getObjectById(ps["controllableId"]) : null;
                    if (controllable)
                    {
                        switch (controllable.data["type"])
                        {
                            case "rocket":
                                if (value)
                                {
                                    this.detonate(controllable);
                                }
                                break;

                            case "helicopter":
                                controllable.data["bWantsToFire"] = value;
                                break;

                            case "turret":
                                controllable.data["bWantsToFire"] = value;
                                break;

                            case "car":
                                controllable.data["bWantsToFire"] = value;
                                break;
                        }
                    }
                    else
                    {
                        pawn = this.getObjectById(_data["playerId"]);                        
                        if (pawn)
                        {
                            if (_data["worldPosition"])
                            {
                                pawn.data["inputPosition"] = _data["worldPosition"];
                            }
                            if (_data["bBarrel"])
                            {
                                cur = this.getCurrentCharacterInventoryItem(pawn);
                                if (_data["value"])
                                {
                                    if (cur["barrelAmmo"] > 0 && !pawn.data["bBarrelCooldown"] && !pawn.data["bWantsToFire"] && this.characterCanFire(pawn, false))
                                    {
                                        pawn.data["bBarrelCooldown"] = true;
                                        var muzzlePos = this.getCharacterMuzzlePosition(pawn);
                                        switch (cur["barrelId"])
                                        {
                                            case Mods.BARREL_GP25:
                                            case Mods.BARREL_M203:
                                                pawn.data["barrelCooldownTimer"] = Math.round(this.localData.settings.fps * 1.5);
                                                var barrelWeapon = this.getWeaponData("thumper");
                                                barrelWeapon.damage = 350;
                                                barrelWeapon.radius = 300;
                                                this.createGrenade(muzzlePos, {
                                                    bImpact: true,
                                                    team: pawn.data["team"],
                                                    playerId: pawn.data["id"],
                                                    causerId: pawn.data["id"],
                                                    rotation: pawn.data["aimRotation"],
                                                    velocity: barrelWeapon["velocity"] ? barrelWeapon["velocity"] : 1500,
                                                    damage: barrelWeapon["damage"],
                                                    weaponId: cur["barrelId"],
                                                    weaponData: barrelWeapon,
                                                    radius: barrelWeapon["radius"]
                                                }, true);
                                                break;

                                            case Mods.BARREL_MASTERKEY:
                                                pawn.data["barrelCooldownTimer"] = Math.round(this.localData.settings.fps * 0.5);
                                                barrelWeapon = this.getWeaponData("m3");
                                                barrelWeapon.accuracy = 10;
                                                var bIgnoreObstacles = (this.localData["bSurvival"] && pawn.data["team"] == 0);
                                                var numBullets = 6;
                                                for (var i = 0; i < numBullets; i++)
                                                {
                                                    var rad = pawn.data["aimRotation"];
                                                    var useAccuracy = (barrelWeapon["accuracy"] * pawn.data["accuracyMultiplier"] * (pawn.data["bWantsToCrouch"] ? 0.8 : 1)) * 10;
                                                    var bulletRad = rad + this.ToRad(this.Random(-useAccuracy, useAccuracy) * 0.1);
                                                    this.createBullet(muzzlePos[0], muzzlePos[1], bulletRad, barrelWeapon["range"], barrelWeapon["damage"], pawn.data["id"], pawn.data["id"], cur["barrelId"], barrelWeapon, true, false, bIgnoreObstacles);
                                                }
                                                break;
                                        }
                                        if (pawn.data["bUseExposeTimer"])
                                        {
                                            this.emitAISound(this.clone(pawn.position), pawn.data["team"]);
                                            pawn.data["bExposed"] = true;
                                            pawn.data["exposedTimer"] = this.localData.settings.fps * 2;
                                        }
                                        if (!pawn.data["bUnlimitedAmmo"])
                                        {
                                            cur["barrelAmmo"]--;
                                            this.requestEvent({
                                                eventId: GameServer.EVENT_PLAYER_UPDATE_INVENTORY,
                                                pawnId: pawn.data["id"],
                                                index: pawn.data["currentInventoryIndex"],
                                                type: GameServer.INV_FIRE,
                                                bBarrel: true
                                            });
                                        }
                                        this.requestEvent({
                                            eventId: GameServer.EVENT_PAWN_ACTION,
                                            pawnId: pawn.data["id"],
                                            type: GameServer.PAWN_FIRE_WEAPON,
                                            recoil: 5,
                                            bBarrel: true,
                                            barrelId: cur["barrelId"]
                                        });
                                    }
                                }                                
                            }
                            else
                            {
                                cur = this.getCurrentCharacterInventoryItem(pawn);
                                if (_data["value"])
                                {
                                    var bPrev = pawn.data["bWantsToFire"];
                                    pawn.data["bWantsToFire"] = true;
                                    if (cur["mag"] > 0)
                                    {
                                        if (!bPrev && !pawn.data.bIsReloading)
                                        {
                                            this.onStartWeaponFire(pawn);
                                        }
                                        pawn.data.weapon["bFireHandler"] = true;                                        
                                    }
                                    else
                                    {
                                        if (cur["ammo"] == 0 && !pawn.data.weapon["bUnlimitedAmmo"])
                                        {
                                            var otherIndex = pawn.data["currentInventoryIndex"] == 1 ? 0 : 1;
                                            var otherItem = pawn.data.inventory[otherIndex];
                                            if (otherItem)
                                            {
                                                if (otherItem["mag"] > 0 || otherItem["ammo"] > 0)
                                                {
                                                    this.requestEvent({
                                                        eventId: GameServer.EVENT_PLAYER_UPDATE_INVENTORY,
                                                        pawnId: pawn.data.id,
                                                        type: GameServer.INV_CURRENT_INVENTORY_INDEX,
                                                        value: otherIndex
                                                    });
                                                }
                                            }
                                            if (!pawn.data["bBot"])
                                            {
                                                if (this.characterIsFree(pawn))
                                                {
                                                    this.requestEvent({
                                                        eventId: GameServer.EVENT_PAWN_ACTION,
                                                        pawnId: pawn.data["id"],
                                                        type: GameServer.PAWN_NO_AMMO
                                                    });
                                                }
                                            }
                                        }
                                        else
                                        {
                                            this.reloadCharacterWeapon(pawn);
                                        }
                                    }
                                }
                                else
                                {
                                    if (pawn.data["bWantsToFire"])
                                    {
                                        this.onEndWeaponFire(pawn);
                                    }
                                    pawn.data["bWantsToFire"] = false;                                    
                                }
                            }
                        }
                    }
                    _data.bServerSideOnly = true;
                    break;

                case GameServer.EVENT_PLAYER_TRIGGER_EQUIPMENT:
                    pawn = this.getObjectById(_data["playerId"]);
                    if (pawn)
                    {
                        var equipment = pawn.data["equipment"];
                        if (equipment)
                        {
                            if (equipment["ammo"] > 0)
                            {
                                this.useCharacterEquipment(pawn, _data["worldX"], _data["worldY"]);
                            }
                            else
                            {
                                switch (equipment["id"])
                                {
                                    case "c4":
                                        var grenades = this.getGrenades(pawn.data["id"], "c4");
                                        for (var i = 0; i < grenades.length; i++)
                                        {
                                            this.detonate(grenades[i]);
                                        }
                                        break;
                                }
                            }
                        }
                    }
                    _data.bServerSideOnly = true;
                    break;

                case GameServer.EVENT_PLAYER_JOIN:
                    var playerData = _data["data"];
                    playerData["id"] = _data["playerId"];
                    playerData["team"] = _data.data["team"];

                    if (playerData["bBot"])
                    {
                        this.onEvent({
                            eventId: GameServer.EVENT_CREATE_AI_CONTROLLER,
                            playerId: playerData["id"],
                            botSkill: playerData["botSkill"]
                        });
                    }
                    else
                    {
                        this.onEvent({
                            eventId: GameServer.EVENT_SET_PLAYER_CONTROLLER_ID,
                            playerId: playerData["id"]
                        });
                    }
                    switch (this.localData.gameModeData["id"])
                    {
                        case GameMode.DEATHMATCH:
                            this.onEvent({
                                eventId: GameServer.EVENT_GAME_UPDATE,
                                gameModeData: this.localData["gameModeData"]
                            });
                            break;

                        case GameMode.INFECTED:
                            this.checkInfected();
                            break;
                    }
                    break;

                case GameServer.EVENT_PLAYER_LEAVE:
                    var pawn = this.getObjectById(_data["playerId"]);
                    if (this.localData["bBattlezone"])
                    {
                        if (pawn)
                        {
                            var ps = this.getPlayerStateById(_data["playerId"])
                            {
                                if (ps.shards > 0 || ps.xp > 0)
                                {
                                    this.createLootPack(pawn.position, {
                                        shards: ps.shards,
                                        xp: ps.xp
                                    });
                                }
                            }
                        }
                    }
                    else if (this.localData["bSurvival"])
                    {
                        if (pawn)
                        {
                            this.dropAllCharacterWeapons(pawn);
                        }
                    }
                    else
                    {
                        switch (this.localData.gameModeData.id)
                        {
                            case GameMode.ASSASSINATION:
                                var ps = this.getPlayerStateById(_data["playerId"]);
                                if (ps && ps.bVIP)
                                {
                                    this.winRound(MatchState.END_CONDITION_VIP_KILLED, this.localData.gameModeData.vipTeam == 0 ? 1 : 0, 1);
                                }
                                break;
                        }
                    }
                    this.removePlayerStateById(_data["playerId"]);
                    this.removeNextStep(pawn);
                    this.removeNextStep(this.getReviverByPlayerId(_data["playerId"]));
                    var helis = this.getHelicopters();
                    for (var i = 0; i < helis.length; i++)
                    {
                        var heli = helis[i];
                        if (heli.data.heliData["playerId"] == _data["playerId"])
                        {
                            this.removeNextStep(heli);
                        }
                    }
                    var turrets = this.getTurrets(_data["playerId"]);
                    for (var i = 0; i < turrets.length; i++)
                    {
                        this.removeNextStep(turrets[i]);
                    }
                    switch (this.localData.gameModeData["id"])
                    {
                        case GameMode.DEATHMATCH:
                            this.onEvent({
                                eventId: GameServer.EVENT_GAME_UPDATE,
                                gameModeData: this.localData["gameModeData"]
                            });
                            break;

                        case GameMode.INFECTED:
                            this.checkInfected();
                            break;

                        default:
                            this.checkAutoTeamBalance();
                            break;
                    }
                    break;

                case GameServer.EVENT_REQUEST_RANKED_CHARACTER:
                    ps = this.getPlayerStateById(_data["playerId"]);
                    if (ps)
                    {
                        if (!ps["avatarData"])
                        {
                            ps["avatarData"] = _data["avatarData"];
                        }
                        if (!ps["bHasPawn"])
                        {
                            if (this.matchInProgress() && this.localData.gameModeData["bSpawnProtection"] && !_data.data["bTacticalInsertion"])
                            {
                                this.startSpawnProtectionTimer(_data["playerId"]);
                            }
                            var newData = this.clone(_data);
                            newData["eventId"] = GameServer.EVENT_CREATE_RANKED_CHARACTER;
                            this.requestEvent(newData);
                        }
                    }
                    else
                    {
                        console.warn("Player id " + _data["playerId"] + " not found");
                    }
                    break;

                case GameServer.EVENT_CREATE_RANKED_CHARACTER:
                    if (this.getObjectById(_data["playerId"]))
                    {
                        this.log(_data["playerId"] + " already exists, don't create");
                    }
                    else
                    {
                        ps = this.getPlayerStateById(_data["playerId"]);
                        var data = _data.data;
                        if (!data["x"])
                        {
                            var map = this.getCurrentMapData();
                            var pos = { x: 0, y: 0 };
                            if (map)
                            {
                                var modeData = this.getGameModeData(this.localData["gameModeData"]["id"]);
                                if (this.localData["bSandbox"] && !this.matchInProgress())
                                {
                                    pos.x = map.spawn_store[0] + this.Random(-100, 100);
                                    pos.y = map.spawn_store[1];
                                }
                                else if (modeData["bTeam"] && (!this.matchInProgress() || this.roundHasEnded()))
                                {
                                    var spawns = map["spawns_team"];
                                    if (spawns)
                                    {
                                        var index = ps["team"];
                                        switch (this.localData.gameModeData["id"])
                                        {
                                            case GameMode.HEADQUARTERS:                                            
                                                index = ps["team"] == (this.localData.gameModeData["round"] + 1) % 2 == 0 ? 0 : 1;
                                                break;
                                            case GameMode.DEMOLITION:
                                                index = ps["team"] == this.localData.gameModeData["bombTeam"] ? 1 : 0;
                                                break;
                                            case GameMode.ASSASSINATION:
                                                index = ps["team"] == this.localData.gameModeData["vipTeam"] ? 0 : 1;
                                                break;
                                            case GameMode.RESCUE:
                                                index = ps["team"] == this.localData.gameModeData["rescueTeam"] ? 0 : 1;
                                                break;
                                        }
                                        var numOnTeam = this.getNumCharactersOnTeam(ps.team);
                                        var offset = (numOnTeam * 75) * (index == 0 ? 1 : -1);
                                        pos.x = spawns[index][0] + offset;
                                        pos.y = spawns[index][1];
                                    }
                                }
                                else
                                {
                                    var spawns = map["spawns"];
                                    if (spawns)
                                    {
                                        var bestSpawn = this.getBestSpawnPosition(ps["team"]);
                                        pos.x = bestSpawn[0];
                                        pos.y = bestSpawn[1];
                                    }
                                }
                            }
                            else
                            {
                                console.warn("Missing map data");
                            }
                            data["x"] = pos.x;
                            data["y"] = pos.y;
                        }
                        var char = this.createCharacter(_data["playerId"], [data["x"], data["y"]], ps["team"], ps["avatarData"], data["inventory"], data["equipment"], data["perks"]);
                        if (data["equipment"] && data["equipmentAmmo"] != undefined)
                        {
                            char.data["equipment"]["ammo"] = data["equipmentAmmo"];
                        }
                        if (char.data["equipment"])
                        {
                            data["equipmentAmmo"] = char.data["equipment"]["ammo"];
                        }
                        data["inventory"] = char.data["inventory"];
                        data["maxHealth"] = char.data["maxHealth"];
                        data["reloadMultiplier"] = char.data["reloadMultiplier"];
                        data["maxSpeed"] = char.data["maxSpeed"];

                        ps["bAutoRespawn"] = true;
                        if (ps["bBot"])
                        {
                            char.data["bBot"] = true;
                            this.setPawnAI(char, ps["botSkill"], false);
                            switch (this.localData.gameModeData["id"])
                            {
                                case GameMode.DOMINATION:
                                case GameMode.CAPTURE_THE_FLAG:
                                    char.data.ai["bObjectiveTakesPriority"] = this.Random(1, 4) > 1;
                                    break;

                                case GameMode.DEFENDER:
                                case GameMode.DEMOLITION:
                                case GameMode.HEADQUARTERS:
                                    char.data.ai["bObjectiveTakesPriority"] = this.Random(1, 2) > 1;
                                    break;

                                case GameMode.ASSASSINATION:
                                    char.data.ai["bObjectiveTakesPriority"] = true;
                                    break;
                            }
                        }
                        //Character damage multipliers
                        if (this.localData["bSandbox"])
                        {
                            if (char.data["team"] == 0)
                            {
                                //char.data.damageMultipliers[DamageType.DAMAGE_BULLET] = 0.15;
                                //char.data.damageMultipliers[DamageType.DAMAGE_EXPLOSIVE] = 0.5;
                            }
                        }
                        else if (this.localData["bBattlezone"])
                        {
                            if (!char.data["bBot"])
                            {
                                char.data.damageMultipliers[DamageType.DAMAGE_BULLET] = 0.5;
                                char.data.damageMultipliers[DamageType.DAMAGE_MELEE] = 0.5;
                                char.data.damageMultipliers[DamageType.DAMAGE_EXPLOSIVE] = 0.75;
                            }
                        }
                        else if (this.localData["bSurvival"])
                        {
                            if (char.data["team"] == 0)
                            {
                                char.data.damageMultipliers[DamageType.DAMAGE_BULLET] = 0.15;
                                char.data.damageMultipliers[DamageType.DAMAGE_EXPLOSIVE] = 0.5;
                                if (char.data["bBot"])
                                {
                                    var ai = char.data.ai;
                                    ai["bCanInteract"] = true;
                                    ai["bCanCamp"] = false;
                                    ai["bUseActivityTimer"] = false;
                                    ai["bLOS"] = false; 
                                }
                            }
                        }
                        else if (this.localData["bOperation"])
                        {
                            if (char.data["team"] == 0)
                            {
                                char.data.damageMultipliers[DamageType.DAMAGE_BULLET] = 0.15 + (this.localData.difficulty * 0.1);
                                char.data.damageMultipliers[DamageType.DAMAGE_MELEE] = 0.5 + (this.localData.difficulty * 0.1);
                                char.data.damageMultipliers[DamageType.DAMAGE_EXPLOSIVE] = 0.25 + (this.localData.difficulty * 0.2);
                                char.data.damageMultipliers[DamageType.DAMAGE_FIRE] = 0.25 + (this.localData.difficulty * 0.2);
                            }
                        }
                        else
                        {
                            if (char.data["bBot"])
                            {
                                var ai = char.data.ai;
                                ai["bCanInteract"] = true;
                                ai["bCamp"] = this.Random(1, 5) == 1;
                            }
                        }

                        char.data["bGodMode"] = data["bGodMode"];
                        char.data.weapon["bUnlimitedAmmo"] = data["bUnlimitedAmmo"];

                        ps["bHasPawn"] = true;
                        this.onEvent({
                            eventId: GameServer.EVENT_PLAYER_UPDATE,
                            playerId: ps["id"],
                            data: {
                                bAutoRespawn: ps["bAutoRespawn"],
                                bHasPawn: ps["bHasPawn"]
                            }
                        });

                        this.setCharacterCurrentInventoryItem(char, 0);
                    }
                    break;

                case GameServer.EVENT_CREATE_GENERIC_CHARACTER:
                    var data = _data.data;
                    char = this.createCharacter(data["id"], [data["x"], _data.data["y"]], data["team"], data["avatarData"], data["inventory"], data["equipment"], data["perks"]);
                    if (this.localData["bSurvival"] || this.localData["bBattlezone"])
                    {
                        char.data["inventory"][0]["ammo"] = Math.round(char.data["inventory"][0]["ammo"] * Math.random());
                    }
                    else
                    {
                        char.data["inventory"][0]["ammo"] = 0;
                    }
                    char.data.weapon["bUnlimitedAmmo"] = true;
                    char.data["bBot"] = true;
                    this.setPawnAI(char, data["botSkill"], data["bZombie"], data["bHero"]);
                    if (data.bDummy)
                    {
                        char.data.ai["bDisabled"] = true;
                    }
                    if (data.bFailIfKilled)
                    {
                        char.data.bFailIfKilled = data.bFailIfKilled;
                    }
                    if (data.bHostage)
                    {
                        char.data["bHostage"] = true;
                        char.data["bGodMode"] = !this.localData["bOperation"] && !this.localData["bSandbox"];
                        char.data["bExposed"] = true;
                        char.data["bUseExposeTimer"] = false;
                        char.data.ai["hostagePos"] = this.clone(char.position);
                        if (this.localData["bOperation"])
                        {
                            data["damageMultipliers"] = {};
                            data["damageMultipliers"][DamageType.DAMAGE_BULLET] = 0.2 + (this.localData.difficulty * 0.1);
                        }
                    }
                    char.data.ai["bLOS"] = false;
                    char.data.ai["bObjectiveTakesPriority"] = false;
                    char.data.ai["bCanCamp"] = false;
                    var ai = data.ai;
                    if (ai)
                    {
                        var keys = Object.keys(ai);
                        for (var i = 0; i < keys.length; i++)
                        {
                            var key = keys[i];
                            char.data.ai[key] = ai[key];
                        }
                    }
                    char.data["bRegenHealth"] = data["bRegenHealth"];
                    if (data.regenAmount)
                    {
                        char.data.regenAmount = data.regenAmount;
                    }
                    if (char.data["pawnName"])
                    {
                        char.data["pawnName"] = data["pawnName"];
                    }
                    if (char.data.bHero)
                    {
                        data.bHero = char.data.bHero;
                    }
                    if (data["perks"])
                    {
                        char.data["perks"] = data["perks"];
                    }
                    if (data["health"] != undefined)
                    {
                        char.data["health"] = char.data["maxHealth"] = data["health"];
                        data["maxHealth"] = data["health"];
                    }
                    if (data["killReward"] != undefined)
                    {
                        char.data["killReward"] = data["killReward"];
                    }
                    if (data["bZombie"] != undefined)
                    {
                        char.data["bZombie"] = data["bZombie"];
                        if (char.data["bZombie"])
                        {
                            char.data.ai["lookRange"] = Number.MAX_VALUE;
                            char.data["zombieType"] = data["zombieType"];
                            if (this.localData["bSurvival"])
                            {
                                char.data.ai["bLOS"] = false;
                                var baseSpeed = 200;
                                var wave = this.localData["gameModeData"]["wave"];
                                var waveIncreaseSpeed = 5;
                                if (wave > waveIncreaseSpeed)
                                {
                                    baseSpeed = Math.min(baseSpeed + (((wave - waveIncreaseSpeed) - 1) * 20), 300);
                                }
                                char.data["maxSpeed"] = baseSpeed * (this.Random(80, 100) * 0.01);
                            }
                            else if (this.localData["bOperation"])
                            {
                                char.data["maxSpeed"] = (200 + (this.localData["difficulty"] * 15)) * (this.Random(80, 100) * 0.01);
                                char.data["health"] = char.data["maxHealth"] = (data["health"] * this.localData["difficulty"]);
                            }
                            else
                            {
                                char.data["maxSpeed"] = 200 * (this.Random(100, 120) * 0.01);
                            }
                        }
                    }
                    if (data["damageMultipliers"] != undefined)
                    {
                        var keys = Object.keys(data["damageMultipliers"]);
                        for (var i = 0; i < keys.length; i++)
                        {
                            char.data.damageMultipliers[keys[i]] = data["damageMultipliers"][keys[i]];
                        }
                    }
                    else
                    {
                        if (data["bZombie"])
                        {
                            char.data.damageMultipliers[DamageType.DAMAGE_EXPLOSIVE] = 2;
                            char.data.damageMultipliers[DamageType.DAMAGE_FIRE] = 2;
                        }
                    }
                    if (data["maxSpeed"] != undefined)
                    {
                        char.data["maxSpeed"] = data["maxSpeed"];
                    }
                    if (data["baseSpeedMultiplier"] != undefined)
                    {
                        char.data["baseSpeedMultiplier"] = data["baseSpeedMultiplier"];
                    }

                    if (this.localData["bSurvival"] || this.localData["bSandbox"] || this.isTutorial())
                    {
                        char.data["bUseExposeTimer"] = false;
                        char.data["bExposed"] = true;
                    }

                    data["bExposed"] = char.data["bExposed"];
                    this.setCharacterCurrentInventoryItem(char, 0);
                    data["inventory"] = this.clone(char.data["inventory"]);
                    break;

                case GameServer.EVENT_CREATE_INFESTOR:
                    var data = _data.data;
                    var infestor = this.createInfestor(data["id"], [data["x"], data["y"]], data["team"], data["infestorType"]);
                    infestor.data["bBot"] = true;
                    this.setPawnAI(infestor, _data.data["botSkill"], true);
                    infestor.data.ai["bPreferDistance"] = true;
                    infestor.data.ai["bLOS"] = false;
                    infestor.data.ai["bCanCamp"] = false;
                    var ai = data.ai;
                    if (ai)
                    {
                        var keys = Object.keys(ai);
                        for (var i = 0; i < keys.length; i++)
                        {
                            var key = keys[i];
                            infestor.data.ai[key] = ai[key];
                        }
                    }
                    if (data["damageMultipliers"] != undefined)
                    {
                        var keys = Object.keys(data["damageMultipliers"]);
                        for (var i = 0; i < keys.length; i++)
                        {
                            infestor.data.damageMultipliers[keys[i]] = data["damageMultipliers"][keys[i]];
                        }
                    }
                    else
                    {
                        infestor.data.damageMultipliers[DamageType.DAMAGE_EXPLOSIVE] = 2;
                        infestor.data.damageMultipliers[DamageType.DAMAGE_FIRE] = 3;
                    }
                    if (this.localData["bOperation"])
                    {
                        infestor.data["maxSpeed"] = this.getSharedData(data["infestorType"])["maxSpeed"] + (this.localData["difficulty"] * 30) * (this.Random(80, 100) * 0.01);
                        infestor.data["health"] = infestor.data["maxHealth"] = (data["health"] + (150 * (this.localData["difficulty"] - 1)));
                    }
                    else
                    {
                        infestor.data["health"] = infestor.data["maxHealth"] = data["health"];
                        infestor.data["killReward"] = data["killReward"];
                        var baseSpeed = this.getSharedData(data["infestorType"])["maxSpeed"];
                        if (this.localData["bSandbox"])
                        {
                            infestor.data["maxSpeed"] = baseSpeed * (this.Random(100, 120) * 0.01);
                        }
                        else if (this.localData["bSurvival"])
                        {                            
                            var wave = this.localData["gameModeData"]["wave"];
                            var waveIncreaseSpeed = 10;
                            if (wave > waveIncreaseSpeed)
                            {
                                baseSpeed = Math.min(baseSpeed + (((wave - waveIncreaseSpeed) - 1) * 25), 550);
                            }
                            infestor.data["maxSpeed"] = baseSpeed;
                        }
                    }
                    break;

                case GameServer.EVENT_PLAYER_OPEN_WORLD_MENU:
                    if (!_data["killstreakId"])
                    {
                        var char = this.getObjectById(_data["playerId"]);
                        if (char && !char.data.bIsOnLadder && !this.characterHasWeaponDelay(char))
                        {
                            this.cancelCharacterReload(char);
                            this.cancelCharacterBoltPull(char);
                            this.stopCharacterInteract(char);
                            char.data.weapon["bUseDelay"] = true;
                            this.requestEvent({
                                eventId: GameServer.EVENT_PAWN_ACTION,
                                pawnId: char.data["id"],
                                type: GameServer.PAWN_OPEN_LAPTOP
                            });
                        }
                        else
                        {
                            _data = {};
                        }
                    }
                    break;

                case GameServer.EVENT_PAWN_DAMAGE:
                    damageAmount = _data["damageAmount"];
                    if (!this.matchInProgress())
                    {
                        break;
                    }
                    if (isNaN(damageAmount))
                    {
                        damageAmount = 0;
                        this.log("Invalid damage amount", _data);
                    }
                    var pawnToDamage = this.getObjectById(_data["pawnId"]);
                    var killer = this.getPlayerStateById(_data["attackerId"]);
                    var killerChar = this.getObjectById(_data["attackerId"]);
                    if (pawnToDamage)
                    {                        
                        var bHitmarker = true;
                        if (pawnToDamage.data["bGodMode"])
                        {
                            break;
                        }
                        if (pawnToDamage.data["type"] == "door") // && _data["damageType"] != DamageType.DAMAGE_EXPLOSIVE)
                        {
                            bHitmarker = false;
                            break;
                        }
                        else if (pawnToDamage.data["type"] == "obstacle")
                        {
                            bHitmarker = false;
                        }
                        _data["bHitmarker"] = bHitmarker == true ? 1 : 0;
                        if (pawnToDamage.data["health"] > 0)
                        {
                            if (this.localData["bBattlezone"])
                            {
                                if (killer && this.getPlayerStateById(_data["pawnId"]))
                                {
                                    damageAmount *= 0.5;
                                }
                            }
                            var causer = this.getObjectById(_data["causerId"]);
                            var damageMultipliers = pawnToDamage.data["damageMultipliers"];
                            if (damageMultipliers)
                            {                                
                                if (damageMultipliers[_data["damageType"]] != undefined)
                                {
                                    damageAmount *= damageMultipliers[_data["damageType"]];
                                }
                            }
                            if (_data["damageType"] == DamageType.DAMAGE_EXPLOSIVE && this.characterHasPerk(pawnToDamage, Perks.PERK_PLAYER_SPECIALIST))
                            {
                                damageAmount = Math.min(this.getCharacterHealth() - 1, damageAmount * 0.35);
                            }
                            if (_data["damageType"] == DamageType.DAMAGE_FIRE && this.characterHasPerk(pawnToDamage, Perks.PERK_PLAYER_SPECIALIST))
                            {
                                damageAmount = damageAmount * 0.1;
                            }
                            damageAmount = Math.ceil(damageAmount);
                            pawnToDamage.data["health"] = Math.max(0, Math.round(pawnToDamage.data["health"] - damageAmount));
                            this.pushObjectDataUpdate(pawnToDamage.data.id, ["health"]);
                            if (pawnToDamage.data["bRegenHealth"])
                            {
                                pawnToDamage.data["regenTimer"] = pawnToDamage.data["regenTimerMax"];
                            }
                            if (pawnToDamage.data["type"] == "obstacle")
                            {
                                pawnToDamage.data["playerId"] = _data["attackerId"];
                            }
                            if (pawnToDamage.data["health"] <= 0)
                            {
                                _data["bKill"] = true;
                                switch (pawnToDamage.data["type"])
                                {
                                    case "door":
                                        this.removeNextStep(pawnToDamage);
                                        break;

                                    case "obstacle":
                                        switch (pawnToDamage.data["obstacleId"])
                                        {
                                            case "barrel_explosive":
                                                this.detonate(pawnToDamage);
                                                break;

                                            default:
                                                this.removeNextStep(pawnToDamage);
                                                break;
                                        }
                                        break;

                                    case "destructableObject":
                                        this.removeNextStep(pawnToDamage);
                                        break;

                                    case "rocket":
                                        this.detonate(pawnToDamage);
                                        break;

                                    default:
                                        var bTeamKill = !bSuicide && killer ? (killer["team"] == pawnToDamage.data["team"]) : false;
                                        if (pawnToDamage.data.bHostage)
                                        {
                                            bTeamKill = true;
                                        }
                                        if (pawnToDamage.data["type"] == "character")
                                        {
                                            if (pawnToDamage.data.bHostage)
                                            {
                                                pawnToDamage.data.ai.moveDirX = 1;
                                            }
                                            if (this.localData["bRanked"])
                                            {
                                                var victim = this.getPlayerStateById(_data["pawnId"]);
                                                if (killer && victim)
                                                {
                                                    var bSuicide = killer == victim;
                                                    this.onEvent({
                                                        eventId: GameServer.EVENT_KILLFEED_ADD,
                                                        type: FeedItem.TYPE_KILL,
                                                        killerId: killer["id"],
                                                        killerName: killer["name"],
                                                        killerClan: killer["clan"],
                                                        killerTeam: killer["team"],
                                                        victimId: victim["id"],
                                                        victimName: victim["name"],
                                                        victimClan: victim["clan"],
                                                        victimTeam: victim["team"],
                                                        weaponId: _data["weaponId"],
                                                        bHeadshot: _data["bHeadshot"],
                                                        bDirectImpact: _data["bDirectImpact"],
                                                        bSuicide: bSuicide
                                                    });
                                                }
                                                else if (this.localData["bBattlezone"])
                                                {
                                                    var killerName = null;
                                                    if (killerChar)
                                                    {
                                                        switch (killerChar.data.type)
                                                        {                                                            
                                                            case "infestor":
                                                                killerName = "Infestor";
                                                                break;
                                                            default:
                                                                killerName = killerChar.data.bZombie ? "Zombie" : "Mercenary";
                                                                break;
                                                        }
                                                    }
                                                    else
                                                    {
                                                        killerName = "Mercenary";
                                                    }
                                                    if (killerName && victim)
                                                    {
                                                        this.onEvent({
                                                            eventId: GameServer.EVENT_KILLFEED_ADD,
                                                            type: FeedItem.TYPE_KILL,
                                                            killerName: killerName,
                                                            killerTeam: killerChar ? killerChar.data.team : null,
                                                            victimId: victim ? victim["id"] : null,
                                                            victimName: victim ? victim["name"] : null,
                                                            victimClan: victim ? victim["clan"] : null,
                                                            victimTeam: victim ? victim["team"] : null,
                                                            weaponId: _data["weaponId"],
                                                            bHeadshot: _data["bHeadshot"],
                                                            bDirectImpact: _data["bDirectImpact"],
                                                            bSuicide: bSuicide
                                                        });
                                                    }
                                                }
                                            }
                                        }
                                        var xpReward = pawnToDamage.data["xpReward"];
                                        var damageInfo = {
                                            type: pawnToDamage.data["type"],
                                            damageType: _data["damageType"],
                                            weaponId: _data["weaponId"]
                                        };
                                        switch (pawnToDamage.data["type"])
                                        {
                                            case "helicopter":
                                            case "turret":
                                            case "car":
                                                damageInfo["killstreakId"] = pawnToDamage.data["killstreakId"];
                                                break;                                            
                                        }
                                        if (_data["bDirectlyCausedByPlayer"])
                                        {
                                            damageInfo["bDirectlyCausedByPlayer"] = true;
                                        }
                                        if (_data["bTeamKill"] || bTeamKill)
                                        {
                                            damageInfo["bTeamKill"] = true;
                                        }
                                        else if (!this.localData["bSurvival"])
                                        {
                                            damageInfo["xpReward"] = xpReward;
                                        }
                                        if (_data["bMelee"])
                                        {
                                            damageInfo["bMelee"] = true;
                                        }
                                        if (bSuicide)
                                        {
                                            damageInfo["bSuicide"] = true;
                                        }
                                        if (_data["bHeadshot"])
                                        {
                                            damageInfo["bHeadshot"] = true;
                                        }
                                        if (_data["bDirectImpact"])
                                        {
                                            damageInfo["bDirectImpact"] = true;
                                        }
                                        if (_data["bLongshot"])
                                        {
                                            damageInfo["bLongshot"] = true;
                                        }
                                        if (_data["bNearshot"])
                                        {
                                            damageInfo["bNearshot"] = true;
                                        }
                                        if (pawnToDamage.data["type"] == "character")
                                        {
                                            switch (this.localData.gameModeData["id"])
                                            {
                                                case GameMode.DOMINATION:
                                                case GameMode.HEADQUARTERS:
                                                case GameMode.DEMOLITION:
                                                    if (this.isNearFriendlyFlag(pawnToDamage))
                                                    {
                                                        damageInfo["bOffensiveKill"] = true;
                                                    }
                                                    else if (this.isNearEnemyFlag(pawnToDamage))
                                                    {
                                                        damageInfo["bDefensiveKill"] = true;
                                                    }
                                                    break;

                                                case GameMode.DEFENDER:
                                                case GameMode.CAPTURE_THE_FLAG:
                                                    if (this.isHoldingFlag(pawnToDamage))
                                                    {
                                                        damageInfo["bEnemyHoldingFlag"] = true;
                                                    }
                                                    break;

                                                case GameMode.ASSASSINATION:
                                                    if (killer && killer.bVIP)
                                                    {
                                                        damageInfo["bOffensiveKill"] = true;
                                                    }
                                                    break;
                                            }
                                        }
                                        if (killerChar)
                                        {
                                            if (killerChar.data["type"] == "character")
                                            {
                                                switch (this.localData.gameModeData["id"])
                                                {
                                                    case GameMode.DOMINATION:
                                                    case GameMode.HEADQUARTERS:
                                                    case GameMode.DEMOLITION:
                                                        if (this.isNearFriendlyFlag(killerChar))
                                                        {
                                                            damageInfo["bDefensiveKill"] = true;
                                                        }
                                                        else if (this.isNearEnemyFlag(killerChar))
                                                        {
                                                            damageInfo["bOffensiveKill"] = true;
                                                        }
                                                        break;

                                                    case GameMode.DEFENDER:
                                                    case GameMode.CAPTURE_THE_FLAG:
                                                        if (this.isHoldingFlag(killerChar))
                                                        {
                                                            damageInfo["bOffensiveKill"] = true;
                                                        }
                                                        break;
                                                }
                                            }
                                        }
                                        if (causer)
                                        {                                            
                                            if (causer.data["type"] == "helicopter")
                                            {
                                                damageInfo["bHeli"] = true;
                                            }
                                            else if (causer.data["type"] == "turret")
                                            {
                                                damageInfo["bTurret"] = true;
                                            }
                                        }
                                        damageInfo["position"] = this.roundNumberArray(pawnToDamage.position);
                                        if (this.localData["bSurvival"])
                                        {
                                            if (this.localData.gameModeData["id"] != GameMode.SURVIVAL_STAKEOUT)
                                            {                                                
                                                var killReward = pawnToDamage.data["killReward"];
                                                if (_data["bHeadshot"])
                                                {
                                                    killReward *= 1.5;
                                                }
                                                else if (_data["bMelee"])
                                                {
                                                    killReward *= 2;
                                                }
                                                damageInfo["moneyReward"] = killReward;
                                            }
                                        }
                                        _data["damageAmount"] = damageAmount;
                                        this.onPlayerKill(_data["attackerId"], damageAmount, _data["pawnId"], _data["causerId"], damageInfo, _data["bHeadshot"]);
                                        this.onPawnDeath(_data["pawnId"], damageAmount, _data["attackerId"], _data["causerId"], damageInfo, _data["bHeadshot"]);
                                        break;
                                }
                            }
                            else
                            {
                                switch (pawnToDamage.data["type"])
                                {
                                    case "character":
                                        if (this.isTeamGameMode())
                                        {
                                            if (!pawnToDamage.data["damagedBy"])
                                            {
                                                pawnToDamage.data["damagedBy"] = [];
                                            }
                                            var damagedBy = pawnToDamage.data["damagedBy"];
                                            if (damagedBy.indexOf(_data["attackerId"]) == -1)
                                            {
                                                damagedBy.push(_data["attackerId"]);
                                            }
                                        }                                        
                                        break;

                                    case "destructableObject":
                                        if (pawnToDamage.data.destructableData["type"] == "deployable_cover")
                                        {
                                            _data["bDeployableCover"] = 1;
                                        }
                                        break;

                                }
                                if (_data["damageType"] == DamageType.DAMAGE_FIRE)
                                {
                                    pawnToDamage.data["bOnFire"] = true;
                                    pawnToDamage.data["fireTimer"] = Math.round(this.localData.settings.fps * 0.5);
                                    this.onEvent({
                                        eventId: GameServer.EVENT_PAWN_ACTION,
                                        pawnId: pawnToDamage.data["id"],
                                        type: GameServer.PAWN_ON_FIRE,
                                        bValue: true
                                    });
                                }
                                if (_data["weaponId"] == "tazer")
                                {
                                    pawnToDamage.data["bStunned"] = true;
                                    if (this.characterHasPerk(pawnToDamage, Perks.PERK_PLAYER_SITREP))
                                    {
                                        pawnToDamage.data["stunTimer"] = 1;
                                        var bSitrep = true;
                                    }
                                    else
                                    {
                                        pawnToDamage.data["stunTimer"] = (this.localData.settings.fps * 3);
                                    }
                                    this.onEvent({
                                        eventId: GameServer.EVENT_PAWN_ACTION,
                                        pawnId: pawnToDamage.data["id"],
                                        type: GameServer.PAWN_STUN,
                                        bValue: true
                                    });
                                }
                                victim = this.getPlayerStateById(pawnToDamage.data["id"]);
                                if (victim)
                                {
                                    if (victim["bJuggernaut"])
                                    {
                                        _data["bJuggernaut"] = 1;
                                    }
                                    if (victim["bVIP"])
                                    {
                                        _data["bVIP"] = 1;
                                    }
                                    if (victim["bInfected"])
                                    {
                                        _data["bInfected"] = 1;
                                    }
                                }
                                if (bSitrep || _data["bSitrep"])
                                {
                                    _data["perkId"] = Perks.PERK_PLAYER_SITREP;
                                }
                                else if (this.characterHasPerk(pawnToDamage, Perks.PERK_PLAYER_JUGGERNAUT))
                                {
                                    _data["perkId"] = Perks.PERK_PLAYER_JUGGERNAUT;
                                }
                                else if ((_data["damageType"] == DamageType.DAMAGE_EXPLOSIVE || _data["damageType"] == DamageType.DAMAGE_FIRE) && this.characterHasPerk(pawnToDamage, Perks.PERK_PLAYER_SPECIALIST))
                                {
                                    _data["perkId"] = Perks.PERK_PLAYER_SPECIALIST;
                                }
                                else if (_data["bHeadshot"] && this.characterHasPerk(pawnToDamage, Perks.PERK_PLAYER_HELMET))
                                {
                                    _data["perkId"] = Perks.PERK_PLAYER_HELMET;
                                }
                                if (_data["bSniper"] && this.characterHasPerk(pawnToDamage, Perks.PERK_PLAYER_ANTI_SNIPER))
                                {
                                    _data["perkId"] = Perks.PERK_PLAYER_ANTI_SNIPER;
                                }
                                if (_data["bKnife"] && this.characterHasPerk(pawnToDamage, Perks.PERK_PLAYER_NINJA))
                                {
                                    _data["perkId"] = Perks.PERK_PLAYER_NINJA;
                                }
                                var killerPawn = this.getObjectById(_data["attackerId"]);
                                if (killerPawn)
                                {
                                    if (this.characterHasPerk(killerPawn, Perks.PERK_WEAPON_STOPPING_POWER))
                                    {
                                        pawnToDamage.data["bFreeze"] = true;
                                        pawnToDamage.data["freezeTimer"] = this.localData.settings.fps * (this.localData["bSurvival"] ? 2 : 1);
                                        pawnToDamage.data["bWantsToSprint"] = false;
                                        _data["bFreeze"] = true;
                                        this.onEvent({
                                            eventId: GameServer.EVENT_PAWN_ACTION,
                                            pawnId: pawnToDamage.data["id"],
                                            type: GameServer.PAWN_FREEZE,
                                            bValue: true
                                        });
                                    }
                                    if (this.characterHasPerk(killerPawn, Perks.PERK_WEAPON_RECON))
                                    {
                                        _data["bReconTagged"] = 1;
                                    }
                                }
                            }
                        }
                        _data["damageAmount"] = Math.round(_data["damageAmount"]);
                        if (pawnToDamage && pawnToDamage.data["bBot"])
                        {
                            if (this.localData.bMultiplayer && this.batchData.length >= Settings.BATCH_MAX)
                            {
                                _data.bServerSideOnly = true;
                            }
                        }
                    }
                    break;

                case GameServer.EVENT_PAWN_ACTION:
                    if (typeof _data.type === "string")
                    {
                        console.warn("Not using valid identifier:", _data.type);
                    }
                    switch (_data.type)
                    {
                        case GameServer.PAWN_START_LADDER_CLIMB:
                            var pawn = this.getObjectById(_data.pawnId);
                            if (pawn && !pawn.data["bBot"])
                            {
                                var ladder = this.getObjectById(_data.ladderId);
                                if (ladder)
                                {
                                    this.startLadderClimb(pawn, ladder);
                                }
                            }
                            break;
                    }
                    var keys = Object.keys(_data);
                    for (var i = 0; i < keys.length; i++)
                    {
                        var key = keys[i];
                        var val = _data[key];
                        if (typeof val === "boolean")
                        {           
                            if (val == true)
                            {
                                _data[key] = 1;
                            }
                            else
                            {
                                delete _data[key];
                            }
                        }
                    }
                    break;
            }
            if (_data && !_data["bServerSideOnly"])
            {
                var keys = Object.keys(_data);
                for (var i = keys.length; i >= 0; i--)
                {
                    var key = keys[i];
                    var val = _data[key];
                    if (typeof val === "boolean")
                    {
                        if (_data[key] == true)
                        {
                            _data[key] = 1;
                        }
                        else
                        {
                            delete _data[key];
                        }
                    }
                    else if (val == null)
                    {
                        delete _data[key];
                    }
                }
                this.onEvent(_data);
            }
        }
    }

    isNearFlag(_body)
    {
        if (_body)
        {
            var flags = this.getAllFlags();
            for (var i = 0; i < flags.length; i++)
            {
                let flag = flags[i];
                var bOverlaps = flag.getAABB().overlaps(_body.getAABB());
                if (bOverlaps)
                {
                    return true;
                }
            }
        }
        return false;
    }

    isNearFriendlyFlag(_body)
    {
        if (_body)
        {
            var flags = this.getAllFlags();
            for (var i = 0; i < flags.length; i++)
            {
                let flag = flags[i];
                var bOverlaps = flag.getAABB().overlaps(_body.getAABB());
                if (bOverlaps)
                {
                    return flag.data.team == _body.data.team;
                }
            }
            var bomb = this.getBombCrate();
            if (bomb)
            {
                if (this.Dist(bomb.position[0], bomb.position[1], _body.position[0], _body.position[1]) < 200)
                {
                    if (this.localData.gameModeData["bBombPlanted"])
                    {
                        return this.localData.gameModeData["bombTeam"] == _body.data.team;
                    }
                    else
                    {
                        return this.localData.gameModeData["bombTeam"] != _body.data.team;
                    }
                }
            }
        }
        return false;
    }

    isNearEnemyFlag(_body)
    {
        if (_body)
        {
            var flags = this.getAllFlags();
            for (var i = 0; i < flags.length; i++)
            {
                let flag = flags[i];
                var bOverlaps = flag.getAABB().overlaps(_body.getAABB());
                if (bOverlaps)
                {
                    return flag.data.team != _body.data.team;
                }
            }
            var bomb = this.getBombCrate();
            if (bomb)
            {
                if (this.Dist(bomb.position[0], bomb.position[1], _body.position[0], _body.position[1]) < 200)
                {
                    if (this.localData.gameModeData["bBombPlanted"])
                    {
                        return this.localData.gameModeData["bombTeam"] != _body.data.team;
                    }
                    else
                    {
                        return this.localData.gameModeData["bombTeam"] == _body.data.team;
                    }
                }
            }
        }
        return false;
    }

    sendBatchData()
    {
        if (this.batchData.length > 0)
        {
            this.onEventFunc({
                eventId: GameServer.EVENT_BATCH,
                lobbyId: this.lobbyId,
                items: this.batchData
            });
            this.batchData = [];
        }
    }

    updateContainer()
    {
        try
        {
            this.update();
        }
        catch (e)
        {
            console.error(e);
            if (this.localData["bMultiplayer"])
            {
                this.endGame();
            }
            else
            {
                this.onEventFunc({
                    eventId: GameServer.EVENT_ERROR,
                    error: e
                });
            }
        }
    }

    update()
    {
        if (!this.data)
        {
            console.warn("Invalid data reference in game loop!");
            return;
        }
        var localData = this.localData;
        if (localData["bPaused"])
        {
            localData["resetCallTime"] = true;
        }
        else
        {
            var j = 0;
            var i = 0;
            for (i = 0; i < localData["playerStates"].length; i++)
            {
                var ps = localData["playerStates"][i];
                if (ps["controllableId"])
                {
                    this.onEvent({
                        eventId: GameServer.EVENT_PLAYER_UPDATE,
                        playerId: ps["id"],
                        data: {
                            controllableId: ps["controllableId"]
                        }
                    });
                    //Handle bots
                    if (ps["bBot"])
                    {
                        var controllable = this.getObjectById(ps["controllableId"]);
                        if (controllable)
                        {
                            var bControllableLOS = false;
                            var bTargetColdBlooded = false;
                            var bIgnoreOutOfSight = false;
                            switch (controllable.data["type"])
                            {
                                case "turret":
                                    //bControllableLOS = true;
                                    bTargetColdBlooded = true;
                                    bIgnoreOutOfSight = true;
                                    break;
                            }
                            var maxRange = controllable.data["maxRange"] ? controllable.data["maxRange"] : Number.MAX_VALUE;
                            var controllableEnemy = this.getNearestEnemyPawn(controllable, {
                                bTargetColdBlooded: bTargetColdBlooded,
                                bLOS: bControllableLOS,
                                maxRange: controllable.data["bMaxLookRange"] ? Number.MAX_VALUE : maxRange,
                                bIgnoreOutOfSight: bIgnoreOutOfSight
                            });
                            if (controllableEnemy)
                            {
                                var controllableEnemyDist = this.Dist(controllable.position[0], controllable.position[1], controllableEnemy.position[0], controllableEnemy.position[1]);
                                this.requestEvent({
                                    eventId: GameServer.EVENT_PLAYER_UPDATE_CONTROLLABLE,
                                    playerId: ps.id,
                                    worldX: controllableEnemy.position[0],
                                    worldY: controllableEnemy.position[1]
                                });
                            }
                            switch (controllable.data["type"])
                            {
                                case "helicopter":
                                    controllable.data["bWantsToFire"] = controllableEnemy != null && controllableEnemyDist < (maxRange * 0.5);
                                    if (controllable.data["rockets"] > 0)
                                    {
                                        controllable.data["bWantsToFireRocket"] = true;
                                    }
                                    if (!controllableEnemy && controllable["contraint"])
                                    {
                                        this.dropHelicopterCrate(controllable);
                                    }
                                    break;

                                case "turret":
                                    controllable.data["bWantsToFire"] = controllableEnemy != null;
                                    break;

                                case "car":
                                    if (controllableEnemy)
                                    {
                                        controllable.data["moveX"] = controllableEnemy.position[0] > controllable.position[0] ? 1 : -1;
                                    }
                                    else
                                    {

                                    }
                                    break;
                            }
                        }
                    }
                }
                //Handle player respawn
                var pawn = this.getObjectById(ps["id"]);
                if (localData.gameModeData["bAllowRespawns"])
                {
                    if (ps["timer_respawn"] != undefined && ps["bWaitingToRespawn"])
                    {
                        if (ps["timer_respawn"] > 0)
                        {
                            ps["timer_respawn"]--;
                        }
                        else
                        {
                            this.onRespawnTimer(ps["id"]);
                        }
                    }
                }
                if (ps["timer_spawnProtection"] != undefined)
                {
                    if (ps["timer_spawnProtection"] > 0)
                    {
                        ps["timer_spawnProtection"]--;
                    }
                    else
                    {
                        this.onSpawnProtectionTimer(ps["id"]);
                    }
                }
                if (!pawn || !pawn.data["health"])
                {
                    if (ps["bHasPawn"])
                    {
                        ps["bHasPawn"] = false;
                        if (localData.gameModeData["bAllowRespawns"])
                        {
                            var bCanRespawn = ps["lives"] != null ? ps["lives"] > 0 : true;
                            if (bCanRespawn)
                            {
                                ps["bCanRespawn"] = false;
                                ps["bWaitingToRespawn"] = true;
                                //Handle respawn timer
                                if (ps["respawnTimer"] <= 0)
                                {
                                    if (ps["timer_respawn"] == undefined)
                                    {
                                        ps["respawnTimer"] = localData.gameModeData["respawnTime"];
                                        ps["timer_respawn"] = this.localData.settings.fps; //timer_respawn;
                                    }

                                    this.onEvent({
                                        eventId: GameServer.EVENT_PLAYER_UPDATE,
                                        playerId: ps["id"],
                                        data: {
                                            bCanRespawn: ps["bCanRespawn"],
                                            bWaitingToRespawn: ps["bWaitingToRespawn"],
                                            bHasPawn: ps["bHasPawn"],
                                            respawnTimer: ps["respawnTimer"]
                                        }
                                    });
                                }
                            }
                        }
                        else
                        {
                            this.onEvent({
                                eventId: GameServer.EVENT_PLAYER_UPDATE,
                                playerId: ps["id"],
                                data: {
                                    bHasPawn: ps["bHasPawn"],
                                    moneyMultiplier: ps["moneyMultiplier"]
                                }
                            });
                            if (this.localData["bSurvival"])
                            {
                                this.onEvent({
                                    eventId: GameServer.EVENT_GAME_UPDATE,
                                    gameModeData: {
                                        bPlayerKilled: true
                                    }
                                });
                            }
                        }
                    }
                }
                else
                {
                    delete pawn.data["bIsCapturingFlag"];                    
                    if (!ps["bHasPawn"])
                    {
                        ps["bHasPawn"] = true;
                        if (localData.gameModeData["bAllowRespawns"])
                        {
                            ps["bWaitingToRespawn"] = false;
                        }
                        this.onEvent({
                            eventId: GameServer.EVENT_PLAYER_UPDATE,
                            playerId: ps["id"],
                            data: {
                                bHasPawn: ps["bHasPawn"],
                                bWaitingToRespawn: ps["bWaitingToRespawn"]
                            }
                        });
                    }
                }

                if (ps["multiKillTimer"] > 0)
                {
                    ps["multiKillTimer"]--;
                }
                else if (ps["multiKillTimer"] === 0)
                {
                    this.endMultiKill(ps);
                    ps["multiKillTimer"] = -1;
                }

                if (ps["avengerTimer"] > 0)
                {
                    ps["avengerTimer"]--;
                }
                else
                {
                    ps["avengerTimer"] = -1;
                }
            }

            //Loop all bodies
            var objects = localData.world.bodies;
            for (i = 0; i < objects.length; i++)
            {
                var body = objects[i];                
                var data = body.data;
                if (data)
                {
                    if (data["destroyTimer"] != undefined)
                    {
                        data["destroyTimer"]--;
                        if (data["destroyTimer"] <= 0)
                        {
                            this.removeNextStep(body);
                        }
                    }

                    switch (data["type"])
                    {
                        case "equipment":
                            var bIsJammer = data.weaponData.id == "jammer";
                            if (!bIsJammer)
                            {
                                var jammers = this.getEquipment("jammer");
                                for (var j = 0; j < jammers.length; j++)
                                {
                                    var curJammer = jammers[j];                                    
                                    var bJammed = data["bJammed"];
                                    if ((bJammed || data["jammerId"]) && !this.getObjectById(data["jammerId"]))
                                    {
                                        bJammed = false;
                                    }
                                    if (curJammer.data.team != data.team && curJammer.data.health)
                                    {
                                        var dist = this.Dist(body.position[0], body.position[1], curJammer.position[0], curJammer.position[1]);
                                        if (dist < (data["radius"] * 2))
                                        {
                                            bJammed = true;
                                            data["jammerId"] = curJammer.data.id;
                                        }
                                    }
                                    if (data["bJammed"] != bJammed)
                                    {                                        
                                        this.requestEvent({
                                            eventId: GameServer.EVENT_PAWN_ACTION,
                                            pawnId: data["id"],
                                            type: GameServer.PAWN_SET_JAMMED,
                                            bValue: bJammed
                                        });
                                    }
                                    data["bJammed"] = bJammed;
                                }
                            }
                            break;
                    }

                    if (data["bFreeze"])
                    {
                        if (data["freezeTimer"] > 0)
                        {
                            data["freezeTimer"]--;
                        }
                        else
                        {
                            delete data["freezeTimer"];
                            data["bFreeze"] = false;
                            this.onEvent({
                                eventId: GameServer.EVENT_PAWN_ACTION,
                                pawnId: data["id"],
                                type: GameServer.PAWN_FREEZE,
                                bValue: false
                            });
                        }
                    }
                    if (data["bOnFire"])
                    {
                        data["bWantsToSprint"] = false;
                        if (data["fireTimer"] > 0)
                        {
                            data["fireTimer"]--;
                        }
                        else
                        {
                            data["bOnFire"] = false;
                            this.onEvent({
                                eventId: GameServer.EVENT_PAWN_ACTION,
                                pawnId: data["id"],
                                type: GameServer.PAWN_ON_FIRE,
                                bValue: false
                            });
                        }
                    }
                    if (data["bStunned"])
                    {
                        data["bWantsToSprint"] = false;
                        if (data["stunTimer"] > 0)
                        {
                            data["stunTimer"]--;
                        }
                        else
                        {
                            data["bStunned"] = false;
                            this.onEvent({
                                eventId: GameServer.EVENT_PAWN_ACTION,
                                pawnId: data["id"],
                                type: GameServer.PAWN_STUN,
                                bValue: false
                            });
                        }
                    }
                    if (data["bFlashed"])
                    {
                        data["bWantsToSprint"] = false;
                        if (data["flashTimer"] > 0)
                        {
                            data["flashTimer"]--;
                        }
                        else
                        {
                            data["flashIntensity"] = null;
                            data["bFlashed"] = false;
                            this.onEvent({
                                eventId: GameServer.EVENT_PAWN_ACTION,
                                pawnId: data["id"],
                                type: GameServer.PAWN_FLASH,
                                bValue: false
                            });
                        }
                    }

                    switch (data["type"])
                    {                       
                        case "door":
                            if (data["cooldownTimer"] > 0)
                            {
                                data["cooldownTimer"]--;
                            }
                            break;

                        case "shield":
                            var shieldPawn = this.getObjectById(data["playerId"]);
                            if (shieldPawn && shieldPawn.data["health"])
                            {
                                var curItem = this.getCurrentCharacterInventoryItem(shieldPawn);
                                if (!curItem || curItem["id"] != "riot_shield")
                                {
                                    this.removeNextStep(body);
                                }
                                else
                                {
                                    var weapon = shieldPawn.data["weapon"];
                                    data["bActive"] = !this.playerHasControllable(data["playerId"]) && !shieldPawn.data["bIsOnLadder"] && !shieldPawn.data["bWantsToInteract"] && !shieldPawn.data.bDoorCooldown && !weapon.bThrowDelay && !weapon.bEquipmentDelay && !weapon.bUseDelay;
                                    if (shieldPawn.data["bWantsToSprint"])
                                    {
                                        body.angle = this.ToRad(shieldPawn.data["scale"] == 1 ? 0 : -180);
                                    }
                                    else
                                    {
                                        body.angle = shieldPawn.data["aimRotation"];
                                    }
                                    var offset = 25;
                                    body.position[0] = shieldPawn.position[0] + (Math.cos(body.angle) * offset);
                                    body.position[1] = (shieldPawn.position[1] - 10) + (Math.sin(body.angle) * offset);
                                }
                            }
                            else
                            {
                                this.removeNextStep(body);
                            }
                            break;

                        case "infestor":
                            this.handleCharacter(body);
                            if (data["bBot"] && this.matchInProgress())
                            {
                                this.handleAICharacter(body);
                            }
                            break;

                        case "character":
                            this.handleCharacter(body);
                            if (data["bBot"] && this.matchInProgress())
                            {
                                this.handleAICharacter(body);
                            }
                            break;

                        case "car":
                            this.handleCar(body);
                            break;

                        case "flag_domination":
                            if (this.matchInProgress())
                            {
                                this.handleFlagDomination(body);
                            }
                            break;

                        case "flag_ctf":
                            if (this.matchInProgress())
                            {
                                this.handleFlagCTF(body);
                            }
                            break;

                        case "flag_defender":
                            if (this.matchInProgress())
                            {
                                this.handleFlagDefender(body);
                            }
                            break;

                        case "equipment":
                            if (this.matchInProgress())
                            {
                                this.handleEquipment(body);
                            }
                            break;

                        case "obstacle":
                            if (this.matchInProgress() && this.isTutorial())
                            {
                                if (body.data.obstacleId == "barrel_explosive")
                                {
                                    var chars = this.getCharacters();
                                    for (var j = 0; j < chars.length; j++)
                                    {
                                        let char = chars[j];
                                        if (!char.data["bBot"])
                                        {
                                            var bOverlaps = body.getAABB().overlaps(char.getAABB());
                                            if (bOverlaps)
                                            {
                                                this.requestEvent({
                                                    eventId: GameServer.EVENT_MESSAGE_ADD,
                                                    data: {
                                                        message: "STR_EXPLOSIVE_BARRELS",
                                                        id: "tutorial_explosive_barrels",
                                                        timer: 30
                                                    }
                                                });
                                                break;
                                            }
                                        }
                                    }
                                }
                            }
                            break;

                        case "info":
                            if (this.matchInProgress())
                            {
                                var chars = this.getCharacters();
                                for (var j = 0; j < chars.length; j++)
                                {
                                    let char = chars[j];
                                    if (!char.data["bBot"])
                                    {
                                        var bOverlaps = body.getAABB().overlaps(char.getAABB());
                                        if (bOverlaps)
                                        {
                                            var infoData = body.data;
                                            if (infoData.timeTrigger)
                                            {
                                                var timeTrigger = Math.round(infoData.timeTrigger * 60);
                                                if (this.localData.gameTimer == timeTrigger)
                                                {
                                                    this.executeInteractable(body, char.data.id);
                                                }
                                            }
                                            else
                                            {
                                                this.executeInteractable(body, char.data.id);
                                            }
                                            break;
                                        }
                                    }
                                }
                            }
                            break;

                        case "scavenger_pack":
                            if (this.matchInProgress())
                            {
                                var chars = this.getCharacters();
                                for (var j = 0; j < chars.length; j++)
                                {
                                    let char = chars[j];
                                    if (this.characterHasPerk(char, Perks.PERK_PLAYER_SCAVENGER))
                                    {
                                        var bOverlaps = body.getAABB().overlaps(char.getAABB());
                                        if (bOverlaps)
                                        {
                                            this.executeInteractable(body, char.data.id);
                                            break;
                                        }
                                    }
                                }
                            }
                            break;

                        case "loot_pack":
                            if (this.matchInProgress() && !body.data.bUsed)
                            {
                                var chars = this.getCharacters();
                                for (var j = 0; j < chars.length; j++)
                                {
                                    let char = chars[j];
                                    if (char && !char.data.bZombie) //!char.data.bBot
                                    {
                                        var bOverlaps = body.getAABB().overlaps(char.getAABB());
                                        if (bOverlaps)
                                        {
                                            this.executeInteractable(body, char.data.id);
                                            break;
                                        }
                                    }
                                }
                            }
                            break;

                        case "flame":
                            if (this.matchInProgress())
                            {
                                if (this.isInSmoke(body))
                                {
                                    this.removeNextStep(body);
                                }
                                else if (body.data.destroyTimer % body.data.ticker == 0)
                                {
                                    var pawns = this.getPawns().concat(this.getEquipment()).concat(this.getObstaclesWithHealth());
                                    for (var j = 0; j < pawns.length; j++)
                                    {
                                        let pawn = pawns[j];
                                        var ps = this.getPlayerStateById(pawn.data.id);
                                        if (ps && ps["bSpawnProtection"])
                                        {
                                            continue;
                                        }
                                        if (pawn.data.team != body.data.team || (pawn.data.id == body.data.playerId && this.localData["bFriendlyFire"]))
                                        {
                                            if (body.data.cooldownTimer > 0 && pawn.data.id == body.data.playerId)
                                            {
                                                continue;
                                            }
                                            var bOverlaps = body.getAABB().overlaps(pawn.getAABB());
                                            if (bOverlaps)
                                            {
                                                this.requestEvent({
                                                    eventId: GameServer.EVENT_PAWN_DAMAGE,
                                                    damageType: DamageType.DAMAGE_FIRE,
                                                    damageAmount: body.data.damage,
                                                    pawnId: pawn.data.id,
                                                    attackerId: body.data.playerId,
                                                    causerId: body.data.id,
                                                    weaponId: body.data.weaponId,
                                                    bDirectlyCausedByPlayer: true
                                                });
                                            }
                                        }
                                    }
                                    if (body.data.cooldownTimer > 0)
                                    {
                                        body.data.cooldownTimer--;
                                    }
                                }
                            }
                            break;

                        case "spawner":
                            if (this.matchInProgress())
                            {
                                if (data["timer"] > 0)
                                {
                                    data["timer"]--;
                                }
                                else
                                {
                                    data["timer"] = data["timerMax"];
                                    var unitId = null;
                                    var units = null;
                                    switch (data["spawnerId"])
                                    {
                                        case "SPAWNER_RANDOM":
                                            units = [
                                                SurvivalEnemyType.OPFOR_PISTOL,
                                                SurvivalEnemyType.OPFOR_BASIC,
                                                SurvivalEnemyType.OPFOR_HEAVY,
                                                SurvivalEnemyType.OPFOR_RPG,
                                                SurvivalEnemyType.RUS_BASIC,
                                                SurvivalEnemyType.RUS_HARD,
                                                SurvivalEnemyType.RUS_EXPERT,
                                                SurvivalEnemyType.RUS_SNIPER,
                                                SurvivalEnemyType.RUS_CLAYMORE,
                                                SurvivalEnemyType.RUS_SHIELD,
                                                SurvivalEnemyType.RUS_EXPLOSIVES,
                                                SurvivalEnemyType.USMC_BASIC,
                                                SurvivalEnemyType.USMC_HARD,
                                                SurvivalEnemyType.USMC_HEAVY,
                                                SurvivalEnemyType.USMC_SNIPER,
                                                SurvivalEnemyType.GSG9_BASIC,
                                                SurvivalEnemyType.GSG9_HARD,
                                                SurvivalEnemyType.GSG9_HEAVY,
                                                SurvivalEnemyType.GSG9_SNIPER,
                                                SurvivalEnemyType.GIGN_BASIC,
                                                SurvivalEnemyType.GIGN_HARD,
                                                SurvivalEnemyType.GIGN_HEAVY,
                                                SurvivalEnemyType.GIGN_SNIPER,
                                                SurvivalEnemyType.JUGGERNAUT,
                                                SurvivalEnemyType.JUGGERNAUT_JAVELIN,
                                                SurvivalEnemyType.JUGGERNAUT_COMMANDER,
                                                SurvivalEnemyType.INFESTOR,
                                                SurvivalEnemyType.INFESTOR_KING,
                                                SurvivalEnemyType.ZOMBIE_DEFAULT,
                                                SurvivalEnemyType.ZOMBIE_MELEE,
                                                SurvivalEnemyType.ZOMBIE_SPRINTER,
                                                SurvivalEnemyType.ZOMBIE_FAT,
                                                SurvivalEnemyType.ZOMBIE_FAT_THUMPER,
                                                SurvivalEnemyType.ZOMBIE_JUGGERNAUT,
                                                SurvivalEnemyType.ZOMBIE_FLAMETHROWER,
                                                SurvivalEnemyType.ZOMBIE_SPITTER,
                                                SurvivalEnemyType.ZOMBIE_EXPLODER,
                                                SurvivalEnemyType.ZOMBIE_SPITTER,
                                                SurvivalEnemyType.ZOMBIE_SPITTER_BOSS,
                                                SurvivalEnemyType.ZOMBIE_EXPLODER_BOSS,
                                                SurvivalEnemyType.ZOMBIE_RIFLE,
                                                SurvivalEnemyType.ZOMBIE_RPG,
                                                SurvivalEnemyType.ZOMBIE_SHIELD
                                            ];
                                            break;

                                        case "SPAWNER_USMC":
                                            units = [
                                                SurvivalEnemyType.USMC_BASIC,
                                                SurvivalEnemyType.USMC_HARD,
                                                SurvivalEnemyType.USMC_HEAVY,
                                                SurvivalEnemyType.USMC_SNIPER
                                            ];
                                            break;

                                        case "SPAWNER_GSG9":
                                            units = [
                                                SurvivalEnemyType.GSG9_BASIC,
                                                SurvivalEnemyType.GSG9_HARD,
                                                SurvivalEnemyType.GSG9_HEAVY,
                                                SurvivalEnemyType.GSG9_SNIPER
                                            ];
                                            break;

                                        case "SPAWNER_GIGN":
                                            units = [
                                                SurvivalEnemyType.GIGN_BASIC,
                                                SurvivalEnemyType.GIGN_HARD,
                                                SurvivalEnemyType.GIGN_HEAVY,
                                                SurvivalEnemyType.GIGN_SNIPER
                                            ];
                                            break;

                                        case "SPAWNER_OPFOR":
                                            units = [
                                                SurvivalEnemyType.OPFOR_PISTOL,
                                                SurvivalEnemyType.OPFOR_BASIC,
                                                SurvivalEnemyType.OPFOR_HEAVY,
                                                SurvivalEnemyType.OPFOR_RPG
                                            ];
                                            break;

                                        case "SPAWNER_RUS":
                                            units = [
                                                SurvivalEnemyType.RUS_BASIC,
                                                SurvivalEnemyType.RUS_HARD,
                                                SurvivalEnemyType.RUS_EXPERT,
                                                SurvivalEnemyType.RUS_SNIPER,
                                                SurvivalEnemyType.RUS_CLAYMORE,
                                                SurvivalEnemyType.RUS_SHIELD
                                            ];
                                            break;                                        

                                        case "SPAWNER_JUGGERNAUT":
                                            units = [
                                                SurvivalEnemyType.JUGGERNAUT,
                                                SurvivalEnemyType.JUGGERNAUT,
                                                SurvivalEnemyType.JUGGERNAUT,
                                                SurvivalEnemyType.JUGGERNAUT_JAVELIN,
                                                SurvivalEnemyType.JUGGERNAUT_COMMANDER
                                            ];
                                            break;

                                        case "SPAWNER_ZOMBIE":
                                            units = [
                                                SurvivalEnemyType.ZOMBIE_DEFAULT,
                                                SurvivalEnemyType.ZOMBIE_MELEE,
                                                SurvivalEnemyType.ZOMBIE_SPRINTER,
                                                SurvivalEnemyType.ZOMBIE_FAT,
                                                SurvivalEnemyType.ZOMBIE_FAT_THUMPER,
                                                SurvivalEnemyType.ZOMBIE_JUGGERNAUT,
                                                SurvivalEnemyType.ZOMBIE_FLAMETHROWER,
                                                SurvivalEnemyType.ZOMBIE_SPITTER,
                                                SurvivalEnemyType.ZOMBIE_EXPLODER,
                                                SurvivalEnemyType.ZOMBIE_SPITTER,
                                                SurvivalEnemyType.ZOMBIE_SPITTER_BOSS,
                                                SurvivalEnemyType.ZOMBIE_EXPLODER_BOSS
                                            ];
                                            break;

                                        case "SPAWNER_ZOMBIE_GENERIC":
                                            units = [
                                                SurvivalEnemyType.ZOMBIE_DEFAULT
                                            ];
                                            break;

                                        case "SPAWNER_INFESTOR":
                                            units = [
                                                SurvivalEnemyType.INFESTOR
                                            ];
                                            break;
                                    }
                                    if (units)
                                    {
                                        unitId = units[this.Random(0, units.length - 1)];
                                    }
                                    if (unitId)
                                    {
                                        var unitData = {
                                            team: data["team"],
                                            unitId: unitId,
                                            pos: body.position
                                        };
                                        this.createSandboxUnit(unitData);
                                    }
                                }
                            }
                            break;

                        case "grenade":
                            if (data["stuckToId"])
                            {
                                var stuckTo = this.getObjectById(data["stuckToId"]);
                                if (!stuckTo)
                                {
                                    if (body["constraint"])
                                    {
                                        this.localData.world.removeConstraint(body["constraint"]);
                                        delete body["constraint"];
                                        body.gravityScale = 1;
                                    }
                                }
                            }
                            if (data["bDetonationTimerEnabled"])
                            {
                                if (data["detonationTimer"] > 0)
                                {
                                    data["detonationTimer"]--;
                                }
                                else if (data["detonationTimer"] == 0)
                                {
                                    if (!data["bDetonated"] && !data.grenadeData["bImpact"])
                                    {
                                        this.detonate(body);
                                    }
                                }
                            }
                            if (data["minTimer"] > 0)
                            {
                                data["minTimer"]--;
                                if (data["minTimer"] <= 0)
                                {
                                    delete data["minTimer"];
                                }
                            }
                            break;

                        case "reviver":
                            if (this.matchInProgress())
                            {
                                body.position[0] = Math.max(0, body.position[0]);
                                body.position[0] = Math.min(this.getCurrentMapData().width, body.position[0]);
                                if (!data["currentPawnId"] && data["bleedTimer"] != undefined)
                                {
                                    if (data["bleedTimer"] > 0)
                                    {
                                        data["bleedTimer"]--;
                                    }
                                    else if (data["bleedTimer"] === 0)
                                    {
                                        data["bleedTimer"] = -1;
                                        if (this.localData.bOperation)
                                        {
                                            this.requestEvent({
                                                eventId: GameServer.EVENT_GAME_END,
                                                condition: MatchState.END_CONDITION_DEAD_ALLY
                                            });
                                        }
                                        else
                                        {
                                            this.removeNextStep(body);
                                        }
                                    }
                                }
                            }
                            break;

                        case "crate":
                            switch (data.interactData["type"])
                            {
                                case Crate.CRATE_BOMB_GENERIC:
                                    if (data["bBombPlanted"])
                                    {
                                        if (data["bombTimer"] > 0)
                                        {
                                            data["bombTimer"]--;
                                        }
                                        else if (!data["bDetonated"])
                                        {
                                            this.detonate(body);
                                        }
                                    }
                                    break;
                            }
                            if (body.position[1] > this.getCurrentMapData().height)
                            {
                                this.removeNextStep(body);
                            }
                            break;

                        case "helicopter":
                            this.handleHelicopter(body);
                            break;

                        case "turret":
                            this.handleTurret(body);
                            break;

                        case "rocket":
                            if (data["destroyTimer"] == 0)
                            {
                                this.detonate(body);
                            }
                            if (body.position[1] < -500)
                            {
                                this.removeNextStep(body);
                            }
                            if (data.rocketData["enemyId"] && !data["path"])
                            {
                                var enemy = this.getObjectById(data.rocketData["enemyId"]);
                                if (enemy && enemy.data["health"])
                                {
                                    var distX = enemy.position[0] - body.position[0];
                                    var distY = enemy.position[1] - body.position[1];
                                    var rad = Math.atan2(distY, distX);
                                    var speed = 300;
                                    var target = this.WrapAngle(body.angle - rad, true);
                                    body.angle -= target * 0.5;
                                    body.applyForce([Math.cos(body.angle) * speed, Math.sin(body.angle) * speed], 0, 0);
                                    this.constrainVelocity(body, 1000);
                                }
                                else if (data["bAutoLock"])
                                {
                                    var enemy = this.getNearestEnemyPawn(body, {
                                        bTargetColdBlooded: false,
                                        bIgnoreOutOfSight: false,
                                        maxRange: 2000,
                                        pawnTypes: ["helicopter"],
                                        bLOS: false
                                    });
                                    if (enemy)
                                    {
                                        data.rocketData["enemyId"] = enemy.data["id"];
                                    }
                                }
                            }
                            else if (data["bControllable"])
                            {
                                var speed = 300;
                                body.applyForce([Math.cos(body.angle) * speed, Math.sin(body.angle) * speed], 0, 0);
                                this.constrainVelocity(body, data["bBoost"] ? 1400 : 700);
                            }
                            else if (data["path"])
                            {
                                var path = data["path"];
                                if (path.length > 0)
                                {
                                    var curTarget = data.path[0];
                                    if (curTarget)
                                    {
                                        if (this.Dist(curTarget[0], curTarget[1], body.position[0], body.position[1]) < 200)
                                        {
                                            path.splice(0, 1);
                                        }
                                        else
                                        {
                                            var distX = curTarget[0] - body.position[0];
                                            var distY = curTarget[1] - body.position[1];
                                            var rad = Math.atan2(distY, distX);
                                            var speed = 500;
                                            var target = this.WrapAngle(body.angle - rad, true);
                                            body.angle -= target;
                                            body.applyForce([Math.cos(body.angle) * speed, Math.sin(body.angle) * speed], 0, 0);
                                            this.constrainVelocity(body, 1000);
                                        }
                                    }
                                }
                                else
                                {
                                    delete data["path"];
                                }
                            }
                            break;
                    }

                    if (data && !data["bSkipServerUpdate"])
                    {
                        var id = data.id;
                        if (id) //localData["updateCounter"] == 1
                        {
                            if (!localData["objectsToUpdate"])
                            {
                                localData["objectsToUpdate"] = {};
                            }
                            var objectsToUpdate = localData["objectsToUpdate"];
                            if (!objectsToUpdate[id])
                            {
                                objectsToUpdate[id] = [];
                            }
                            var arr = objectsToUpdate[id];

                            //Batch stuff

                            //Position
                            //var position = [this.RoundDecimal(body.position[0]), this.RoundDecimal(body.position[1])];
                            var position = [Math.round(body.position[0]), Math.round(body.position[1])];

                            //Velocity
                            var velocity = null;
                            if (body.mass > 0)
                            {
                                //velocity = [this.RoundDecimal(body.velocity[0]), this.RoundDecimal(body.velocity[1])];
                                velocity = [Math.round(body.velocity[0]), Math.round(body.velocity[1])];
                            }

                            //Rotation
                            var rotation = null;
                            var angularForce = null;
                            var angularVelocity = null;
                            if (data["bFixed"] || (body.mass > 0 && !body.fixedRotation))
                            {
                                rotation = this.RoundDecimal(body.angle);
                                angularForce = Math.round(body.angularForce); //this.RoundDecimal(body.angularForce);
                                angularVelocity = Math.round(body.angularVelocity); //this.RoundDecimal(body.angularVelocity);
                            }

                            var newData = this.clone(data);
                            var updateObj = {};

                            if (position != null)
                            {
                                updateObj.position = position;
                            }
                            if (newData != null)
                            {
                                updateObj.data = newData;
                            };
                            if (velocity != null)
                            {
                                updateObj.velocity = velocity;
                            }
                            if (rotation != null)
                            {
                                updateObj.rotation = rotation;
                            }
                            if (angularForce != null)
                            {
                                updateObj.angularForce = angularForce;
                            }
                            if (angularVelocity != null)
                            {
                                updateObj.angularVelocity = angularVelocity;
                            }

                            var numIds = Object.keys(updateObj).length;
                            if (numIds > 0)
                            {
                                updateObj.id = id;
                                arr.push(updateObj);
                            }
                        }
                    }
                }
            }

            if (localData["updateCounter"] == 1)
            {
                if (localData["objectsToUpdate"])
                {
                    var ids = Object.keys(localData["objectsToUpdate"]);
                    var tmp = {};
                    var numIds = ids.length;
                    for (i = 0; i < numIds; i++)
                    {
                        var curObjectId = ids[i];
                        var objectUpdates = localData["objectsToUpdate"][curObjectId];

                        //Save last object data for next batch update
                        tmp[curObjectId] = objectUpdates[objectUpdates.length - 1].data;

                        //Check duplicate keys in object data
                        if (objectUpdates.length == this.localData.settings.update_counter_max)
                        {
                            var newArr = [];
                            for (var j = 0; j < objectUpdates.length; j++)
                            {
                                var curUpdate = objectUpdates[j];
                                var targetData = null;
                                var newUpdate = null;
                                if (j > 0)
                                {
                                    targetData = objectUpdates[j - 1].data;
                                }
                                else
                                {
                                    //Should check against tmp object's last element
                                    var prevObjectData = localData["prevObjectData"];
                                    if (prevObjectData)
                                    {
                                        targetData = prevObjectData[curUpdate.id];
                                    }
                                }
                                if (targetData)
                                {
                                    var newData = this.removeDuplicateKeys(curUpdate.data, targetData);
                                    if (newData)
                                    {
                                        var newUpdate = this.clone(curUpdate);
                                        newUpdate.data = newData;
                                        newArr.push(newUpdate);
                                    }
                                }
                                if (!newUpdate)
                                {
                                    //this.log("Pushing original object data for " + curObjectId);
                                    newArr.push(curUpdate);
                                }
                            }
                            if (newArr)
                            {
                                localData["objectsToUpdate"][curObjectId] = newArr;
                            }
                        }
                        else
                        {
                            //this.log("First object update for " + curObjectId);
                        }
                    }
                    this.onEvent({
                        eventId: GameServer.EVENT_OBJECT_UPDATE,
                        objects: localData["objectsToUpdate"]
                    });
                    localData["prevObjectData"] = tmp;
                    delete localData["objectsToUpdate"];
                }
                localData["updateCounter"] = localData["updateCounterMax"];
            }
            else
            {
                localData["updateCounter"]--;
            }

            if (localData["deadswitchCooldownTimer"] > 0)
            {
                localData["deadswitchCooldownTimer"]--;
            }
            else if (localData["deadswitchCooldownTimer"] === 0)
            {
                delete localData["deadswitchCooldownTimer"];
            }

            var killstreaks = localData["killstreaks"];
            if (killstreaks)
            {
                var bUpdate = false;
                var bDeadswitch = false;
                for (i = killstreaks.length - 1; i >= 0; i--)
                {
                    var ks = killstreaks[i];
                    var rockets = ks["rockets"];
                    if (rockets)
                    {
                        for (var j = 0; j < rockets.length; j++)
                        {
                            var rocket = rockets[j];
                            if (rocket["timer"] > 0)
                            {
                                rocket["timer"]--;
                            }
                            else
                            {
                                this.createRocket(rocket.position, rocket.rocketData);
                                rockets.splice(0, 1);
                                break;
                            }
                        }
                    }
                    if (ks["timer"] > 0)
                    {
                        ks["timer"]--;
                    }
                    else
                    {
                        switch (ks["id"])
                        {
                            case Killstreaks.KILLSTREAK_DEADSWITCH:
                                this.executeDeadswitch(ks["playerId"]);
                                bDeadswitch = true;
                                break;
                        }
                        killstreaks.splice(i, 1);
                        bUpdate = true;
                    }
                }
                if (bUpdate)
                {
                    this.onEvent({
                        eventId: GameServer.EVENT_KILLSTREAKS_UPDATE,
                        killstreaks: killstreaks,
                        bDeadswitch: bDeadswitch
                    });
                }
            }

            var world = localData["world"];
            var timeSinceLastCall = 0;
            var timeMilliseconds = Date.now();
            var maxSubSteps = localData.bMultiplayer ? 10 : 1;
            if (localData["resetCallTime"])
            {
                timeSinceLastCall = 0;
                localData["resetCallTime"] = false;
            }
            else
            {
                if (timeMilliseconds !== undefined && localData["lastTimeMilliseconds"] !== undefined)
                {
                    timeSinceLastCall = (timeMilliseconds - localData["lastTimeMilliseconds"]) / 1000;
                }
            }
            world.step(this.localData.settings.fixed_timestep, timeSinceLastCall, maxSubSteps);
            localData["lastTimeMilliseconds"] = timeMilliseconds;

            while (localData.toRemove.length > 0)
            {
                this.removeObject(localData.toRemove[0]);
                localData.toRemove.splice(0, 1);
            }
        }
        this.sendBatchData();
    }

    destroy()
    {
        this.log("Destroy game");
        var localData = this.localData;
        if (localData)
        {
            var world = localData.world;
            if (world)
            {
                world.time = 0;
                world.fixedStepTime = 0;
                //Remove all solver equations
                if (world.solver && world.solver.equations.length)
                {
                    world.solver.removeAllEquations();
                }
                //Remove all constraints
                var cs = world.constraints;
                for (var i = cs.length - 1; i >= 0; i--)
                {
                    world.removeConstraint(cs[i]);
                }
                //Remove all bodies
                var bodies = world.bodies;
                for (var i = bodies.length - 1; i >= 0; i--)
                {
                    world.removeBody(bodies[i]);
                }
                //Remove all springs
                var springs = world.springs;
                for (var i = springs.length - 1; i >= 0; i--)
                {
                    world.removeSpring(springs[i]);
                }
                //Remove all contact materials
                var cms = world.contactMaterials;
                for (var i = cms.length - 1; i >= 0; i--)
                {
                    world.removeContactMaterial(cms[i]);
                }
                world.off("beginContact");
            }
            clearInterval(localData["interval"]);
            this.stopAllTimers();
            while (this.localData.playerStates.length > 0)
            {
                this.removePlayerStateById(this.localData.playerStates[0]["id"]);
            }
            this.localData.playerStates = null;
            this.onEndCallback = null;
            this.batchData = null;
            if (this.localData.graphInstance)
            {
                this.localData.graphInstance.clear();
                this.localData.graphInstance = null;
            }
            var keys = Object.keys(this.data);
            for (var i = 0; i < keys.length; i++)
            {
                delete this.data[keys[i]];
            }
            delete this.onEndCallback,
            delete this.onEventFunc;
            delete this.localData;
            delete this.lobbyId;
            delete this.data;
            delete this.p2;
        }
    }

    log(_val)
    {
        console.log(Settings.LOG_PREFIX + " " + _val); //Settings.LOG_SUFFIX
    }

    removeDuplicateKeys(_source, _target)
    {
        if (_source && _target)
        {
            var newData = {};
            var sourceKeys = Object.keys(_source);
            for (var i = 0; i < sourceKeys.length; i++)
            {
                var sourceKey = sourceKeys[i];
                var sourceValue = _source[sourceKey];
                if (typeof sourceValue === "boolean")
                {
                    sourceValue = sourceValue ? 1 : 0;
                }
                else if (typeof sourceValue === "number" && sourceValue % 1 != 0)
                {
                    sourceValue = this.RoundDecimal(sourceValue);
                }
                switch (sourceKey)
                {
                    case "ai":
                    case "weapon":
                    case "damageMultipliers":
                    case "inventory":
                    case "perks":
                    case "interactData":
                    case "avatarData":
                    case "inputPosition":
                    case "bBot":
                    case "regenTimer":
                    case "bRegen":
                    case "exposedTimer":
                    case "interactData":
                    case "bZombie":
                    case "zombieType":
                    case "xpReward":
                    case "enemyId":
                    case "moveX":
                    case "moveY":
                    case "jumpHeight":
                    case "regenAmount":
                    case "regenTimer":
                    case "regenTimerMax":
                    case "cooldownTimer":
                    case "bADS":
                    case "bEnabled":
                    case "carrierId":
                    case "bActivated":
                    case "bIsBeingCaptured":
                    case "interactTeam":
                    case "team":
                    case "equipment":
                    case "bIsReloading":
                    case "climbSpeedMultiplier":
                    case "bRegenHealth":
                    case "currentInventoryIndex":
                    case "weaponData":
                    case "bZombie":
                    case "zombieType":
                    case "bHostage":
                    case "bVIP":
                    case "projectileData":
                    case "pawnName":
                    case "clientPos":
                        //Don't include these keys
                        break;

                    case "reloadMultiplier":
                        //Don't include these keys for bots
                        if (!_source["bBot"])
                        {
                            newData[sourceKey] = sourceValue;
                        }
                        break;

                    case "bOnGround":                    
                    case "bWantsToCrouch":
                    case "bWantsToMove":
                    case "bWantsToSprint":
                    case "interactTeam":
                    case "health":
                    case "maxHealth":
                    case "step":
                    case "bWantsToFire":
                        //Always include these keys             
                        //newData[sourceKey] = sourceValue;
                        var target = sourceValue;
                        if (typeof target === "boolean")
                        {
                            target = target ? 1 : 0;
                        }
                        newData[sourceKey] = target;
                        break;

                    case "lookPos":
                        newData[sourceKey] = this.roundNumberArray(sourceValue);
                        break;

                    default:
                        //console.log(sourceKey, sourceValue);
                        var target = _target[sourceKey];
                        if (typeof target === "boolean")
                        {
                            target = target ? 1 : 0;
                        }                        
                        if (target !== sourceValue)
                        {
                            newData[sourceKey] = sourceValue;
                        }
                        break;
                }
            }
            if (newData)
            {
                //this.log(sourceKeys.length + " source, " + Object.keys(newData).length + " new");
                return newData;
            }
        }
        else
        {
            console.warn("removeDuplicateKeys: Invalid source or target reference");
        }
        return null;
    }

    getRandomUniqueId()
    {
        for (var i = 0; i < 100; i++)
        {
            var id = Math.random().toString(36).substr(2, 3);
            if (!this.getObjectById(id))
            {
                return id;
            }
        }
        return id;
    }

    constrainVelocity(_body, _val)
    {
        var angle, currVelocitySqr, vx, vy;
        vx = _body.velocity[0];
        vy = _body.velocity[1];
        currVelocitySqr = vx * vx + vy * vy;
        if (currVelocitySqr > _val * _val)
        {
            angle = Math.atan2(vy, vx);
            vx = Math.cos(angle) * _val;
            vy = Math.sin(angle) * _val;
            _body.velocity[0] = vx;
            _body.velocity[1] = vy;
        }
    }

    getTotalVelocity(_body)
    {
        if (_body)
        {
            var vx = _body.velocity[0];
            var vy = _body.velocity[1];
            return vx * vx + vy * vy;
        }
        return 0;
    }

    setPaused(_bVal)
    {
        var localData = this.localData;
        localData["bPaused"] = _bVal;
        if (localData["timer_game"])
        {
            var timer = localData["timer_game"];
            if (_bVal)
            {
                timer.pause();
            }
            else
            {
                timer.resume();
            }
        }
        if (localData["timer_preGame"])
        {
            timer = localData["timer_preGame"];
        }
        if (localData["timer_wave"])
        {
            timer = localData["timer_wave"];
        }
        if (localData["timer_waveSpawn"])
        {
            timer = localData["timer_waveSpawn"];
        }
    }

    getWinner()
    {
        if (this.localData)
        {
            if (this.localData.gameModeData)
            {
                return this.localData.gameModeData["winner"];
            }
        }
        return -1;
    }

    endGame()
    {
        if (this.bGameEnded)
        {
            this.log("Game is already ended");
            return;
        }
        this.log("End game");
        this.bGameEnded = true;
        this.localData["matchState"] = MatchState.STATE_POST_GAME;
        this.localData.gameModeData["bAllowRespawns"] = false;
        this.stopAllTimers();
        var pawns = this.getPawns();
        for (var i = 0; i < pawns.length; i++)
        {
            var pawn = pawns[i];
            pawn.data["bWantsToFire"] = false;
            switch (pawn.data["type"])
            {
                case "helicopter":
                    pawn.data["ammo"] = 0;
                    pawn.shapes[0].collisionMask = (CollisionGroups.PROJECTILE | CollisionGroups.PROJECTILE_AIR);
                    break;

                case "character":
                    pawn.data["bWantsToFire"] = false;
                    break;
            }
        }
        if (this.onEndCallback)
        {
            this.onEndCallback.apply(this, [this.lobbyId]);
        }
    }

    matchInProgress()
    {
        if (this.localData && this.localData["matchState"] == MatchState.STATE_IN_PROGRESS)
        {
            return true;
        }
        return false;
    }

    isPreGame()
    {
        if (this.localData && this.localData["matchState"] == MatchState.STATE_PRE_GAME)
        {
            return true;
        }
        return false;
    }

    matchHasEnded()
    {
        if (!this.localData)
        {
            return true;
        }
        return this.localData["matchState"] == MatchState.STATE_POST_GAME;
    }

    roundHasEnded()
    {
        if (!this.localData)
        {
            return true;
        }
        return this.localData["matchState"] == MatchState.STATE_POST_ROUND;
    }

    createWorld()
    {
        var localData = this.localData;
        localData.objects = {};

        var world = new this.p2.World({
            gravity: [0, 800],
            //broadphase: new this.p2.NaiveBroadphase(),
            islandSplit: false
        });
        world.defaultContactMaterial.friction = 0.5;
        if (this.localData["bMultiplayer"])
        {
            world.solver.tolerance = 0.01;
            world.solver.iterations = 8;
        }
        else
        {
            world.solver.tolerance = 0.1;
            world.solver.iterations = 1;
        }
        world.emitImpactEvent = !this.localData["bPerformanceMode"];
        world.sleepMode = this.p2.World.BODY_SLEEPING;
        world.on("beginContact", (_event) =>
        {
            this.onBeginContact(_event);
        });
        this.localData.world = world;

        var map = this.getCurrentMapData();

        var groundMask = CollisionGroups.PAWN | CollisionGroups.PROJECTILE | CollisionGroups.DRONE | CollisionGroups.FLAME | CollisionGroups.CAR; 

        var groundMaterial = new this.p2.Material();
        localData.materials = {
            ground: groundMaterial
        };

        var leftBody = new this.p2.Body({
            angle: (3 * Math.PI) / 2
        });
        leftBody.data = {
            id: "bounds_left",
            type: "ground",
            bSkipServerUpdate: true
        };
        leftBody.addShape(new this.p2.Plane({
            collisionGroup: CollisionGroups.GROUND,
            collisionMask: groundMask
        }));
        this.addWorldBody(leftBody);

        var rightBody = new this.p2.Body({
            angle: Math.PI / 2,
            position: [map["width"], 0]
        });
        rightBody.data = {
            id: "bounds_right",
            type: "ground",
            bSkipServerUpdate: true
        };
        rightBody.addShape(new this.p2.Plane({
            collisionGroup: CollisionGroups.GROUND,
            collisionMask: groundMask
        }));
        this.addWorldBody(rightBody);

        var bottomBody = new this.p2.Body({
            angle: this.ToRad(180),
            position: [0, map["height"]]
        });
        bottomBody.data = {
            id: "bounds_bottom",
            type: "ground",
            bSkipServerUpdate: true
        };
        bottomBody.addShape(new this.p2.Plane({
            collisionGroup: CollisionGroups.GROUND,
            collisionMask: groundMask
        }));
        this.addWorldBody(bottomBody);

        var objects = map.objects;
        if (objects)
        {
            for (var i = 0; i < objects.length; i++)
            {
                var curObject = objects[i];
                switch (curObject.type)
                {
                    case "polygon":
                        var mapBody = new this.p2.Body({
                            mass: 0,
                            position: curObject.position
                        });
                        mapBody.allowSleep = true;
                        var cg = CollisionGroups.GROUND;
                        var cm = CollisionGroups.PAWN | CollisionGroups.PROJECTILE | CollisionGroups.DRONE | CollisionGroups.FLAME | CollisionGroups.CAR;
                        var pType = "ground";
                        if (curObject.bPlatform)
                        {
                            cg = CollisionGroups.PLATFORM;
                            cm = CollisionGroups.PAWN;
                            pType = "platform";
                        }
                        this.loadPolygon(curObject.spriteId, mapBody, curObject.width, curObject.height, 1, {
                            material: this.localData.materials["ground"],
                            collisionGroup: cg,
                            collisionMask: cm
                        });
                        mapBody.data = {
                            id: "map",
                            type: pType,
                            bSkipServerUpdate: true
                        };
                        this.addWorldBody(mapBody);
                        break;

                    case "ground":
                        var body = new this.p2.Body({
                            mass: 0,
                            position: curObject.position
                        });
                        body.allowSleep = true;
                        body.data = {
                            id: this.getRandomUniqueId(),
                            type: curObject.type,
                            material: curObject.material,
                            bSkipServerUpdate: true
                        };
                        body.addShape(new this.p2.Box({
                            width: curObject.width,
                            height: curObject.height,
                            collisionGroup: CollisionGroups.GROUND,
                            collisionMask: CollisionGroups.PAWN | CollisionGroups.PROJECTILE | CollisionGroups.DRONE | CollisionGroups.FLAME | CollisionGroups.CAR
                        }));
                        this.addWorldBody(body);
                        break;

                    case "platform":
                        var body = new this.p2.Body({
                            mass: 0,
                            position: curObject.position
                        });
                        if (curObject.rotation != undefined)
                        {
                            body.angle = this.ToRad(curObject.rotation);
                        }
                        body.allowSleep = true;
                        body.data = {
                            id: this.getRandomUniqueId(),
                            type: curObject.type,
                            material: curObject.material,
                            bSkipServerUpdate: true
                        };
                        body.addShape(new this.p2.Box({
                            width: curObject.width,
                            height: curObject.height,
                            collisionGroup: CollisionGroups.PLATFORM,
                            collisionMask: CollisionGroups.PAWN | CollisionGroups.FLAME | CollisionGroups.CAR
                        }));
                        this.addWorldBody(body);
                        break;

                    case "ladder":
                        if (this.getObjectById(curObject.id))
                        {
                            console.warn("Ladder already exists:", curObject.id);
                        }
                        var body = new this.p2.Body({
                            mass: 0,
                            position: curObject.position
                        });
                        body.allowSleep = true;
                        body.data = {
                            id: curObject.id,
                            type: curObject.type,
                            width: this.getSharedData("ladderWidth") ? this.getSharedData("ladderWidth") : 15, //curObject.width,
                            height: curObject.height,
                            direction: curObject.direction,
                            bPlayer: curObject.bPlayer,
                            bBot: curObject.bBot,
                            bSkipServerUpdate: true
                        };
                        var shape = new this.p2.Box({
                            width: curObject.width,
                            height: curObject.height,
                        });
                        shape.sensor = true;
                        body.addShape(shape);
                        this.addWorldBody(body);
                        break;

                    case "obstacle":
                        this.createObstacle(curObject);
                        break;

                    case "door":
                        this.createDoor(curObject);
                        break;
                }
            }
        }
        localData["lastTimeMilliseconds"] = undefined;
    }

    createDoor(_data)
    {
        var body = new this.p2.Body({
            mass: 0,
            position: _data.position,
            allowSleep: true,
            fixedRotation: true,
            sleepSpeedLimit: 1,
            sleepTimeLimit: 1
        });
        if (!_data.height)
        {
            console.warn("Missing height");
        }
        var width = _data.width ? _data.width : 40;
        var height = _data.height; //_data.useHeight ? _data.useHeight : _data.height;

        var useWidth = Math.max(50, width);
        var useHeight = Math.max(100, height);
        var material = _data.material ? _data.material : "wood";
        body.data = {
            id: _data.id ? _data.id : this.getRandomUniqueId(),
            type: "door",
            bClosed: _data.bClosed,
            material: material,
            width: width,
            height: height,
            useHeight: useHeight,
            cooldownTimer: 0
        };
        if (_data.doorType)
        {
            body.data.doorType = _data.doorType;
            body.data.interactData = { doorType: _data.doorType, height: _data.height };
        }
        var health = 500;
        if (health > 0)
        {
            //body.data["health"] = health;
            body.data["team"] = -1;
            body.data["damageMultipliers"] = {
                1: 1,
                2: 1,
                3: 1
            };
        }
        body.addShape(new this.p2.Box({
            width: useWidth,
            height: useHeight,
            collisionGroup: CollisionGroups.PAWN
        }));
        this.addWorldBody(body);
        this.requestEvent({
            eventId: GameServer.EVENT_SPAWN_OBJECT,
            data: {
                id: body.data.id,
                position: body.position,
                type: "door",
                data: _data
            }
        });
        this.setDoorClosed(body, body.data.bClosed);
    }

    setDoorClosed(_body, _bClosed, _causer, _bImpact, _bForce)
    {
        if (_body)
        {
            var data = _body.data;
            if (!_bForce && data["cooldownTimer"] > 0)
            {
                return;
            }
            var prev = data.bClosed;
            data.bClosed = _bClosed;
            var shape = _body.shapes[0];
            if (_bClosed)
            {               
                shape.collisionGroup = CollisionGroups.GROUND;
                shape.collisionMask = CollisionGroups.PAWN | CollisionGroups.PROJECTILE | CollisionGroups.DRONE | CollisionGroups.FLAME | CollisionGroups.CAR;
            }
            else
            {
                shape.collisionGroup = 0;
                shape.collisionMask = 0;
            }
            if (data.bClosed != prev)
            {
                var scale = null;
                if (_causer)
                {
                    data["cooldownTimer"] = Math.round(this.localData.settings.fps * 0.5);
                    if (!_bClosed)
                    {
                        var causerPos = _causer.previousPosition ? _causer.previousPosition : _causer.position;
                        scale = _body.position[0] > causerPos[0] ? 1 : -1;
                    }
                    if (_bImpact || _bClosed)
                    {
                        this.emitAISound(_body.position, _causer.data.team, 400);
                    }
                }
                this.onEvent({
                    eventId: GameServer.EVENT_PAWN_ACTION,
                    pawnId: data["id"],
                    causerId: _causer ? _causer.data.id : null,
                    type: GameServer.PAWN_UPDATE_DOOR,
                    bClosed: data["bClosed"],
                    scale: scale,
                    bImpact: _bImpact
                });
            }
        }
    }

    createObstacle(_data)
    {
        if (this.localData["bNoSandbags"] && _data["obstacleId"].indexOf("sandbags") >= 0)
        {
            return;
        }
        var body = new this.p2.Body({
            mass: 0,
            position: _data.position,
            allowSleep: true,
            sleepSpeedLimit: 1,
            sleepTimeLimit: 1
        });
        var shared = this.getSharedData(_data["obstacleId"]);
        var useWidth = shared.width;
        var useHeight = shared.height;
        var material;
        switch (_data["obstacleId"])
        {
            case "barrel_explosive":
                var health = 25;
                material = "metal";
                break;
            case "sandbags":
                material = "sandbag";
                break;
            case "sandbags_large":
                material = "sandbag";
                break;
            case "sandbags_tall":
                material = "sandbag";
                break;
            case "sandbags_narrow":
                material = "sandbag";
                break;
            case "sandbags_edge":
                material = "sandbag";
                break;
            case "window":
                health = 1;
                material = "glass";
                break;
            default:
                material = "default";
                break;
        }
        if (_data["rotation"])
        {
            body.angle = this.ToRad(_data["rotation"]);
        }
        body.data = {
            id: _data.id ? _data.id : this.getRandomUniqueId(),
            obstacleId: _data["obstacleId"],
            scale: _data["scale"],
            rotation: _data["rotation"],
            type: _data.type,
            material: material,
            width: useWidth,
            height: useHeight,
            bBlock: _data["bBlock"],
            bSkipServerUpdate: true
        };
        if (health > 0)
        {
            body.data["health"] = health;
            body.data["team"] = -1;
            body.data["damageMultipliers"] = {
                1: 1,
                2: 1,
                3: 50
            };
        }
        body.addShape(new this.p2.Box({
            width: useWidth,
            height: useHeight,
            collisionMask: CollisionGroups.PROJECTILE
        }));
        this.addWorldBody(body);
        this.requestEvent({
            eventId: GameServer.EVENT_SPAWN_OBJECT,
            data: {
                id: body.data.id,
                position: body.position,
                rotation: body.angle,
                type: "obstacle",
                data: _data
            }
        });
    }

    onBeginContact(_event)
    {
        if (!this.localData)
        {
            return;
        }
        this.onHit(_event.bodyA, _event.bodyB);
        this.onHit(_event.bodyB, _event.bodyA);
    }

    onHit(_bodyA, _bodyB)
    {
        var dataA = _bodyA.data;
        var dataB = _bodyB.data;
        if (dataB && dataB["bInvisible"])
        {
            return;
        }
        if (dataA)
        {
            if (dataA["bPendingRemoval"])
            {
                return;
            }
            switch (dataA["type"])
            {
                case "crate":
                    this.requestEvent({
                        eventId: GameServer.EVENT_PAWN_ACTION,
                        pawnId: dataA.id,
                        type: GameServer.PAWN_HIT
                    });
                    break;

                case "flame":
                    if (dataA.bFromWeapon)
                    {
                        _bodyA.velocity[0] *= 0.5;
                        _bodyA.velocity[1] *= 0.5;
                    }
                    break;

                case "character":
                case "infestor":
                    switch (dataB.type)
                    {
                        case "platform":
                        case "ground":
                            if (!dataA["bOnGround"])
                            {
                                /*
                                if (this.localData.settings.fps != 60 && this.batchData.length <= Settings.BATCH_MAX)
                                {
                                    this.requestEvent({
                                        eventId: GameServer.EVENT_PAWN_ACTION,
                                        pawnId: dataA.id,
                                        type: GameServer.PAWN_HIT
                                    });
                                }
                                */
                            }
                            if (this.isHardcore())
                            {
                                //Fall damage
                                if (_bodyA.velocity && !this.characterHasPerk(_bodyA, Perks.PERK_PLAYER_NINJA))
                                {
                                    var velY = _bodyA.velocity[1];
                                    if (velY > 500)
                                    {
                                        this.requestEvent({
                                            eventId: GameServer.EVENT_PAWN_DAMAGE,
                                            damageType: DamageType.DAMAGE_WORLD,
                                            damageAmount: Math.min(25, velY * 0.05),
                                            pawnId: dataA.id,
                                            attackerId: dataA.id,
                                            causerId: dataB.id,
                                            weaponId: "fall",
                                            bDirectlyCausedByPlayer: false
                                        });
                                    }
                                }
                            }
                            break;
                    }
                    break;

                case "door":
                    if (dataA["bClosed"])
                    {
                        if (dataB["type"] == "character" || dataB["type"] == "infestor")
                        {
                            if (dataB["bBot"] || dataB["bWantsToSprint"])
                            {
                                this.setDoorClosed(_bodyA, false, _bodyB, true, dataB["bBot"]);
                            }
                        }
                    }
                    break;

                case "helicopter":
                    if (dataB["type"] === "ground")
                    {
                        if (!dataA["health"])
                        {
                            this.createExplosion({
                                eventId: GameServer.EVENT_SPAWN_EXPLOSION,
                                x: _bodyA.position[0],
                                y: _bodyA.position[1],
                                radius: 500,
                                damage: 0,
                                playerId: null,
                                causerId: null,
                                weaponId: null
                            });
                            this.removeNextStep(_bodyA);
                        }
                        else
                        {
                            this.requestEvent({
                                eventId: GameServer.EVENT_PAWN_ACTION,
                                pawnId: dataA.id,
                                type: GameServer.PAWN_HIT
                            });
                        }
                    }
                    break;

                case "projectile":
                    if (!dataA["bHit"])
                    {
                        var bHit = true;
                        if (this.localData["bSurvival"] || this.localData["bSandbox"])
                        {
                            bHit = dataA["team"] != dataB["team"];
                        }
                        else if (this.localData["bOperation"] && dataA["team"] == 1)
                        {
                            bHit = dataA["team"] != dataB["team"];
                        }
                        if (dataA.projectileData["playerId"] == dataB["id"])
                        {
                            bHit = false;
                        }
                        if (dataB["type"] == "shield")
                        {
                            if (dataA.projectileData["playerId"] == dataB["playerId"])
                            {
                                bHit = false;
                            }
                        }
                        if (bHit)
                        {
                            var ps = this.getPlayerStateById(dataB["id"]);
                            var bSpawnProtected = ps && ps["bSpawnProtection"];
                            if (bSpawnProtected)
                            {
                                bHit = false;
                            }
                        }
                        if (bHit)
                        {
                            dataA["bHit"] = true;
                            if (dataB["type"] == "character")
                            {
                                var impactType = dataB["material"] ? dataB["material"] : "default";
                                this.createImpactEffect(_bodyA.position[0], _bodyA.position[1], _bodyA.angle, impactType, 1);
                            }
                            if (dataA["team"] != dataB["team"])
                            {
                                var damageType = DamageType.DAMAGE_MELEE;
                                if (dataA.projectileData["weaponId"] == "zombie_spitter_boss")
                                {
                                    damageType = DamageType.DAMAGE_EXPLOSIVE;
                                }
                                if (dataB["health"])
                                {
                                    var projDamage = dataA["damage"];  
                                    switch (dataA.projectileData["weaponId"])
                                    {
                                        case "knife":
                                            if (dataB["type"] == "character")
                                            {
                                                if (_bodyA.position[1] > _bodyB.position[1] + 10)
                                                {
                                                    projDamage *= 0.5;
                                                }
                                                if (this.characterHasPerk(_bodyB, Perks.PERK_PLAYER_NINJA))
                                                {
                                                    projDamage = Math.min(projDamage, 100); //dataB["maxHealth"] - 1;
                                                }
                                            }
                                            break;

                                        case "crossbow":
                                            if (dataB.bZombie)
                                            {
                                                projDamage *= 2;
                                            }
                                            if (dataB["type"] == "character")
                                            {
                                                if (_bodyA.position[1] < _bodyB.position[1] - 20)
                                                {
                                                    var bHeadshot = true;
                                                    projDamage *= 2;
                                                }
                                                else if (_bodyA.position[1] > _bodyB.position[1] + 10)
                                                {
                                                    projDamage *= this.localData.bSurvival ? 0.5 : 0.25;
                                                }
                                            }
                                            else if (dataB["type"] == "infestor")
                                            {
                                                if (_bodyA.position[1] > _bodyB.position[1])
                                                {
                                                    bHeadshot = true;
                                                    projDamage *= 2;
                                                }
                                            }
                                            break;
                                    }
                                    this.requestEvent({
                                        eventId: GameServer.EVENT_PAWN_DAMAGE,
                                        damageType: damageType,
                                        damageAmount: projDamage,
                                        pawnId: dataB["id"],
                                        attackerId: dataA.projectileData["playerId"],
                                        causerId: dataA["id"],
                                        weaponId: dataA.projectileData["weaponId"],
                                        bMelee: dataA.projectileData["weaponId"] == "knife" || dataA.projectileData["weaponId"] == "crossbow",
                                        bKnife: dataA.projectileData["weaponId"] == "knife",
                                        bHeadshot: bHeadshot,
                                        bDirectlyCausedByPlayer: true
                                    });
                                }
                            }
                            var pos = _bodyA.previousPosition ? _bodyA.previousPosition : _bodyA.position;
                            switch (dataA.projectileData["weaponId"])
                            {
                                case "knife":
                                    this.createDroppedWeapon(this.getRandomUniqueId(), pos, _bodyA.rotation, 1, {
                                        weaponData: this.getWeaponData(dataA.projectileData["weaponId"]),
                                        playerId: dataA.projectileData["playerId"]
                                    });
                                    break;

                                case "crossbow":
                                    this.createImpactEffect(pos[0], pos[1], _bodyA.rotation, "default", 1);
                                    //this.createScavengerPack(pos, {});
                                    break;
                            }
                            this.removeNextStep(_bodyA);
                        }
                    }
                    break;

                case "grenade":
                    if (dataA.grenadeData["bImpact"])
                    {
                        if (dataB)
                        {         
                            var bDud = dataA["minTimer"] > 0 && !dataA["bDud"];
                            switch (dataB["type"])
                            {
                                case "helicopter":
                                    var bDamage = true;
                                    var bDetonate = true;
                                    var attacker = this.getPlayerStateById(dataA.grenadeData["playerId"]);
                                    if (attacker)
                                    {
                                        if (attacker["id"] == dataB.heliData["playerId"])
                                        {
                                            bDamage = this.localData["bFriendlyFire"] && !dataB["bPlayerControlled"];
                                            bDetonate = bDamage;
                                        }
                                        else if (attacker["team"] == dataB["team"])
                                        {
                                            bDamage = false;
                                            bDetonate = false;
                                        }
                                    }
                                    else if (dataA["team"] == dataB["team"])
                                    {
                                        bDamage = false;
                                        bDetonate = false;
                                    }
                                    if (bDamage)
                                    {
                                        var useDamage = dataA["damage"];
                                        if (this.localData["bModeGame"])
                                        {
                                            useDamage *= 0.75;
                                        }
                                        this.requestEvent({
                                            eventId: GameServer.EVENT_PAWN_DAMAGE,
                                            damageType: DamageType.DAMAGE_EXPLOSIVE,
                                            damageAmount: useDamage,
                                            pawnId: dataB["id"],
                                            attackerId: dataA.grenadeData["playerId"],
                                            causerId: dataA["id"],
                                            weaponId: dataA.grenadeData["weaponId"]
                                        });
                                    }
                                    if (bDetonate)
                                    {
                                        this.detonate(_bodyA, dataB["id"]);
                                    }
                                    break;

                                case "infestor":
                                case "character":
                                    var bDetonate = true;
                                    var attacker = this.getPlayerStateById(dataA.grenadeData["playerId"]);
                                    if (attacker)
                                    {
                                        if (attacker["id"] == dataB["id"])
                                        {
                                            bDetonate = false;
                                        }
                                    }
                                    else
                                    {
                                        if (dataA.grenadeData["playerId"] == dataB["id"])
                                        {
                                            bDetonate = false;
                                        }
                                    }
                                    if (bDetonate)
                                    {
                                        if (dataA.grenadeData["team"] == dataB["team"])
                                        {
                                            bDetonate = !this.localData["bSurvival"] && !this.localData["bSandbox"] && !this.localData["bBattlezone"] && !this.localData.bOperation;
                                        }
                                    }
                                    if (bDetonate)
                                    {
                                        if (bDud)
                                        {
                                            var ps = this.getPlayerStateById(dataB["id"]);
                                            var bSpawnProtected = ps && ps["bSpawnProtection"];
                                            if (!bSpawnProtected && dataA.grenadeData["team"] != dataB["team"])
                                            {           
                                                this.requestEvent({
                                                    eventId: GameServer.EVENT_PAWN_DAMAGE,
                                                    damageType: DamageType.DAMAGE_MELEE,
                                                    damageAmount: 200, //Direct impact
                                                    pawnId: dataB["id"],
                                                    attackerId: dataA.grenadeData["playerId"],
                                                    causerId: dataA["id"],
                                                    weaponId: dataA.grenadeData["weaponId"], //"impact"
                                                    bDirectImpact: true
                                                });
                                                dataA["bDud"] = true;
                                            }
                                            else
                                            {
                                                this.createImpactEffect(_bodyA.position[0], _bodyA.position[1], _bodyA.angle, "grenade", 1);
                                            }
                                            this.removeNextStep(_bodyA);
                                        }
                                        else
                                        {
                                            this.detonate(_bodyA);
                                        }
                                    }
                                    break;

                                case "turret":
                                    var bDetonate = true;
                                    if (this.localData["bSurvival"])
                                    {
                                        bDetonate = false;
                                    }
                                    else if (dataA["team"] == dataB["team"])
                                    {
                                        bDetonate = false;
                                    }
                                    if (bDetonate)
                                    {
                                        this.detonate(_bodyA);
                                    }
                                    break;

                                case "obstacle":
                                    if (this.localData["bSurvival"])
                                    {
                                        if (dataA.grenadeData["team"] == 0)
                                        {
                                            //Ignore
                                        }
                                    }
                                    else
                                    {
                                        this.detonate(_bodyA);
                                    }
                                    break;

                                case "door":
                                    this.detonate(_bodyA);
                                    this.setDoorClosed(_bodyB, false, _bodyA, true);
                                    break;

                                default:
                                    this.detonate(_bodyA);
                                    break;
                            }
                        }
                    }
                    else
                    {
                        if (dataA.grenadeData["bStartDetonationAfterHit"])
                        {
                            dataA["bDetonationTimerEnabled"] = true;
                        }
                        var weaponData = this.getWeaponData(dataA.grenadeData["weaponId"]);
                        if (weaponData["bSticky"])
                        {
                            if (!_bodyA["constraint"])
                            {
                                _bodyA.velocity[0] = 0;
                                _bodyA.velocity[1] = 0;
                                _bodyA.angularVelocity = 0;
                                /*
                                var constraint = new this.p2.RevoluteConstraint(_bodyA, _bodyB, {
                                    worldPivot: [_bodyA.position[0], _bodyA.position[1]]
                                });
                                */
                                switch (_bodyB.data["type"])
                                {
                                    case "shield":
                                        var constraint = new this.p2.LockConstraint(_bodyA, _bodyB);
                                        break;

                                    default:
                                        var constraint = new this.p2.RevoluteConstraint(_bodyA, _bodyB, {
                                            worldPivot: [_bodyA.position[0], _bodyA.position[1]]
                                        });
                                        break;
                                }              
                                constraint.setStiffness(1000);
                                this.localData.world.addConstraint(constraint);
                                _bodyA["constraint"] = constraint;
                                dataA["bStuck"] = true;
                                dataA["stuckToId"] = _bodyB.data["id"];
                            }
                        }
                    }
                    break;

                case "rocket":
                    if (dataB)
                    {
                        switch (dataB["type"])
                        {
                            case "helicopter":
                                var bDamage = true;
                                var bDetonate = true;
                                var attacker = this.getPlayerStateById(dataA.rocketData["playerId"]);
                                if (attacker)
                                {
                                    if (dataA.rocketData.causerId == dataB.id)
                                    {
                                        bDamage = false;
                                    }
                                    else if (attacker["id"] == dataB.heliData["playerId"])
                                    {
                                        bDamage = this.localData["bFriendlyFire"];
                                    }
                                    else if (attacker["team"] == dataB["team"])
                                    {
                                        bDamage = false; //this.localData["bFriendlyFire"];
                                    }
                                }
                                else
                                {
                                    if (dataA.rocketData["team"] == dataB["team"])
                                    {
                                        bDamage = false;
                                    }
                                }
                                bDetonate = bDamage;
                                if (bDamage)
                                {
                                    this.requestEvent({
                                        eventId: GameServer.EVENT_PAWN_DAMAGE,
                                        damageType: DamageType.DAMAGE_EXPLOSIVE,
                                        damageAmount: dataA["damage"],
                                        pawnId: dataB["id"],
                                        attackerId: dataA.rocketData["playerId"],
                                        causerId: dataA["id"],
                                        weaponId: dataA.rocketData["weaponId"]
                                    });
                                }
                                if (bDetonate)
                                {
                                    this.detonate(_bodyA, dataB["id"]);
                                }
                                break;

                            case "character":
                                var bDetonate = true;
                                var attackerPawn = this.getObjectById(dataA.rocketData["playerId"]);
                                if (attackerPawn)
                                {
                                    if (attackerPawn.data["id"] == dataB["id"])
                                    {
                                        bDetonate = false;
                                    }
                                    else if (dataA.rocketData["team"] == dataB["team"])
                                    {
                                        bDetonate = !this.localData["bSurvival"] && !this.localData["bSandbox"] && !this.localData["bBattlezone"];
                                    }
                                }
                                if (bDetonate)
                                {
                                    this.detonate(_bodyA);
                                }
                                break;

                            case "obstacle":
                            case "destructableObject":
                                if (this.localData["bSurvival"])
                                {
                                    if (dataA.rocketData["team"] == 0)
                                    {
                                        //Ignore
                                    }
                                }
                                else
                                {
                                    this.detonate(_bodyA);
                                }
                                break;

                            case "turret":
                                var bDetonate = true;
                                if (this.localData["bSurvival"] || this.localData["bSandbox"])
                                {
                                    bDetonate = dataA.rocketData["team"] != 0;
                                }
                                else if (dataA["team"] == dataB["team"])
                                {
                                    bDetonate = false;
                                }
                                if (bDetonate)
                                {
                                    this.detonate(_bodyA);
                                }
                                break;

                            case "equipment":
                                //Ignore
                                break;

                            case "door":
                                this.detonate(_bodyA);
                                this.setDoorClosed(_bodyB, false, _bodyA, true);
                                break;

                            default:
                                this.detonate(_bodyA);
                                break;
                        }
                    }
                    break;
            }
        }
    }

    createWeaponObject()
    {
        var data = {
            fireDelayTimer: 0,
            burstTimer: 0,
            recoil: 0
        };
        return data;
    }

    characterNeedsWeapon(_body)
    {
        var data = _body.data;
        if (data["bNoPickups"])
        {
            return false;
        }
        if (data.inventory.length == 1)
        {
            var item = data.inventory[0];
            if (item["type"] === Weapon.TYPE_PISTOL)
            {
                return true;
            }
            else if (this.characterHasNoAmmo(_body))
            {
                return true;
            }
        }
        else
        {
            if (this.characterHasNoAmmo(_body))
            {
                return true;
            }
            //var curItem = data.inventory[data.currentInventoryIndex];     
        }
        return false;
    }

    characterHasNoAmmo(_body)
    {
        var data = _body.data;
        for (var i = 0; i < data.inventory.length; i++)
        {
            var item = data.inventory[i];
            if (item["ammo"] > 0 && item["mag"] > 0)
            {
                return false;
            }
        }
        return true;
    }

    characterIsLowOnAmmo(_body)
    {
        var item = this.getCurrentCharacterInventoryItem(_body);
        if (item["ammo"] <= item["magSize"])
        {
            return true;
        }
        return false;
    }

    characterShouldReload(_body)
    {
        var item = this.getCurrentCharacterInventoryItem(_body);
        if (item["mag"] < item["magSize"])
        {
            return true;
        }
        return false;
    }

    getBestInventoryIndex(_body, _enemyPawn, _enemyDist)
    {
        var data = _body.data;
        var inventory = data["inventory"];
        var bestIndex = data["currentInventoryIndex"];
        var bestValue = 0;
        for (var i = 0; i < inventory.length; i++)
        {
            var item = inventory[i];
            var damage = item["damage"];
            if (item["type"] == Weapon.TYPE_SHOTGUN)
            {
                damage *= 6;
            }
            else if (item["type"] == Weapon.TYPE_LAUNCHER)
            {
                damage *= 0.5;
            }
            var itemValue = damage * item["magSize"];
            if (item["mag"] > 0 || item["ammo"] > 0 || data.weapon["bUnlimitedAmmo"])
            {
                var enemyState = _enemyPawn ? this.getPlayerStateById(_enemyPawn.data["id"]) : null;
                if (_enemyPawn && _enemyPawn.data["type"] == "helicopter")
                {
                    if (item["bRocket"])
                    {
                        bestIndex = i;
                    }
                }
                else
                {
                    if (enemyState && enemyState["bJuggernaut"] && !item["bAirOnly"] && (item["type"] == Weapon.TYPE_LAUNCHER))
                    {
                        bestIndex = i;
                    }
                    else if (_enemyPawn && _enemyDist < 200 && item["id"] == "riot_shield")
                    {
                        bestIndex = i;
                    }                    
                    else if (itemValue > bestValue && !item["bAirOnly"])
                    {
                        bestIndex = i;
                        bestValue = itemValue;
                    }
                }
            }
        }
        return bestIndex;
    }

    hasInventoryAmmo(_body)
    {
        var data = _body.data;
        var inventory = data["inventory"];
        for (var i = 0; i < inventory.length; i++)
        {
            if (inventory[i]["mag"] > 0 || inventory[i]["ammo"] > 0)
            {
                return true;
            }
        }
        if (data.weapon["bUnlimitedAmmo"])
        {
            return true;
        }
        return false;
    }

    emitAISound(_position, _team, _radius, _priority = 0)
    {
        if (!this.localData["bOperation"] && !this.localData["bBattlezone"])
        {
            return;
        }
        var chars = this.getCharacters();
        chars = chars.concat(this.getInfestors());
        for (var i = 0; i < chars.length; i++)
        {
            var char = chars[i];
            var data = char.data;
            if (data["bBot"])
            {
                if (_team != undefined && _team == data["team"])
                {
                    continue;
                }
                var ai = data["ai"];
                if (ai && !ai["bDisabled"] && ai["bCanInvestigate"] && !ai["currentEnemy"])
                {
                    var dist = this.Dist(_position[0], _position[1], char.position[0], char.position[1]);
                    if (!data["bStunned"] && !data["bFlashed"])
                    {
                        if (ai["investigatePos"])
                        {
                            if (ai.investigatePriority > _priority)
                            {
                                continue;
                            }
                        }
                        var radius = _radius ? _radius : ai.hearRange;
                        if (dist <= radius)
                        {
                            //On alert
                            this.requestEvent({
                                eventId: GameServer.EVENT_PAWN_ACTION,
                                pawnId: data["id"],
                                type: GameServer.PAWN_INVESTIGATE
                            });
                            ai["investigatePos"] = this.clone(_position);
                            ai["investigatePriority"] = _priority;
                            ai["returnPos"] = this.clone(char.position);
                        }
                    }
                }
            }
        }
        var helis = this.getHelicopters();
        for (var i = 0; i < helis.length; i++)
        {
            var heli = helis[i];
            var data = heli.data;
            if (data.team != 0)
            {
                var dist = this.Dist(_position[0], _position[1], heli.position[0], heli.position[1]);
                var hearRange = 1500 + (this.localData["difficulty"] * 500);
                if (dist <= hearRange)
                {
                    data.heliData.destination = [_position[0] - (data.muzzleOffsetX ? data.muzzleOffsetX : 0), data["bDrone"] ? _position[1] : Math.min(_position[1], this.getHeliMaxY())];
                }
            }
        }
    }

    getBestSpawnPosition(_team, _body)
    {
        var map = this.getCurrentMapData();
        var spawns = map.spawns;
        if (this.getCharacters().length == 0)
        {
            return spawns[this.Random(0, spawns.length - 1)];
        }
        var bestSpawns = [];
        var objects = this.getCharacters();
        objects = objects.concat(this.getHelicopters());
        objects = objects.concat(this.getAllFlags());
        var bomb = this.getBombCrate();
        if (bomb)
        {
            objects.push(bomb);
        }
        for (var i = 0; i < spawns.length; i++)
        {
            var curSpawn = spawns[i];
            var danger = 0;
            var flags = 0;
            var enemies = 0;
            for (var j = 0; j < objects.length; j++)
            {
                var cur = objects[j];
                if (cur == _body)
                {
                    continue;
                }
                var curDist = this.Dist(cur.position[0], cur.position[1], curSpawn[0], curSpawn[1]);
                var maxDist = map.width;
                if (curDist < maxDist)
                {
                    var distVal = (curDist / maxDist); //map.width - curDist;
                    if (cur.data["id"] == "crate_bomb")
                    {
                        enemies += 10;
                    }
                    if (cur.data["team"] != _team)
                    {
                        var bLOS = curDist < 300 || this.isInLOS(curSpawn, [cur.position[0], cur.position[1]], cur);
                        if (bLOS)
                        {
                            enemies++;
                        }
                        //Enemy
                        switch (cur.data["type"])
                        {
                            case "flag_domination":
                                if (this.localData.gameModeData["id"] == GameMode.DOMINATION)
                                {
                                    danger += distVal * 3;
                                }
                                break;

                            case "flag_defender":
                            case "flag_ctf":
                                danger += distVal;
                                break;

                            default:
                                danger += distVal;
                                break;
                        }
                    }
                    else
                    {
                        //Ally
                        switch (cur.data["type"])
                        {
                            case "flag_domination":
                                if (this.localData.gameModeData["id"] == GameMode.DOMINATION)
                                {
                                    if (curDist < 600)
                                    {
                                        flags++;
                                    }
                                    danger -= distVal * 3;
                                }
                                break;

                            case "flag_defender":
                            case "flag_ctf":
                                //Ignore
                                break;

                            default:
                                danger -= distVal;                             
                                break;
                        }
                    }
                }
            }
            bestSpawns.push({
                index: i,
                flags: flags,
                enemies: enemies,
                danger: danger
            });
        }
        bestSpawns.sort(function (a, b)
        {
            if (a.flags > b.flags) return -1;
            if (a.flags < b.flags) return 1; 
            if (a.enemies > b.enemies) return 1;
            if (a.enemies < b.enemies) return -1;  
            if (a.danger > b.danger) return -1;
            if (a.danger < b.danger) return 1;           
            return 0;
        });
        bestSpawns = [bestSpawns[0], bestSpawns[1], bestSpawns[2]];
        this.shuffleArray(bestSpawns);
        var selected = spawns[bestSpawns[0].index];        
        var res = [
            selected[0] + this.Random(-40, 40),
            selected[1]
        ];
        return res;
    }

    getBombCrate()
    {
        return this.getObjectById("crate_bomb");
    }

    isBeingInteractedWith(_body)
    {
        var chars = this.getCharacters();
        for (var i = 0; i < chars.length; i++)
        {
            var char = chars[i];
            if (char.data["interactableId"] == _body.data.id)
            {
                return true;
            }
        }
        return false;
    }

    getBestInteractable(_body)
    {
        if (this.localData["bBattlezone"])
        {
            var curItem = this.getCurrentCharacterInventoryItem(_body);
            if (curItem && this.isMeleeWeapon(curItem))
            {
                return null;
            }
            var lootPacks = this.getLootPacks();
            if (lootPacks.length > 0)
            {
                lootPacks.sort((a, b) =>
                {
                    var distA = this.Dist(_body.position[0], _body.position[1], a.position[0], a.position[1]);
                    var distB = this.Dist(_body.position[0], _body.position[1], b.position[0], b.position[1]);
                    if (distA < distB) return -1;
                    if (distA > distB) return 1;
                    return 0;
                });
                var curLoot = lootPacks[0];
                if (curLoot)
                {
                    return [curLoot, true];
                }
            }
        }
        var bomb = this.getBombCrate();
        if (bomb)
        {
            if (bomb.data["bBombPlanted"])
            {
                if (_body.data["team"] != this.localData.gameModeData["bombTeam"])
                {
                    return [bomb, false];
                }
            }
            else
            {
                if (_body.data["team"] == this.localData.gameModeData["bombTeam"])
                {
                    return [bomb, false];
                }
            }
        }
        var revivers = this.getRevivers();
        if (revivers.length > 0)
        {
            return [revivers[0], false];
        }
        var bLowOnAmmo = this.characterIsLowOnAmmo(_body);
        var bHasNoAmmo = this.characterHasNoAmmo(_body);
        if (bHasNoAmmo || bLowOnAmmo)
        {
            var ammoCrates = this.getAmmoCrates();
            if (ammoCrates.length > 0)
            {
                ammoCrates.sort((a, b) =>
                {
                    var distA = this.Dist(_body.position[0], _body.position[1], a.position[0], a.position[1]);
                    var distB = this.Dist(_body.position[0], _body.position[1], b.position[0], b.position[1]);
                    if (distA < distB) return -1;
                    if (distA > distB) return 1;
                    return 0;
                });
                return [ammoCrates[0], true];
            }
        }
        var bNeedsWeapon = this.characterNeedsWeapon(_body);
        if (bNeedsWeapon)
        {
            var droppedWeapons = this.getDroppedWeapons(true);
            if (droppedWeapons.length > 0)
            {
                droppedWeapons.sort(this.compareDroppedWeapons);
                return [droppedWeapons[0], bHasNoAmmo];
            }
        }
        if (!_body.data["bHasFlag"])
        {
            var turrets = this.getAvailableControllableTurrets(_body.data.team);
            if (turrets.length > 0)
            {
                turrets.sort((a, b) =>
                {
                    var distA = this.Dist(_body.position[0], _body.position[1], a.position[0], a.position[1]);
                    var distB = this.Dist(_body.position[0], _body.position[1], b.position[0], b.position[1]);
                    if (distA < distB) return -1;
                    if (distA > distB) return 1;
                    return 0;
                });
                var curTurret = turrets[0];
                return [curTurret, false];
            }
        }
        var itemCrates = this.getItemCrates(_body);
        if (itemCrates.length > 0)
        {
            for (var i = itemCrates.length - 1; i >= 0; i--)
            {
                var cr = itemCrates[i];
                if (cr.data["ownerId"] != _body.data["id"] && this.Dist(_body.position[0], _body.position[1], cr.position[0], cr.position[1]) > 1000) // && !this.checkLineOfSight(_body.position, cr.position, false, cr))
                {
                    itemCrates.splice(i, 1);
                }
            }
            itemCrates.sort((a, b) =>
            {
                var distA = this.Dist(_body.position[0], _body.position[1], a.position[0], a.position[1]);
                var distB = this.Dist(_body.position[0], _body.position[1], b.position[0], b.position[1]);
                if (distA < distB) return -1;
                if (distA > distB) return 1;
                return 0;
            });
            var curCrate = itemCrates[0];
            if (curCrate)
            {
                return [curCrate, curCrate.data["ownerId"] == _body.data["id"]];
            }
        }        
        return null;
    }

    compareDroppedWeapons(a, b)
    {
        var weaponA = a.data.interactData.weaponData;
        var weaponB = b.data.interactData.weaponData;
        if ((weaponA.damage * weaponA.magSize) > (weaponB.damage * weaponB.magSize))
        {
            return -1;
        }
        else if ((weaponA.damage * weaponA.magSize) < (weaponB.damage * weaponB.magSize))
        {
            return 1;
        }
        return 0;
    }

    setPawnAI(_body, _botSkill, _bZombie, _bHero)
    {
        var ai = {
            ticker: 1,
            pathTicker: 0,
            destThreshold: 30,
            activityTimer: 1,
            botSkill: _botSkill,
            lookToPos: [0, 0],
            moveToPos: null,
            path: null,
            fireBurstTimer: 0,
            fireBurstTimerMax: Math.round((this.Random(25, 30) + (_botSkill * 10)) * this.localData.settings.fps_mult),
            fireCooldownTimer: 0,
            fireCooldownTimerMax: Math.round((this.Random(90, 100) - (_botSkill * 15)) * this.localData.settings.fps_mult),
            semiCooldownTimer: 0,
            semiCooldownTimerMax: Math.round((this.Random(15, 20) - (_botSkill * 2)) * this.localData.settings.fps_mult),
            lookRange: this.Random(1000, 1100) + (_botSkill * (_bHero ? 200 : 100)),
            hearRange: Number.MAX_VALUE,
            bFireCooldown: true,
            bLOS: false,
            bObjectiveTakesPriority: false,
            bCanInteract: false,
            bCanCamp: !_bZombie,
            bCanExplore: true,
            bUseActivityTimer: true,
            bCanInvestigate: false,
            enemyDistMult: 1
        };
        if (this.localData["bOperation"])
        {
            ai.lookRange += 500;
        }
        if (!_bZombie)
        {            
            if (this.localData["bRanked"])
            {
                if (_botSkill == BotSkill.SKILL_EASY)
                {
                    ai.fireBurstTimerMax = Math.ceil(ai.fireBurstTimerMax * 0.4);
                    ai.fireCooldownTimerMax = Math.ceil(ai.fireCooldownTimerMax * 1.5);
                }
                else if (_botSkill == BotSkill.SKILL_NORMAL)
                {
                    ai.fireBurstTimerMax = Math.ceil(ai.fireBurstTimerMax * 0.5);
                    ai.fireCooldownTimerMax = Math.ceil(ai.fireCooldownTimerMax * 1.2);
                }
                else if (_botSkill == BotSkill.SKILL_INSANE)
                {
                    ai.semiCooldownTimerMax -= Math.round(3 * this.localData.settings.fps_mult);
                    ai.fireBurstTimerMax = Math.ceil(ai.fireBurstTimerMax * 1.5);
                }
                else if (_botSkill >= BotSkill.SKILL_GOD)
                {
                    ai.semiCooldownTimerMax = 1;
                    ai.fireBurstTimerMax = Math.ceil(ai.fireBurstTimerMax * 5);
                }
            }
            var mult = 1 - (_botSkill * 0.1);
            ai.fireCooldownTimer = Math.round(ai.fireCooldownTimerMax * mult);
            ai.semiCooldownTimer = Math.round(ai.semiCooldownTimerMax * mult);
        }
        _body.data["ai"] = ai;
        _body.data["aimSpeed"] = (0.05 + (_botSkill * 0.1)) / this.localData.settings.fps_mult;
    }

    generateMapNodes() 
    {
        this.log("Generating map nodes...");
        var map = this.getCurrentMapData();
        var nodes = map.nodes;
        var links = map.links;
        if (nodes && links)
        {
            var createGraph = this.data.graph;
            if (createGraph)
            {
                var graph = createGraph();
                this.localData.graphInstance = graph;
                for (var i = 0; i < nodes.length; i++)
                {
                    var node = nodes[i];
                    graph.addNode(node.id, node.data);
                }
                for (var i = 0; i < links.length; i++)
                {
                    var link = links[i];
                    graph.addLink(link.source, link.target);
                }
                this.localData.graph = graph;
                var path = this.data.path;
                var pathfinder = path.aStar(graph);
                this.localData.pathfinder = pathfinder;
            }
            else
            {
                console.warn("Invalid graph reference!");
            }
        }
        else
        {
            if (!nodes)
            {
                console.warn("Missing node data!");
            }
            if (!links)
            {
                console.warn("Missing link data!");
            }
        }
    }

    getClosestNode(_position)
    {
        if (_position)
        {
            var map = this.getCurrentMapData();
            var nodes = map.nodes;
            if (nodes)
            {
                var arr = [];
                for (var i = 0; i < nodes.length; i++)
                {
                    var node = nodes[i];
                    var bLOS = this.checkLineOfSight(_position, node.data.position);
                    var dist = this.Dist(_position[0], _position[1], node.data.position[0], node.data.position[1]);
                    arr.push({
                        node: node,
                        dist: dist,
                        bLOS: bLOS
                    });
                }
                if (arr.length === 0)
                {
                    return null;
                }
                arr.sort(function (a, b)
                {
                    if (a.bLOS < b.bLOS) return 1;
                    if (a.bLOS > b.bLOS) return -1;
                    if (a.dist < b.dist) return -1;
                    if (a.dist > b.dist) return 1;
                    return 0;
                });
                return arr[0].node;
            }
        }
        return null;
    }

    getAIPath(_start, _destination, _body, _destinationThreshold, _bIsOnLadder)
    {
        if (_start && _destination)
        {
            var graph = this.localData.graph;
            var pathfinder = this.localData.pathfinder;
            if (graph && pathfinder)
            {
                var fromNode = this.getClosestNode(_start);
                var toNode = this.getClosestNode(_destination);
                if (fromNode && toNode)
                {
                    var foundPath = pathfinder.find(fromNode.id, toNode.id);
                    if (foundPath)
                    {
                        if (foundPath.length > 0)
                        {
                            foundPath.reverse();
                            var node = foundPath[0];
                            if (node.data.type == "node_climb")
                            {
                                var data = _body.data;
                                if (!data["bIsOnLadder"])
                                {
                                    var nextNode = foundPath[1];
                                    if (nextNode && nextNode.data.position[1] < (_body.position[1] - 100))
                                    {
                                        var ladder = this.getObjectById(node.data.ladderId);
                                        if (ladder)
                                        {
                                            this.startLadderClimb(_body, ladder);
                                        }
                                    }
                                }
                            }
                            foundPath.splice(0, 1);
                            foundPath.push({
                                data: {
                                    position: _destination,
                                    type: "node_dest",
                                    threshold: _destinationThreshold
                                }
                            });
                        }
                        else
                        {
                            console.warn("Empty path!", fromNode.id, toNode.id, this.getCurrentMapData().id);
                        }
                        return foundPath;
                    }
                    else
                    {
                        console.warn("Invalid path!");
                    }
                }
                else
                {
                    if (!fromNode)
                    {
                        console.warn("Invalid fromNode!");
                    }
                    if (!toNode)
                    {
                        console.warn("Invalid toNode!");
                    }
                }
            }
            else
            {
                if (!graph)
                {
                    console.warn("Invalid graph reference!");
                }
                if (!pathfinder)
                {
                    console.warn("Invalid pathfinder reference!");
                }
            }
        }
        return null;
    }

    handleEquipment(_body)
    {
        var data = _body.data;
        var weaponData = data["weaponData"];
        switch (weaponData["id"])
        {
            case "trophy":
                if (data["bJammed"])
                {
                    break;
                }
                if (data["blockNum"] > 0)
                {
                    var targets = this.getRockets();
                    targets = targets.concat(this.getGrenades());
                    for (var i = 0; i < targets.length; i++)
                    {
                        var target = targets[i];
                        if (target.data["team"] != data["team"])
                        {
                            var dist = this.Dist(_body.position[0], _body.position[1], target.position[0], target.position[1]);
                            if (dist <= weaponData["radius"])
                            {
                                //TODO: Check LOS
                                data["blockNum"]--;
                                this.requestEvent({
                                    eventId: GameServer.EVENT_PAWN_ACTION,
                                    pawnId: data["id"],
                                    type: GameServer.PAWN_TROPHY_HIT,
                                    pos: target.position
                                });
                                this.removeNextStep(target);                                
                                this.createExplosion({
                                    eventId: GameServer.EVENT_SPAWN_EXPLOSION,
                                    x: target.position[0],
                                    y: target.position[1],
                                    radius: 200,
                                    damage: 0,
                                    playerId: null,
                                    causerId: null,
                                    weaponId: null
                                });                                
                                break;
                            }
                        }
                    }
                }
                else
                {
                    this.removeNextStep(_body);
                }
                break;

            default:
                if (weaponData["bMine"])
                {
                    if (data["bTriggered"])
                    {
                        if (data["triggerTimer"] == Math.ceil(this.localData.settings.fps * 0.5))
                        {
                            switch (data.weaponData["id"])
                            {
                                case "betty":
                                    _body.applyImpulse([0, -550], 0, 0);
                                    _body.angularVelocity = this.Random(-1, 1);
                                    break;
                            }
                        }
                        if (data["triggerTimer"] > 0)
                        {
                            data["triggerTimer"]--;
                        }
                        else
                        {
                            this.detonate(_body);
                        }
                    }
                    else 
                    {
                        var chars = this.getPawns(); //characters
                        for (var i = 0; i < chars.length; i++)
                        {
                            var char = chars[i];
                            if (char.data["team"] != data["team"])
                            {
                                if (data["bUseScale"])
                                {
                                    if (data["scale"] == 1 && char.position[0] < _body.position[0])
                                    {
                                        continue;
                                    }
                                    else if (data["scale"] == -1 && char.position[0] > _body.position[0])
                                    {
                                        continue;
                                    }
                                }
                                var bOverlap = (this.Dist(char.position[0], char.position[1], _body.position[0], _body.position[1]) < data["triggerRange"]) && this.checkLineOfSight(_body.position, char.position, false, char); //_body.getAABB().overlaps(char.getAABB());
                                if (bOverlap)
                                {
                                    var bSitrep = this.characterHasPerk(char, Perks.PERK_PLAYER_SITREP);
                                    this.triggerMine(_body, Math.ceil(this.localData.settings.fps * (bSitrep ? 3 : 0.5)));
                                    break;
                                }
                            }
                        }
                    }
                }
                break;
        }
    }

    handleFlagDomination(_body)
    {
        var data = _body.data;
        var charsTouching;
        var chars = this.getCharacters();
        for (var i = 0; i < chars.length; i++)
        {
            var char = chars[i];
            var bOverlap = _body.getAABB().overlaps(char.getAABB());
            if (bOverlap)
            {
                if (!charsTouching)
                {
                    charsTouching = {};
                }
                if (!charsTouching[char.data["team"]])
                {
                    charsTouching[char.data["team"]] = [];
                }
                charsTouching[char.data["team"]].push(char.data["id"]);
            }
        }
        var bWasBeingCaptured = data["bIsBeingCaptured"];
        var bWasContested = data["bIsContested"];
        var prevCapturingTeam = data["capturingTeam"];
        var prevTeam = data["team"];
        data["charsTouching"] = charsTouching;
        data["bIsBeingCaptured"] = false;
        data["bIsContested"] = false;
        data["capturingTeam"] = null;
        if (charsTouching)
        {
            var keys = Object.keys(charsTouching);
            if (keys.length === 1)
            {
                var team = parseInt(keys[0]);
                if (team != data["team"])
                {
                    data["bIsBeingCaptured"] = true;
                    data["capturingTeam"] = team;
                    if (data["captureTimer"][team] > 0)
                    {
                        data["captureTimer"][team] -= Math.min(charsTouching[team].length, 4);

                        for (var i = 0; i < charsTouching[team].length; i++)
                        {
                            var char = this.getObjectById(charsTouching[team][i]);
                            if (char)
                            {
                                char.data["bIsCapturingFlag"] = true;
                            }
                        }
                    }
                    else
                    {
                        data["captureTimer"][team] = 0;
                        data["team"] = team;

                        this.onFlagCaptured(_body, charsTouching[team]);
                    }
                }
            }
            else if (keys.length > 1)
            {
                data["bIsContested"] = true;
            }
        }
        else
        {
            if (this.localData.gameModeData["id"] == GameMode.DOMINATION)
            {
                data["captureTimerMax"] = this.localData.settings.fps * (data["team"] == null ? 5 : 10);
            }
            for (var i = 0; i < 2; i++)
            {
                if (data["captureTimer"][i] < data["captureTimerMax"])
                {
                    var val = 2; //4 * this.localData.settings.fps_mult;
                    data["captureTimer"][i] = Math.min(data["captureTimer"][i] + val, data["captureTimerMax"]);
                }
            }
        }
        if (data["team"] != undefined)
        {
            if (data["pointTimer"] > 0)
            {
                data["pointTimer"]--;
            }
            else
            {
                this.onFlagPoint(data["team"]);
                data["pointTimer"] = data["pointTimerMax"];
            }
        }
        var params = [];
        if (bWasBeingCaptured != data.bIsBeingCaptured)
        {
            params.push("bIsBeingCaptured");
        }
        if (bWasContested != data.bIsContested)
        {
            params.push("bIsContested");
        }
        if (prevCapturingTeam != data.capturingTeam)
        {
            params.push("capturingTeam");
        }
        if (prevTeam != data.team)
        {
            params.push("team");
        }
        if (params.length > 0)
        {
            this.pushObjectDataUpdate(data.id, params);
        }
    }

    returnFlagCTF(_body, _playerId)
    {
        if (_body)
        {
            var data = _body.data;
            var map = this.getCurrentMapData();
            var pos = map["flags_ctf"][data["team"]];
            if (pos)
            {
                _body.position[0] = pos[0];
                _body.position[1] = pos[1];
            }
            else
            {
                console.warn("Invalid flag position", map.flags_ctf, data.team);
            }
            data["bAwayFromHome"] = false;
            data["cooldownTimer"] = 5;
            if (_playerId)
            {
                this.onFlagReturned(_body, _playerId);
            }
        }
    }

    returnFlagDefender(_body)
    {
        if (_body)
        {
            var data = _body.data;
            var map = this.getCurrentMapData();
            var pos = map.flag_defender;
            if (!pos)
            {
                pos = map.flags_headquarters[0];
            }
            if (pos)
            {
                _body.position[0] = pos[0];
                _body.position[1] = pos[1];
            }
            data["cooldownTimer"] = 5;
        }
    }

    characterHasFlag(_body)
    {
        return false;
    }

    handleFlagCTF(_body)
    {
        if (this.isOutOfMap(_body))
        {
            this.returnFlagCTF(_body);
        }
        var data = _body.data;        
        if (data["cooldownTimer"] > 0)
        {
            data["cooldownTimer"]--;
        }
        else
        {
            delete data["cooldownTimer"];
        }
        if (data["carrierId"])
        {
            var carrier = this.getObjectById(data["carrierId"]);
            if (carrier)
            {
                if (carrier.data["health"])
                {
                    _body.position[0] = carrier.position[0];
                    _body.position[1] = carrier.position[1] - 40;
                }
                _body.gravityScale = 0;
            }
            else
            {
                this.onFlagDropped(_body, data["carrierId"]);
                this.setFlagCarrierId(_body, null);
            }
        }    
        if (data["bAwayFromHome"])
        {
            if (!data["carrierId"])
            {
                _body.gravityScale = 1;
            }
        }
        else
        {
            var map = this.getCurrentMapData();
            var pos = map.flags_ctf[data["team"]];
            _body.position[0] = pos[0];
            _body.position[1] = pos[1];
            _body.gravityScale = 0;
        }
        if (!data["cooldownTimer"])
        {
            var chars = this.getCharacters();
            for (var i = 0; i < chars.length; i++)
            {
                var char = chars[i];
                var bOverlap = _body.getAABB().overlaps(char.getAABB());
                if (bOverlap)
                {
                    if (char.data["team"] == data["team"])
                    {
                        if (!data["carrierId"] && data["bAwayFromHome"])
                        {
                            data["cooldownTimer"] = 5;
                            this.returnFlagCTF(_body, char.data["id"]);
                        }
                        else if (!data["bAwayFromHome"])
                        {
                            var otherFlag = this.getFlagCTF(data["team"] == 1 ? 0 : 1);
                            if (otherFlag.data["carrierId"] == char.data["id"])
                            {
                                this.setFlagCarrierId(otherFlag, null);
                                otherFlag.data["cooldownTimer"] = 5;
                                var map = this.getCurrentMapData();
                                var pos = map["flags_ctf"][otherFlag.data["team"]];
                                otherFlag.position[0] = pos[0];
                                otherFlag.position[1] = pos[1];
                                otherFlag.data["bAwayFromHome"] = false;                                
                                otherFlag.wakeUp();

                                data["cooldownTimer"] = 5;
                                this.onFlagCaptured(_body, [char.data["id"]]);
                                return;
                            }
                        }
                    }
                    else
                    {
                        if (!data["carrierId"])
                        {
                            this.setFlagCarrierId(_body, char.data.id);
                            data["bAwayFromHome"] = true;
                            data["cooldownTimer"] = 5;

                            this.onFlagPickedUp(_body, char.data["id"]);
                        }
                    }
                }
            }
        }
    }

    setFlagCarrierId(_body, _carrierId)
    {
        if (_body)
        {
            var data = _body.data;
            var prev = data.carrierId;
            data.carrierId = _carrierId;
            if (prev != _carrierId)
            {
                this.pushObjectDataUpdate(data.id, ["carrierId"]);
            }
        }
    }

    handleFlagDefender(_body)
    {
        if (this.isOutOfMap(_body))
        {
            this.returnFlagDefender(_body);
        }
        var data = _body.data;
        if (data["cooldownTimer"] > 0)
        {
            data["cooldownTimer"]--;
        }
        else
        {
            delete data["cooldownTimer"];
        }
        if (data["carrierId"])
        {
            var carrier = this.getObjectById(data["carrierId"]);
            if (carrier)
            {
                if (carrier.data["health"])
                {
                    var prevTeam = data.team;
                    data["team"] = carrier.data["team"];
                    if (prevTeam != data.team)
                    {
                        this.pushObjectDataUpdate(data.id, ["team"]);
                    }
                    _body.position[0] = carrier.position[0];
                    _body.position[1] = carrier.position[1] - 40;
                    _body.gravityScale = 0;
                }
            }
            else
            {
                this.onFlagDropped(_body, data["carrierId"]);
                _body.gravityScale = 1;
                data["team"] = null;
                this.pushObjectDataUpdate(data.id, ["team"]);
                this.setFlagCarrierId(_body, null);
                data["cooldownTimer"] = 5;                
            }
        }
        if (!data["cooldownTimer"])
        {
            var chars = this.getCharacters();
            for (var i = 0; i < chars.length; i++)
            {
                var char = chars[i];
                var bOverlap = _body.getAABB().overlaps(char.getAABB());
                if (bOverlap)
                {
                    if (!data["carrierId"])
                    {
                        this.setFlagCarrierId(_body, char.data.id);
                        data["cooldownTimer"] = 5;

                        this.onDefenderFlagPickedUp(_body, char.data["id"]);
                    }
                }
            }
        }
        if (data["team"] != null)
        {
            if (data["pointTimer"] > 0)
            {
                data["pointTimer"]--;
            }
            else
            {
                this.onFlagPoint(data["team"], data["carrierId"]);
                data["pointTimer"] = data["pointTimerMax"];
            }
        }
        //LocalServer.localData.gameModeData["flagTeam"] = data["team"];
    }

    getDefenderFlag()
    {
        return this.getObjectById("flag_defender");
    }

    isHoldingFlag(_body)
    {
        if (_body)
        {
            switch (this.localData.gameModeData["id"])
            {
                case GameMode.DEFENDER:
                    var flag = this.getDefenderFlag();
                    if (flag)
                    {
                        return flag.data.carrierId == _body.data.id;
                    }
                    break;

                case GameMode.CAPTURE_THE_FLAG:
                    var flags = [this.getFlagCTF(0), this.getFlagCTF(1)];
                    for (var i = 0; i < flags.length; i++)
                    {
                        flag = flags[i];
                        if (flag && flag.data.carrierId == _body.data.id)
                        {
                            return true;
                        }
                    }                    
                    break;
            }
        }
        return false;
    }

    handleCharacter(_body)
    {
        var data = _body.data;
        data["bOnGround"] = this.isOnGround(_body);
        if (!_body.fixedRotation)
        {
            if (!data["bOnGround"])
            {
                _body.angularVelocity = -_body.angle * 10;
            }
        }

        var stepMaterial = this.getSurfaceMaterial(_body);
        if (stepMaterial)
        {
            data["step"] = stepMaterial;
        }

        //Kill players out of bounds
        var bounds = 10;
        if (_body.position[0] < -bounds || _body.position[0] > (this.getCurrentMapData().width + bounds) || _body.position[1] > this.getCurrentMapData().height)
        {
            this.log("Player out of bounds: " + data["id"]);
            this.killPawn(data["id"]);
        }
        this.constrainVelocity(_body, 600);
        _body.position[1] = Math.max(0, _body.position[1]);
        var target = this.WrapAngle(data["aimRotation"] - data["desiredAimRotation"], true);
        data["aimRotation"] -= target * data["aimSpeed"];
        var deg = this.ToDeg(this.WrapAngle(data["aimRotation"], true));
        var abs = Math.abs(deg);
        data["scale"] = abs < 90 ? 1 : -1;
        if (data["bUseExposeTimer"] && data["bExposed"])
        {
            if (data["exposedTimer"] > 0)
            {
                data["exposedTimer"]--;
            }
            else
            {
                data["bExposed"] = false;
            }
        }
        if (data["bWantsToMove"] && this.characterCanMove(_body) && this.matchInProgress())
        {
            var maxSpeed = data["maxSpeed"] * this.getCharacterSpeedMultiplier(_body); //data["speedMultiplier"];
            if (data["bStunned"])
            {
                maxSpeed = maxSpeed * 0.2;
            }
            else if (data["bFreeze"])
            {
                maxSpeed = maxSpeed * 0.5;
            }
            else if (!data["bIsOnLadder"])
            {
                if (data["bWantsToSprint"])
                {
                    var mult = this.characterHasPerk(_body, Perks.PERK_PLAYER_LIGHTWEIGHT) ? 2 : 1.8;
                    maxSpeed = maxSpeed * mult;
                }
                else if (data["bWantsToCrouch"])
                {
                    var mult = this.characterHasPerk(_body, Perks.PERK_PLAYER_NINJA) ? 1 : 0.6;
                    maxSpeed = maxSpeed * mult;
                }
            }
            switch (data["moveX"])
            {
                case -1:
                    _body.velocity[0] = -maxSpeed;
                    if (data["type"] === "character")
                    {
                        var normal = this.getSurfaceNormal(_body);
                        if (normal && maxSpeed > 100)
                        {
                            var normX = Math.abs(normal[0]);
                            if (normX < 0.8)
                            {
                                _body.velocity[1] += (maxSpeed * normX) * this.localData.settings.fixed_timestep_mult;
                            }
                        }
                    }
                    break

                case 1:
                    _body.velocity[0] = maxSpeed;
                    if (data["type"] === "character")
                    {
                        var normal = this.getSurfaceNormal(_body);
                        if (normal && maxSpeed > 0)
                        {
                            var normX = Math.abs(normal[0]);
                            if (normX < 0.8)
                            {
                                _body.velocity[1] += (maxSpeed * normX) * this.localData.settings.fixed_timestep_mult;
                            }
                        }
                    }
                    break;
            }
        }
        else
        {
            _body.velocity[0] = 0;
        }
        if (data["bIsOnLadder"])
        {
            var shape = _body.shapes[0];
            if (shape)
            {
                shape.collisionMask = CollisionGroups.PROJECTILE;
            }
            data["bWantsToCrouch"] = false;
            var ladder = this.getObjectById(data["ladderId"]);
            if (ladder)
            {
                if (!data["bLadderCooldown"])
                {
                    var ladderHeightHalf = (ladder.shapes[0].height * 0.5);
                    if (_body.position[1] < (ladder.position[1] - ladderHeightHalf))
                    {
                        if (_body.velocity[1] < 0)
                        {
                            this.leaveLadder(_body);
                        }
                    }
                    else if (_body.position[1] > (ladder.position[1] + ladderHeightHalf))
                    {
                        if (_body.velocity[1] > 0 && data["moveY"] === 1)
                        {
                            this.leaveLadder(_body);
                        }
                    }
                }
            }
            if (data["bWantsToClimb"])
            {
                var climbSpeed = (data["maxSpeed"] * this.getCharacterSpeedMultiplier(_body)) * data["climbSpeedMultiplier"];
                if (data["bStunned"])
                {
                    climbSpeed = climbSpeed * 0.2;
                }
                else if (data["bFreeze"])
                {
                    climbSpeed = climbSpeed * 0.5;
                }
                if (this.characterHasPerk(_body, Perks.PERK_PLAYER_NINJA))
                {
                    climbSpeed *= this.getSharedData("perks")["ninjaClimbSpeedMultiplier"];
                }

                switch (data["moveY"])
                {
                    case -1:
                        _body.velocity[1] = -climbSpeed;
                        break

                    case 1:
                        _body.velocity[1] = climbSpeed;
                        break;
                }
            }
            else
            {
                _body.velocity[1] = 0;
            }
        }
        var lastAimSpeed = data["aimSpeed"];
        if (data["bStunned"])
        {
            data["aimSpeed"] = 0.01 / this.localData.settings.fps_mult;
        }
        else
        {
            data["aimSpeed"] = Math.min((0.2 * data["aimSpeedMultiplier"]) / this.localData.settings.fps_mult, 1);
        }
        if (!data["bBot"])
        {
            if (data["aimSpeed"] != lastAimSpeed)
            {
                this.pushObjectDataUpdate(data["id"], ["aimSpeed"]);
            }
        }
        if (data["type"] == "character")
        {
            var desiredHeight = 85;
            if (data["bWantsToCrouch"] && !data["bIsOnLadder"])
            {
                data["bWantsToSprint"] = false;
                desiredHeight = 60;
            }
            var shape = _body.shapes[0];
            if (shape.height != desiredHeight)
            {
                _body.removeShape(shape);
                var shape = new this.p2.Box({
                    width: 40,
                    height: desiredHeight,
                    collisionGroup: CollisionGroups.PAWN,
                    collisionMask: data["bIsOnLadder"] ? CollisionGroups.PROJECTILE : (CollisionGroups.GROUND | CollisionGroups.PLATFORM | CollisionGroups.PROJECTILE)
                });
                _body.addShape(shape);
                if (data["bOnGround"] && !data["bIsOnLadder"])
                {
                    if (data["bWantsToCrouch"])
                    {
                        _body.position[1] -= 1;
                    }
                    else 
                    {
                        _body.position[1] -= 15;
                    }
                }
                _body.wakeUp();
            }
        }        
        if (data["bRegenHealth"])
        {
            var regenThreshold = data["maxHealth"];
            if (data["bJuggernaut"])
            {
                regenThreshold = data["maxHealth"] * 0.25; //Juggernaut threshold
            }
            if (data["health"] < regenThreshold)
            {
                if (data["regenTimer"] == 0)
                {
                    data["health"] = Math.min(data["maxHealth"], data["health"] + data["regenAmount"]);
                    this.pushObjectDataUpdate(data.id, ["health", "maxHealth"]);
                    if (data["damagedBy"])
                    {
                        delete data["damagedBy"];
                    }
                }
                else
                {
                    data["regenTimer"]--;
                }
            }
        }
        var item = this.getCurrentCharacterInventoryItem(_body);
        if (data.weapon)
        {
            var recoilMult = 0.3; //Lower value is faster recoil recovery
            if (item.type != Weapon.TYPE_PISTOL)
            {
                if (item["fireMode"] == Weapon.MODE_AUTO || item["fireRate"] <= 10)
                {
                    recoilMult = 0.2;
                }
            }
            if (item["bRevolver"])
            {
                recoilMult -= 0.1;
            }
            if (data["bWantsToCrouch"])
            {
                recoilMult += 0.05;
            }
            if (item.type != Weapon.TYPE_SHOTGUN && data["bADS"])
            {
                recoilMult += 0.05;
            }
            if (this.hasMod(item, Mods.BARREL_GRIP) || this.hasMod(item, Mods.BASE_DAMPER) || this.hasMod(item, Mods.BARREL_COMPENSATOR))
            {
                //recoilMult += 0.05;
            }
            var recoilDecay = recoilMult * this.localData.settings.fps_mult;
            data.weapon.recoil -= data.weapon.recoil * recoilDecay;
            data.weapon.recoil = this.RoundDecimal(data.weapon.recoil);
        }
        if (item["bAirOnly"] && data["lookPos"])
        {
            var prev = data["lockOnTargetId"];
            data["lockOnTargetId"] = null;
            var helis = this.getHelicopters();
            for (var i = 0; i < helis.length; i++)
            {
                var heli = helis[i];
                if (heli.data["team"] !== data["team"])
                {
                    var bContainsPoint = heli.getAABB().containsPoint(data["lookPos"]) || this.Dist(heli.position[0], heli.position[1], data.lookPos[0], data.lookPos[1]) < 100;
                    if (bContainsPoint)
                    {
                        data["lockOnTargetId"] = heli.data["id"];
                        break;
                    }
                }
            }
            if (prev != data["lockOnTargetId"])
            {
                this.pushObjectDataUpdate(data.id, ["lockOnTargetId"]);
            }
        }
        if (data["bWantsToInteract"])
        {
            var interactable = this.getObjectById(data["interactableId"]);
            if (interactable)
            {
                if (data["interactTimer"] > 0)
                {
                    data["interactTimer"]--;
                }
                else
                {
                    if (data["interactableId"])
                    {
                        this.executeInteractable(interactable, data["id"]);
                    }
                    this.stopCharacterInteract(_body);
                }
            }
            else
            {
                this.stopCharacterInteract(_body);
            }
        }
        //Ladder cooldown
        if (data["bLadderCooldown"])
        {
            if (data["ladderCooldownTimer"] > 0)
            {
                data["ladderCooldownTimer"]--;
            }
            else
            {
                //Ladder cooldown over
                var shape = _body.shapes[0];
                if (shape)
                {
                    shape.collisionMask = CollisionGroups.GROUND | CollisionGroups.PLATFORM | CollisionGroups.PROJECTILE;
                }
                data["speedMultiplier"] = this.getCurrentCharacterInventoryItem(_body)["speedModifier"];
                delete data["bLadderCooldown"];
                delete data["ladderCooldownTimer"];
                this.pushObjectDataUpdate(data.id, ["bLadderCooldown"]);
            }
        }
        //Shield cooldown
        if (data["bShieldCooldown"])
        {
            if (data["shieldCooldownTimer"] > 0)
            {
                data["shieldCooldownTimer"]--;
            }
            else
            {
                delete data["bShieldCooldown"];
                delete data["shieldCooldownTimer"];
                this.requestEvent({
                    eventId: GameServer.EVENT_PAWN_ACTION,
                    pawnId: data["id"],
                    type: GameServer.PAWN_END_SHIELD_COOLDOWN,
                    bDoor: data["bDoorCooldown"]
                });
            }
        }
        //Barrel mod cooldown
        if (data["bBarrelCooldown"])
        {
            if (data["barrelCooldownTimer"] > 0)
            {
                data["barrelCooldownTimer"]--;
            }
            else
            {
                delete data["bBarrelCooldown"];
                delete data["barrelCooldownTimer"]
            }
        }
        var weapon = data["weapon"];
        var curInvItem = this.getCurrentCharacterInventoryItem(_body);
        //Fire handler
        if (weapon["bFireHandler"])
        {
            if (!data["bWantsToFire"])
            {
                weapon["bFireHandler"] = false;
            }
            else
            {
                if (this.characterCanFire(_body))
                {
                    this.fireCharacterWeapon(_body);
                    switch (curInvItem["fireMode"])
                    {
                        case Weapon.MODE_SEMI:
                            weapon["bFireDelay"] = true;
                            var fireRate = curInvItem["fireRate"]; // + (this.localData.settings.fps == 60 ? 1 : 0); 
                            weapon["fireDelayTimer"] = Math.floor(fireRate * this.localData.settings.fps_mult);
                            weapon["bFireHandler"] = false;
                            break;

                        case Weapon.MODE_BURST:
                            weapon["bFireDelay"] = true;
                            var burstFireRate = curInvItem["burstFireRate"]; // + (this.localData.settings.fps == 60 ? 1 : 0); 
                            weapon["fireDelayTimer"] = Math.round(burstFireRate * this.localData.settings.fps_mult);
                            curInvItem["bursts"] = (curInvItem["numBursts"] ? curInvItem["numBursts"] : 3) - 1;
                            var fireRate = curInvItem["fireRate"] + (this.localData.settings.fps == 60 ? 1 : 0);
                            weapon["burstTimer"] = Math.floor(fireRate * this.localData.settings.fps_mult);
                            weapon["bBurstFireHandler"] = true;
                            weapon["bFireHandler"] = false;
                            break;

                        case Weapon.MODE_AUTO:
                            weapon["bFireDelay"] = true;
                            var fireRate = curInvItem["fireRate"]; // + (this.localData.settings.fps == 60 ? 1 : 0); 
                            weapon["fireDelayTimer"] = Math.max(1, Math.ceil(fireRate * this.localData.settings.fps_mult));
                            break;
                    }
                }
                else if (curInvItem["mag"] == 0)
                {
                    this.reloadCharacterWeapon(_body);
                }
                else if (curInvItem["bAirOnly"])
                {
                    this.reloadCharacterWeapon(_body);
                }
                else if (data["bIsReloading"])
                {
                    if (curInvItem["bSingleRoundLoaded"] && curInvItem["mag"] > 0)
                    {
                        this.cancelCharacterReload(_body);
                    }
                }
            }
        }
        //Burst fire handler
        if (weapon["bBurstFireHandler"])
        {
            if (curInvItem["bursts"] > 0)
            {
                if (weapon["burstTimer"] > 0) 
                {
                    weapon["burstTimer"]--;
                }
                else 
                {
                    if (curInvItem["mag"] > 0) 
                    {
                        if (curInvItem["bursts"] > 0)
                        {
                            curInvItem["bursts"]--;
                        }
                        weapon["burstTimer"] = Math.round(curInvItem["fireRate"] * this.localData.settings.fps_mult);
                        this.fireCharacterWeapon(_body);
                    }
                    else 
                    {
                        weapon["bBurstFireHandler"] = false;
                    }
                }
            }
            else 
            {
                weapon["bBurstFireHandler"] = false;
            }
        }
        //Fire delay handler
        if (weapon["bFireDelay"])
        {
            weapon["fireDelayTimer"]--;
            if (weapon["fireDelayTimer"] <= 0) 
            {
                weapon["bFireDelay"] = false;
                this.requestEvent({
                    eventId: GameServer.EVENT_PAWN_ACTION,
                    pawnId: data["id"],
                    type: GameServer.PAWN_END_FIRE_DELAY
                });
                if (curInvItem["bNeedsBoltPull"])
                {
                    this.pullCharacterBolt(_body);
                }
                else if (curInvItem["mag"] == 0)
                {
                    if (curInvItem["ammo"] > 0)
                    {
                        this.reloadCharacterWeapon(_body);
                    }
                    this.onEndWeaponFire(_body);
                }
            }
        }
        //Bolt delay handler
        if (weapon["bBoltDelay"])
        {
            weapon["boltDelayTimer"]--;
            if (weapon["boltDelayTimer"] <= 0) 
            {
                weapon["bBoltDelay"] = false;
                curInvItem["bNeedsBoltPull"] = false;
                this.requestEvent({
                    eventId: GameServer.EVENT_PAWN_ACTION,
                    pawnId: data["id"],
                    type: GameServer.PAWN_END_BOLT_DELAY
                });
                if (curInvItem["mag"] == 0 && curInvItem["ammo"] > 0)
                {
                    this.reloadCharacterWeapon(_body);
                }
            }
        }
        //Throw delay handler
        if (weapon["bThrowDelay"])
        {
            weapon["throwDelayTimer"]--;
            if (weapon["throwDelayTimer"] <= 0) 
            {
                weapon["bThrowDelay"] = false;
                this.requestEvent({
                    eventId: GameServer.EVENT_PAWN_ACTION,
                    pawnId: data["id"],
                    type: GameServer.PAWN_END_THROW_DELAY
                });
            }
        }
        //Equipment delay handler
        if (weapon["bEquipmentDelay"])
        {
            if (weapon["equipmentDelayTimer"] > 0)
            {
                weapon["equipmentDelayTimer"]--;
                data["bWantsToCrouch"] = true;
            }
            else
            {
                weapon["bEquipmentDelay"] = false;
                this.requestEvent({
                    eventId: GameServer.EVENT_PAWN_ACTION,
                    pawnId: data["id"],
                    type: GameServer.PAWN_END_EQUIPMENT_DELAY
                });
                data["bWantsToCrouch"] = false;
                this.pushObjectDataUpdate(data.id, ["bWantsToCrouch"]);
            }
        }
        if (weapon["bUseDelay"])
        {
            if (weapon["useDelayTimer"] > 0)
            {
                weapon["useDelayTimer"]--;
            }
            if (weapon["useDelayTimer"] == 0) 
            {
                weapon["useDelayTimer"] = -1;
                var useData = weapon["useData"];
                if (useData)
                {
                    switch (useData["type"])
                    {
                        case "killstreak":
                            var killstreakId = this.getCurrentPlayerKillstreak(data["id"]);
                            var killstreakData = this.getKillstreakData(killstreakId);
                            if (!data["bBot"] && (killstreakData ? killstreakData["bWorldMenu"] : false))
                            {
                                this.onEvent({
                                    eventId: GameServer.EVENT_PLAYER_OPEN_WORLD_MENU,
                                    playerId: data["id"],
                                    killstreakId: killstreakId
                                });
                            }
                            else
                            {
                                this.triggerPlayerCurrentKillstreak(data["id"], useData.position[0], useData.position[1]);
                                this.endCharacterUseDelay(_body);
                            }
                            break;
                    }
                }
            }
        }
        //Melee delay handler
        if (weapon["bMeleeDelay"])
        {
            weapon["meleeDelayTimer"]--;
            if (weapon["meleeDelayTimer"] <= 0) 
            {
                weapon["bMeleeDelay"] = false;
                this.requestEvent({
                    eventId: GameServer.EVENT_PAWN_ACTION,
                    pawnId: data["id"],
                    type: GameServer.PAWN_END_MELEE_DELAY
                });
                if (curInvItem["mag"] == 0 && curInvItem["ammo"] > 0)
                {
                    this.reloadCharacterWeapon(_body);
                }
            }
        }
        //Reload handler
        if (data["bIsReloading"])
        {
            data["reloadTimer"]--;
            if (data["reloadTimer"] == 0)
            {
                data["bIsReloading"] = false;
                if (curInvItem["bSingleRoundLoaded"])
                {
                    var roundsToLoad = 1;
                    if (curInvItem["bSpeedLoader"])
                    {
                        var speedLoader = 2;
                        if (weapon.bUnlimitedAmmo)
                        {
                            roundsToLoad = speedLoader;
                        }
                        else if (curInvItem["ammo"] > speedLoader && (curInvItem["mag"] + speedLoader) <= curInvItem["magSize"])
                        {
                            roundsToLoad = speedLoader;
                        }
                    }
                    if (!weapon.bUnlimitedAmmo)
                    {
                        curInvItem["ammo"] = Math.max(curInvItem["ammo"] - roundsToLoad, 0);
                    }
                    curInvItem["mag"] = Math.min(curInvItem["mag"] + roundsToLoad, curInvItem["magSize"]);
                }
                else
                {
                    if (curInvItem["ammo"] >= curInvItem["magSize"] || weapon.bUnlimitedAmmo) 
                    {
                        if (!weapon.bUnlimitedAmmo)
                        {
                            curInvItem["ammo"] -= curInvItem["magSize"] - curInvItem["mag"];
                        }
                        curInvItem["mag"] = curInvItem["magSize"];
                    }
                    else if ((curInvItem["ammo"] + curInvItem["mag"]) > curInvItem["magSize"]) 
                    {
                        if (!weapon.bUnlimitedAmmo)
                        {
                            curInvItem["ammo"] -= curInvItem["magSize"] - curInvItem["mag"];
                        }
                        curInvItem["mag"] += (curInvItem["magSize"] - curInvItem["mag"]);
                    }
                    else 
                    {
                        curInvItem["mag"] += curInvItem["ammo"];
                        if (!weapon.bUnlimitedAmmo)
                        {
                            curInvItem["ammo"] -= curInvItem["ammo"];
                        }
                    }
                }
                this.requestEvent({
                    eventId: GameServer.EVENT_PLAYER_UPDATE_INVENTORY,
                    pawnId: data["id"],
                    index: data["currentInventoryIndex"],
                    type: GameServer.INV_ITEM
                });
                this.requestEvent({
                    eventId: GameServer.EVENT_PAWN_ACTION,
                    pawnId: data["id"],
                    type: GameServer.PAWN_RELOAD_COMPLETE
                });
                if (curInvItem["bSingleRoundLoaded"] && curInvItem["mag"] < curInvItem["magSize"])
                {
                    this.reloadCharacterWeapon(_body);
                }
            }
        }
        //Player actions
        if (this.getPlayerStateById(data["id"]) != null)
        {
            var droppedWeapons = this.getDroppedWeapons();
            for (var i = 0; i < droppedWeapons.length; i++)
            {
                var dropped = droppedWeapons[i];
                if (this.characterHasWeapon(_body, dropped.data.interactData.weaponData["id"]))
                {
                    if (!dropped.data.interactData.weaponData["bMelee"])
                    {
                        if (dropped.getAABB().overlaps(_body.getAABB()))
                        {
                            this.requestEvent({
                                eventId: GameServer.EVENT_PLAYER_INTERACT,
                                playerId: data.id,
                                pawnId: data.id,
                                interactableId: dropped.data["id"],
                                bServerSideOnly: true
                            });
                            break;
                        }
                    }
                }
                else if (this.characterHasEquipment(_body, dropped.data.interactData.weaponData["id"]) && _body.data.equipment["ammo"] < _body.data.equipment["ammoMax"])
                {
                    if (dropped.getAABB().overlaps(_body.getAABB()))
                    {
                        this.requestEvent({
                            eventId: GameServer.EVENT_PLAYER_INTERACT,
                            playerId: data.id,
                            pawnId: data.id,
                            interactableId: dropped.data["id"],
                            bServerSideOnly: true
                        });
                        break;
                    }
                }
            }
        }
    }

    characterHasWeapon(_body, _weaponId)
    {
        if (_body)
        {
            var inventory = _body.data["inventory"];
            if (inventory)
            {
                for (var i = 0; i < inventory.length; i++)
                {
                    if (inventory[i]["id"] === _weaponId)
                    {
                        return true;
                    }
                }
            }
        }
        return false;
    }

    characterHasEquipment(_body, _weaponId)
    {
        if (_body)
        {
            var equipment = _body.data["equipment"];
            return equipment && equipment["id"] == _weaponId;
        }
        return false;
    }

    endCharacterUseDelay(_body)
    {
        var data = _body.data;
        var weapon = data.weapon;
        if (weapon["bUseDelay"])
        {
            weapon["bUseDelay"] = false;
            delete weapon["useData"];
            var ps = this.getPlayerStateById(_body.data["id"]);
            if (ps && !ps.controllableId)
            {
                this.requestEvent({
                    eventId: GameServer.EVENT_PAWN_ACTION,
                    pawnId: ps["id"],
                    type: GameServer.PAWN_CLOSE_LAPTOP
                });
            }
        }
    }

    getCurrentCharacterInventoryItem(_body)
    {
        return _body.data.inventory[_body.data["currentInventoryIndex"]];
    }

    setCharacterCurrentInventoryItem(_body, _index)
    {
        this.cancelCharacterReload(_body);
        this.cancelCharacterBoltPull(_body);
        var prev = this.getCurrentCharacterInventoryItem(_body);
        if (prev && prev["id"] == "riot_shield")
        {
            _body.data["bShieldCooldown"] = true;
            _body.data["shieldCooldownTimer"] = Math.ceil(this.localData.settings.fps * (this.characterHasPerk(_body, Perks.PERK_WEAPON_QUICKDRAW) ? 0.3 : 0.6));
            this.requestEvent({
                eventId: GameServer.EVENT_PAWN_ACTION,
                pawnId: _body.data["id"],
                type: GameServer.PAWN_START_SHIELD_COOLDOWN
            });
        }
        _body.data["currentInventoryIndex"] = _index;
        var item = this.getCurrentCharacterInventoryItem(_body);
        _body.data["reloadTimerMax"] = Math.round(Math.ceil(item["reloadTime"] * this.localData.settings.fps) / _body.data["reloadMultiplier"]);
        _body.data["reloadTimer"] = _body.data["reloadTimerMax"];
        _body.data["aimRotation"] = this.ToRad(-90);
        _body.data["speedMultiplier"] = item["speedModifier"];
        if (item["bNeedsBoltPull"])
        {
            this.pullCharacterBolt(_body);
        }
        if (_body.data["lockOnTargetId"] !== undefined)
        {
            _body.data["lockOnTargetId"] = null;
            this.pushObjectDataUpdate(_body.data.id, ["lockOnTargetId"]);
        }
        if (item["mag"] == 0)
        {
            this.reloadCharacterWeapon(_body);
        }
        if (item["id"] == "riot_shield")
        {
            var shield = this.createShield(_body.data["id"]);
            if (shield)
            {
                _body.data["shieldId"] = shield.data["id"];
            }
        }
        else
        {
            if (_body.data["shieldId"])
            {
                this.removeObjectById(_body.data["shieldId"]);
                delete _body.data["shieldId"];
            }
        }
    }

    getCharacterInventoryItemIndex(_body, _itemId)
    {
        var inventory = _body.data["inventory"];
        for (var i = 0; i < inventory.length; i++)
        {
            if (inventory[i]["id"] == _itemId)
            {
                return i;
            }
        }
        return -1;
    }

    onStartWeaponFire(_body)
    {
        var cur = this.getCurrentCharacterInventoryItem(_body);
        if (cur)
        {
            switch (cur.id)
            {
                case "flamethrower":
                case "minigun":
                    this.requestEvent({
                        eventId: GameServer.EVENT_PAWN_ACTION,
                        pawnId: _body.data["id"],
                        type: GameServer.PAWN_START_FLAME
                    });
                    _body.data.weapon.bStartFlame = true;
                    break;
            }
        }
    }

    onEndWeaponFire(_body)
    {
        var cur = this.getCurrentCharacterInventoryItem(_body);
        if (cur)
        {
            switch (cur.id)
            {
                case "flamethrower":
                case "minigun":
                    if (_body.data.weapon.bStartFlame)
                    {
                        this.requestEvent({
                            eventId: GameServer.EVENT_PAWN_ACTION,
                            pawnId: _body.data["id"],
                            type: GameServer.PAWN_END_FLAME
                        });
                        delete _body.data.weapon.bStartFlame;
                    }
                    break;
            }
        }
    }

    reloadCharacterWeapon(_body, _bManual)
    {
        if (this.characterCanReload(_body))
        {
            _body.data["reloadTimer"] = _body.data["reloadTimerMax"];
            _body.data["bIsReloading"] = true;
            this.requestEvent({
                eventId: GameServer.EVENT_PAWN_ACTION,
                pawnId: _body.data["id"],
                type: GameServer.PAWN_RELOAD,
                bManual: _bManual
            });            
        }
    }

    dropCharacterEquipment(_body)
    {
        if (!this.localData["bDroppedWeapons"])
        {
            return;
        }
        var rad = _body.data["aimRotation"];
        if (_body.data["scale"] == -1)
        {
            rad += this.ToRad(-180);
        }
        var equipment = _body.data.equipment;
        if (equipment && equipment.ammo > 0)
        {
            var force = this.Random(100, 150);
            var vx = (Math.cos(_body.data["aimRotation"]) * force);
            var vy = (Math.sin(_body.data["aimRotation"]) * force);
            this.createDroppedWeapon(
                this.getRandomUniqueId(),
                [_body.position[0], _body.position[1] - 30],
                rad,
                _body.data["scale"],
                {
                    weaponData: this.clone(equipment)
                },
                [vx, vy],
                this.Random(0, 5)
            );
        }
    }

    dropAllCharacterWeapons(_body)
    {
        if (!this.localData["bDroppedWeapons"])
        {
            return;
        }
        this.dropCharacterEquipment(_body);
        var rad = _body.data["aimRotation"];
        if (_body.data["scale"] == -1)
        {
            rad += this.ToRad(-180);
        }
        var inventory = _body.data.inventory;
        for (var i = 0; i < inventory.length; i++)
        {
            var weaponData = inventory[i];
            if (weaponData["bZombie"] || weaponData["id"] == "none")
            {
                continue;
            }
            var force = this.Random(100, 150);
            var vx = (Math.cos(_body.data["aimRotation"]) * force);
            var vy = (Math.sin(_body.data["aimRotation"]) * force);
            this.createDroppedWeapon(
                this.getRandomUniqueId(),
                [_body.position[0], _body.position[1] - 30],
                rad + this.ToRad(i * 30),
                _body.data["scale"],
                {
                    weaponData: weaponData
                },
                [vx, vy],
                this.Random(0, 5)
            );
        }        
    }

    dropCharacterWeapon(_body, _index)
    {
        if (this.localData.gameModeData["id"] == GameMode.GUN_GAME || this.localData.gameModeData["id"] == GameMode.INFECTED)
        {
            return;
        }
        if (!this.localData["bDroppedWeapons"])
        {
            return;
        }
        var rad = _body.data["aimRotation"];
        if (_body.data["scale"] == -1)
        {
            rad += this.ToRad(-180);
        }
        var weaponData = _body.data.inventory[_index];
        if (weaponData["bZombie"] || weaponData["id"] == "none")
        {
            return;
        }
        var force = this.Random(120, 150);
        var vx = (Math.cos(_body.data["aimRotation"]) * force);
        var vy = (Math.sin(_body.data["aimRotation"]) * force);
        this.createDroppedWeapon(
            this.getRandomUniqueId(),
            [_body.position[0], _body.position[1] - 30],
            rad,
            _body.data["scale"],
            {
                weaponData: weaponData
            },
            [vx, vy],
            this.Random(0, 5)
        );
    }

    getCharacterHealth()
    {
        if (this.isHardcore())
        {
            return 100;
        }
        return 200;
    }

    isHardcore()
    {
        return this.localData.gameModeData["bHardcore"];
    }

    updateCharacterPerks(_body)
    {
        var perks = _body.data["perks"];
        if (!perks)
        {
            console.warn("Invalid perk reference");
            return;
        }
        var data = _body.data;
        //Reset to defaults
        data["maxSpeed"] = 200;
        data["maxHealth"] = this.getCharacterHealth();
        data["health"] = Math.min(data["health"], data["maxHealth"]);
        data["regenTimerMax"] = this.localData.settings.fps * 3;
        data["regenAmount"] = 1;
        data["unTargetable"] = false;
        data["aimSpeedMultiplier"] = 1;
        data["accuracyMultiplier"] = 1;
        data["reloadMultiplier"] = 1;
        var item = this.getCurrentCharacterInventoryItem(_body);
        data["reloadTimerMax"] = Math.round(Math.ceil(item["reloadTime"] * this.localData.settings.fps) / data["reloadMultiplier"]);

        var params = [
            "maxSpeed",
            "maxHealth",
            "health",
            "regenAmount",
            "unTargetable",
            "aimSpeedMultiplier",
            "accuracyMultiplier",
            "reloadMultiplier",
            "reloadTimerMax"
        ];
        for (var i = 0; i < perks.length; i++)
        {
            switch (perks[i])
            {
                case Perks.PERK_PLAYER_LIGHTWEIGHT:
                    data["maxSpeed"] = 230;
                    break;

                case Perks.PERK_PLAYER_JUGGERNAUT:
                    if (this.localData["bSurvival"])
                    {
                        data["maxHealth"] = this.getCharacterHealth() * 3;
                    }
                    else
                    {
                        var ps = this.getPlayerStateById(data["id"]);
                        data["maxHealth"] = this.getCharacterHealth() * 1.5;
                        if (ps)
                        {
                            if (ps["bInfected"])
                            {
                                //data["maxHealth"] = this.getCharacterHealth() * 2;
                            }
                            else if (ps["bJuggernaut"])
                            {
                                data["bNoPickups"] = true;
                                data["maxHealth"] = this.getCharacterHealth() * 5;
                                data.damageMultipliers[DamageType.DAMAGE_BULLET] = 0.25;
                                data["maxSpeed"] = 160;
                                params.push("bNoPickups");
                            }
                            else if (ps["bVIP"])
                            {
                                data["bNoPickups"] = true;
                                data["maxHealth"] = this.getCharacterHealth() * 2;
                                data.damageMultipliers[DamageType.DAMAGE_EXPLOSIVE] = 0.5;
                                params.push("bNoPickups");
                            }
                        }
                    }
                    data["health"] = data["maxHealth"];
                    break;

                case Perks.PERK_PLAYER_SPECIALIST:
                    data["regenAmount"] = 5;
                    data["regenTimerMax"] = this.localData.settings.fps * 2;
                    break;

                case Perks.PERK_PLAYER_COLD_BLOODED:
                    data["unTargetable"] = true;
                    break;

                case Perks.PERK_WEAPON_AMMO:
                    if (!data["bBandolier"] || !this.matchInProgress())
                    {
                        data["bBandolier"] = true;
                        var inventory = data.inventory;
                        for (var j = 0; j < inventory.length; j++)
                        {
                            var curInvItem = inventory[j];
                            if (!curInvItem["bMelee"])
                            {
                                var defaultData = this.getWeaponData(curInvItem["id"]);
                                curInvItem["ammo"] = Math.min(curInvItem["ammo"] + defaultData["ammo"], 999);
                            }
                        }
                        if (data.equipment)
                        {
                            data.equipment["ammo"] = Math.min(data.equipment["ammo"] + 1, data.equipment["ammoMax"]);
                        }
                        this.requestEvent({
                            eventId: GameServer.EVENT_PLAYER_UPDATE_INVENTORY,
                            pawnId: data.id,
                            type: GameServer.INV_INVENTORY
                        });
                        this.requestEvent({
                            eventId: GameServer.EVENT_PLAYER_UPDATE_INVENTORY,
                            pawnId: data.id,
                            type: GameServer.INV_EQUIPMENT
                        });
                    }
                    break;

                case Perks.PERK_WEAPON_QUICKDRAW:
                    data["aimSpeedMultiplier"] = 2;
                    break;

                case Perks.PERK_WEAPON_ACCURACY:
                    data["accuracyMultiplier"] = 0.6;
                    break;

                case Perks.PERK_WEAPON_RELOAD:
                    data["reloadMultiplier"] = this.getSharedData("perks")["fastReloadMultiplier"]; //1.5;
                    var item = this.getCurrentCharacterInventoryItem(_body);
                    data["reloadTimerMax"] = Math.round(Math.ceil(item["reloadTime"] * this.localData.settings.fps) / _body.data["reloadMultiplier"]);
                    break;
            }
        }
        this.pushObjectDataUpdate(data.id, params);
    }

    pushObjectDataUpdate(_id, _keys)
    {
        var obj = this.getObjectById(_id);
        if (obj)
        {
            var localData = this.localData;
            var objectsToUpdate = localData["objectsToUpdate"];
            var arr = objectsToUpdate ? objectsToUpdate[_id] : null;
            var curItem = arr ? arr[arr.length - 1] : null;
            var newData = {};
            for (var i = 0; i < _keys.length; i++)
            {
                var key = _keys[i];
                newData[key] = obj.data[key];
                if (curItem)
                {
                    //curItem.data[key] = obj.data[key];
                }
            }
            this.onEvent({
                eventId: GameServer.EVENT_OBJECT_UPDATE,
                object: {
                    id: _id,
                    data: newData
                }
            });
        }
    }

    pullCharacterBolt(_body)
    {
        _body.data.weapon["bBoltDelay"] = true;
        var item = this.getCurrentCharacterInventoryItem(_body);
        _body.data.weapon["boltDelayTimer"] = item["boltDelayTimer"] * this.localData.settings.fps;
        this.requestEvent({
            eventId: GameServer.EVENT_PAWN_ACTION,
            pawnId: _body.data["id"],
            type: GameServer.PAWN_PULL_BOLT
        });
    }

    cancelCharacterReload(_body)
    {
        if (_body.data["bIsReloading"])
        {
            this.requestEvent({
                eventId: GameServer.EVENT_PAWN_ACTION,
                pawnId: _body.data["id"],
                type: GameServer.PAWN_CANCEL_RELOAD
            });
        }
        _body.data["bIsReloading"] = false;
    }

    cancelCharacterBoltPull(_body)
    {
        if (_body.data.weapon["bBoltDelay"])
        {
            this.requestEvent({
                eventId: GameServer.EVENT_PAWN_ACTION,
                pawnId: _body.data["id"],
                type: GameServer.PAWN_CANCEL_BOLT_PULL
            });
        }
        _body.data.weapon["bBoltDelay"] = false;
    }

    characterHasAllSurvivalPerks(_body)
    {
        if (!_body)
        {
            return false;
        }
        var data = _body.data;
        if (data["perks"])
        {
            return data["perks"].length >= this.getSurvivalPerks().length;
        }
        return false;
    }

    getRandomSurvivalPerk()
    {
        var perks = this.getSurvivalPerks();
        return perks[this.Random(0, perks.length - 1)];
    }

    getRandomPerk()
    {
        var perks = this.getAllPerks();
        return perks[this.Random(0, perks.length - 1)];
    }

    getAllPerks()
    {
        var perks = this.getSurvivalPerks();
        perks.push(Perks.PERK_PLAYER_MARTYRDOM, Perks.PERK_WEAPON_SHRAPNEL, Perks.PERK_WEAPON_RECON, Perks.PERK_PLAYER_SCAVENGER, Perks.PERK_PLAYER_SITREP, Perks.PERK_PLAYER_ANTI_SNIPER, Perks.PERK_PLAYER_COLD_BLOODED);
        return perks;
    }

    getSurvivalPerks()
    {
        return [
            Perks.PERK_PLAYER_SITREP,
            Perks.PERK_PLAYER_NINJA,
            Perks.PERK_PLAYER_LIGHTWEIGHT,
            Perks.PERK_PLAYER_JUGGERNAUT,
            Perks.PERK_PLAYER_SPECIALIST,
            Perks.PERK_PLAYER_HELMET,
            Perks.PERK_WEAPON_QUICKDRAW,
            Perks.PERK_WEAPON_ACCURACY,
            Perks.PERK_WEAPON_AGGRESSION,
            Perks.PERK_WEAPON_RELOAD,
            Perks.PERK_WEAPON_STOPPING_POWER,
            Perks.PERK_WEAPON_VAMPIRE,
            Perks.PERK_PLAYER_SCAVENGER,
            Perks.PERK_PLAYER_HELMET
        ];
    }

    characterHasPerk(_body, _perkId)
    {
        if (!_body)
        {
            return false;
        }
        var data = _body.data;
        if (data["perks"])
        {
            return data["perks"].indexOf(_perkId) >= 0;
        }
        return false;
    }

    characterHasWeaponDelay(_body)
    {
        var weapon = _body.data["weapon"];
        return weapon.bFireDelay || weapon.bMeleeDelay || weapon.bThrowDelay || weapon.bEquipmentDelay || weapon.bUseDelay;
    }

    characterCanCrouch(_body)
    {
        var data = _body.data;
        if (data["bBot"] && data["bLadderCooldown"])
        {
            return false;
        }
        return !data["bIsOnLadder"];
    }

    characterCanSprint(_body)
    {
        var data = _body.data;
        return !data["bWantsToCrouch"] && !data["bIsOnLadder"] && data["bWantsToMove"] && !data["bStunned"] && !data["bFlashed"] && data["bOnGround"];
    }

    characterCanClimb(_body)
    {
        var data = _body.data;
        if (!data["bBot"] && data["bLadderCooldown"])
        {
            return false;
        }
        return !data["bUseDelay"] && !data["bEquipmentDelay"] && !data["bWantsToCrouch"];
    }

    characterCanJump(_body)
    {
        var data = _body.data;
        var ps = this.getPlayerStateById(data["id"]);
        if (ps && ps["controllableId"])
        {
            return false;
        }
        if (data["bIsOnLadder"])
        {
            return true;
        }
        var bOnGround = this.isOnGround(_body);
        return this.characterCanMove(_body) && !data["bStunned"] && !data["bFlashed"] && !data["bLadderCooldown"] && bOnGround;
    }

    characterCanMelee(_body)
    {
        var data = _body.data;
        var ps = this.getPlayerStateById(data["id"]);
        if (ps && ps["controllableId"])
        {
            return false;
        }
        if (data["bShieldCooldown"])
        {
            return false;
        }
        var item = this.getCurrentCharacterInventoryItem(_body);
        var bWeaponCanMelee = this.isMeleeWeapon(item) ? item["bCanMelee"] : true;
        return !data["bWantsToInteract"] && !data["bIsOnLadder"] && !this.characterHasWeaponDelay(_body) && bWeaponCanMelee;
    }

    characterIsFree(_body)
    {
        var data = _body.data;
        var ps = this.getPlayerStateById(data["id"]);
        if (ps && ps["controllableId"])
        {
            return false;
        }
        if (data["bShieldCooldown"])
        {
            return false;
        }
        return !data["bWantsToInteract"] && !data["bIsOnLadder"] && !this.characterHasWeaponDelay(_body) && !data.bIsReloading;
    }

    characterCanReload(_body)
    {
        var data = _body.data;
        var ps = this.getPlayerStateById(data["id"]);
        if (ps && ps["controllableId"])
        {
            return false;
        }
        var item = this.getCurrentCharacterInventoryItem(_body);
        if (item["bMelee"])
        {
            return false;
        }
        var weapon = data["weapon"];
        var bAmmoCheck = (item["mag"] < item["magSize"]) && (item["ammo"] > 0 || weapon.bUnlimitedAmmo);
        return !data["bShieldCooldown"] && !data["bWantsToInteract"] && !data.bIsOnLadder && item && !this.characterHasWeaponDelay(_body) && !data.bIsReloading && bAmmoCheck;
    }

    characterCanInteract(_body, _interactable)
    {
        var data = _body["data"];
        var ps = this.getPlayerStateById(data["id"]);
        if (ps && ps["controllableId"])
        {
            return false;
        }
        if (_interactable)
        {
            if (_interactable.data["interactTeam"] != undefined)
            {
                if (_interactable.data["interactTeam"] !== data["team"])
                {
                    return false;
                }
            }
            if (_interactable.data["bLimitInteractions"])
            {
                if (_interactable.data["currentPawnId"])
                {
                    return false;
                }
            }
        }
        var dist = this.Dist(_body.position[0], _body.position[1], _interactable.position[0], _interactable.position[1]);
        return !data["bIsOnLadder"] && !data["bWantsToInteract"] && dist < 200;
    }

    characterCanFire(_body, _bCheckMag = true)
    {
        if (!this.matchInProgress())
        {
            return false;
        }
        var ps = this.getPlayerStateById(_body.data["id"])
        if (ps && ps["controllableId"])
        {
            return false;
        }
        var item = this.getCurrentCharacterInventoryItem(_body);
        if (!item)
        {
            return false;
        }
        if (_bCheckMag)
        {
            var bHasMag = this.isMeleeWeapon(item) ? true : (item["mag"] > 0);
            if (!bHasMag)
            {
                return false;
            }
        }
        var data = _body.data;
        if (data["bIsOnLadder"])
        {
            return false;
        }
        if (item["bAirOnly"])
        {
            if (!data["lockOnTargetId"])
            {
                return false;
            }
        }
        var weapon = data["weapon"];
        return !data["bWantsToInteract"] && !data.bIsReloading && !this.characterHasWeaponDelay(_body) && !weapon.bBoltDelay && !data["bWantsToSprint"] && !data["bShieldCooldown"];
    }

    characterCanMove(_body)
    {
        var data = _body.data;
        var ps = this.getPlayerStateById(data["id"]);
        if (ps)
        {
            if (ps["controllableId"])
            {
                return false;
            }
        }
        return !data["bIsOnLadder"] && !data["bEquipmentDelay"] && !data["bWantsToInteract"];
    }

    characterCanUseEquipment(_body)
    {
        var data = _body.data;
        var equipment = data.equipment;
        if (!equipment)
        {
            return false;
        }
        else
        {
            var bGroundCheck = true;
            if ((equipment["bPlaceable"] || equipment["bMine"]) && !equipment["bThrowable"])
            {
                bGroundCheck = data["bOnGround"]; //this.isOnGround(_body);
                if (!bGroundCheck)
                {
                    return false;
                }
            }
        }
        var curItem = this.getCurrentCharacterInventoryItem(_body);
        if (curItem["id"] == "riot_shield" && !this.localData["bSurvival"])
        {
            return false;
        }
        if (!equipment["bSprintUse"] && data["bWantsToSprint"])
        {
            return false;
        }
        return !data["bWantsToInteract"] && !data.bIsOnLadder && !this.characterHasWeaponDelay(_body) && !data["bShieldCooldown"];
    }

    useCharacterEquipment(_body, _worldX, _worldY)
    {
        if (!this.characterCanUseEquipment(_body))
        {
            return;
        }       
        var data = _body.data;
        var equipment = data["equipment"];
        var bUse = true;
        var equipmentRot = data["desiredAimRotation"] ? data["desiredAimRotation"] : data["aimRotation"];
        switch (equipment["type"])
        {
            case Weapon.TYPE_GRENADE:
                data.weapon["bThrowDelay"] = true;
                data.weapon["throwDelayTimer"] = Math.round(this.localData.settings.fps * 0.4);
                var velocity = Math.min(1200, this.Dist(_worldX, _worldY, _body.position[0], _body.position[1]) * 2);
                var offset = 0; //60;
                var grenadeRad = data["bBot"] ? this.Angle(_body.position[0], _body.position[1], _worldX, _worldY) : equipmentRot;
                this.createGrenade([_body.position[0] + (Math.cos(grenadeRad) * offset), (_body.position[1] - 30) + (Math.sin(grenadeRad) * offset)], {
                    team: data["team"],
                    playerId: data["id"],
                    causerId: data["id"],
                    rotation: grenadeRad,
                    velocity: velocity,
                    damage: equipment["damage"],
                    weaponId: equipment["id"],
                    bStartDetonationAfterHit: equipment["bStartDetonationAfterHit"],
                    bImpact: equipment["bImpact"]
                });
                this.requestEvent({
                    eventId: GameServer.EVENT_PAWN_ACTION,
                    pawnId: data["id"],
                    type: GameServer.PAWN_THROW_GRENADE,
                    weaponId: equipment["id"]
                });
                break;

            default:
                switch (equipment["id"])
                {
                    case "molotov":
                        data.weapon["bThrowDelay"] = true;
                        data.weapon["throwDelayTimer"] = Math.round(this.localData.settings.fps * 0.4);
                        var velocity = Math.min(1200, this.Dist(_worldX, _worldY, _body.position[0], _body.position[1]) * 2);
                        var offset = 0; //60;
                        var grenadeRad = data["bBot"] ? this.Angle(_body.position[0], _body.position[1], _worldX, _worldY) : equipmentRot;
                        this.createGrenade([_body.position[0] + (Math.cos(grenadeRad) * offset), (_body.position[1] - 30) + (Math.sin(grenadeRad) * offset)], {
                            team: data["team"],
                            playerId: data["id"],
                            causerId: data["id"],
                            rotation: grenadeRad,
                            velocity: velocity,
                            damage: equipment["damage"],
                            weaponId: equipment["id"],
                            bStartDetonationAfterHit: equipment["bStartDetonationAfterHit"],
                            bImpact: equipment["bImpact"]
                        });
                        this.requestEvent({
                            eventId: GameServer.EVENT_PAWN_ACTION,
                            pawnId: data["id"],
                            type: GameServer.PAWN_THROW_GRENADE,
                            weaponId: equipment["id"]
                        });
                        break;

                    case "c4":
                        var curC4s = this.getGrenades(data["id"], "c4");
                        if (curC4s.length >= 4)
                        {
                            this.removeNextStep(curC4s[0]);
                        }
                        data.weapon["bThrowDelay"] = true;
                        data.weapon["throwDelayTimer"] = Math.round(this.localData.settings.fps * 0.3);
                        var velocity = Math.min(600, this.Dist(_worldX, _worldY, _body.position[0], _body.position[1]) * 2);
                        var offset = 0; //60;
                        this.createGrenade([_body.position[0] + (Math.cos(equipmentRot) * offset), (_body.position[1] - 30) + (Math.sin(equipmentRot) * offset)], {
                            team: data["team"],
                            playerId: data["id"],
                            causerId: data["id"],
                            rotation: equipmentRot,
                            velocity: velocity,
                            damage: equipment["damage"],
                            weaponId: equipment["id"]
                        });
                        this.requestEvent({
                            eventId: GameServer.EVENT_PAWN_ACTION,
                            pawnId: data["id"],
                            type: GameServer.PAWN_THROW_GRENADE,
                            weaponId: equipment["id"]
                        });
                        break;

                    case "stim":
                        if (data["health"] >= data["maxHealth"])
                        {
                            bUse = false;
                            var ally = this.getNearestFriendlyPawn(_body, { maxRange: 100, bInjured: true, pawnTypes: ["character"] });
                            if (ally)
                            {
                                bUse = true;
                                var allyData = ally.data;
                                allyData["health"] = allyData["maxHealth"];
                                this.pushObjectDataUpdate(allyData.id, ["health"]);
                                data.weapon["bThrowDelay"] = true;
                                data.weapon["throwDelayTimer"] = Math.round(this.localData.settings.fps * 0.5);
                                this.requestEvent({
                                    eventId: GameServer.EVENT_PAWN_ACTION,
                                    pawnId: data["id"],
                                    type: GameServer.PAWN_USE_STIM,
                                    bAlly: true
                                });
                                this.requestEvent({
                                    eventId: GameServer.EVENT_PAWN_ACTION,
                                    pawnId: allyData["id"],
                                    type: GameServer.PAWN_RECEIVE_STIM
                                });
                            }
                        }
                        else
                        {
                            data["health"] = data["maxHealth"];
                            this.pushObjectDataUpdate(data.id, ["health"]);
                            data.weapon["bThrowDelay"] = true;
                            data.weapon["throwDelayTimer"] = Math.round(this.localData.settings.fps * 0.5);
                            this.requestEvent({
                                eventId: GameServer.EVENT_PAWN_ACTION,
                                pawnId: data["id"],
                                type: GameServer.PAWN_USE_STIM
                            });
                        }
                        break;

                    case "knife":
                        data.weapon["bThrowDelay"] = true;
                        data.weapon["throwDelayTimer"] = Math.round(this.localData.settings.fps * 0.5);
                        var velocity = 160; //180;
                        var offset = 0; //40;
                        this.createProjectile([_body.position[0] + (Math.cos(equipmentRot) * offset), (_body.position[1] - 30) + (Math.sin(equipmentRot) * offset)], equipmentRot, data["team"], {
                            playerId: data["id"],
                            causerId: data["id"],
                            rotation: equipmentRot,
                            velocity: velocity,
                            damage: equipment["damage"],
                            weaponId: equipment["id"]
                        });
                        this.requestEvent({
                            eventId: GameServer.EVENT_PAWN_ACTION,
                            pawnId: data["id"],
                            type: GameServer.PAWN_THROW_GRENADE,
                            weaponId: equipment["id"]
                        });
                        break;

                    case "deployable_cover":
                        data.weapon["bEquipmentDelay"] = true;
                        data.weapon["equipmentDelayTimer"] = Math.round(this.localData.settings.fps * 0.3);
                        this.createDeployableCover(this.getRandomUniqueId(), [_body.position[0], _body.position[1] + 10], data["id"]);
                        this.requestEvent({
                            eventId: GameServer.EVENT_PAWN_ACTION,
                            pawnId: data["id"],
                            type: GameServer.PAWN_PLACE_EQUIPMENT,
                            equipmentId: equipment["id"]
                        });
                        break;

                    default:
                        if (equipment["id"] == "tac_insert")
                        {
                            this.removeEquipmentByPlayerId(data["id"], "tac_insert");
                        }
                        if (equipment["bPassive"])
                        {
                            bUse = false;
                        }
                        else if (equipment["bThrowable"])
                        {
                            data.weapon["bThrowDelay"] = true;
                            data.weapon["throwDelayTimer"] = Math.round(this.localData.settings.fps * 0.3);
                            var throwable = this.createEquipment([_body.position[0], _body.position[1] - 30], data["team"], data["scale"], data["id"], equipment);
                            if (throwable)
                            {
                                var force = Math.min(400, this.Dist(_worldX, _worldY, _body.position[0], _body.position[1]) * 2);
                                var rad = equipmentRot;
                                throwable.applyImpulse([Math.cos(rad) * force, Math.sin(rad) * force], 0, 0);
                            }
                            this.requestEvent({
                                eventId: GameServer.EVENT_PAWN_ACTION,
                                pawnId: data["id"],
                                type: GameServer.PAWN_THROW_GRENADE,
                                equipmentId: equipment["id"]
                            });
                        }
                        else
                        {
                            data.weapon["bEquipmentDelay"] = true;
                            data.weapon["equipmentDelayTimer"] = Math.round(this.localData.settings.fps * 0.3);
                            var placeablePos = [_body.position[0] + 10, _body.position[1] + 20];
                            if (equipment["id"] == "claymore")
                            {
                                placeablePos[0] += 30 * data["scale"];
                            }
                            this.createEquipment(placeablePos, data["team"], data["scale"], data["id"], equipment);
                            this.requestEvent({
                                eventId: GameServer.EVENT_PAWN_ACTION,
                                pawnId: data["id"],
                                type: GameServer.PAWN_PLACE_EQUIPMENT,
                                equipmentId: equipment["id"]
                            });
                        }
                        break;
                }
                break;
        }
        if (!bUse)
        {
            return;
        }
        this.cancelCharacterReload(_body);
        this.cancelCharacterBoltPull(_body);
        equipment["ammo"]--;
        this.requestEvent({
            eventId: GameServer.EVENT_PLAYER_UPDATE_INVENTORY,
            pawnId: data["id"],
            type: GameServer.INV_EQUIPMENT,
            equipment: equipment
        });
    }

    useCharacterMeleeAttack(_body)
    {
        if (this.characterCanMelee(_body))
        {
            this.cancelCharacterReload(_body);
            this.cancelCharacterBoltPull(_body);
            var data = _body.data;
            data.weapon["bMeleeDelay"] = true;
            data.weapon["meleeDelayTimer"] = Math.round(this.characterHasPerk(_body, Perks.PERK_PLAYER_NINJA) ? 10 : 20) * this.localData.settings.fps_mult;
            var damage = 100; //Melee damage
            if (!this.localData["bModeGame"] && _body.data["team"] === 1)
            {
                damage = 50;
            }
            var perks = _body.data["perks"];
            if (perks)
            {
                for (var i = 0; i < perks.length; i++)
                {
                    if (perks[i] == Perks.PERK_WEAPON_AGGRESSION)
                    {
                        damage = 300;
                        break;
                    }
                }
            }
            this.createBullet(_body.position[0], _body.position[1] - 10, data["aimRotation"], 50, damage, data["id"], data["id"], "none", null, true, true, true);
            this.requestEvent({
                eventId: GameServer.EVENT_PAWN_ACTION,
                pawnId: data["id"],
                type: GameServer.PAWN_MELEE_ATTACK
            });
        }
    }

    getCharacterMuzzlePosition(_body)
    {
        if (_body)
        {
            var data = _body["data"];
            var rad = data["aimRotation"];
            var armsWidth = 5;
            if (_body.data["bBot"] && this.localData["bOperation"])
            {
                armsWidth = 10;
            }
            var pos = _body.position;
            if (_body.data.clientPos)
            {
                pos = _body.data.clientPos;
            }
            var muzzlePos = [
                pos[0] + (Math.cos(rad) * armsWidth),
                ((pos[1] - 25) + (data["bWantsToCrouch"] ? 10 : 0)) + (Math.sin(rad) * armsWidth)
            ];
            return muzzlePos;
        }
        return null;
    }

    fireCharacterWeapon(_body)
    {
        var data = _body.data;
        var weapon = data.inventory[data["currentInventoryIndex"]];        
        var rad = data["aimRotation"];
        var bSilenced = this.hasMod(weapon, Mods.BARREL_SILENCER);
        var muzzlePos = this.getCharacterMuzzlePosition(_body);
        var bMelee = this.isMeleeWeapon(weapon);
        var numBullets = 1;
        if (weapon["type"] == Weapon.TYPE_SHOTGUN && !weapon["bSlug"])
        {
            numBullets = 6;
        }        
        for (var i = 0; i < numBullets; i++)
        {
            var useAccuracy = (weapon["accuracy"] * data["accuracyMultiplier"] * (data["bWantsToCrouch"] && weapon.type != Weapon.TYPE_SHOTGUN ? 0.8 : 1)) * 10;
            var bulletRad = rad + this.ToRad(this.Random(-useAccuracy, useAccuracy) * 0.1);
            bulletRad += this.ToRad(data.weapon.recoil);
            if (weapon["bRocket"])
            {
                var rocketData = {
                    type: weapon["rocketType"] ? weapon["rocketType"] : Rocket.TYPE_DEFAULT,
                    team: data["team"],
                    playerId: data["id"],
                    causerId: data["id"],
                    rotation: bulletRad,
                    weaponId: weapon["id"],
                    damage: weapon["damage"],
                    radius: weapon["radius"],
                    bAirOnly: weapon["bAirOnly"]                    
                };
                if (weapon.fireDamage)
                {
                    rocketData.weaponData = weapon;
                }
                if (weapon["id"] == "javelin")
                {
                    var lookPos = [
                        _body.data["lookPos"][0],
                        Math.max(_body.data["lookPos"][1], 500)
                    ];
                    rocketData["path"] = [
                        [_body.position[0] + (_body.data["scale"] * 100), 0],
                        [lookPos[0] + (-_body.data["scale"] * 100), 0],
                        [lookPos[0] + (-_body.data["scale"] * 100), 500],
                        [lookPos[0], lookPos[1]]
                    ];
                    if (weapon["bAirOnly"])
                    {
                        rocketData["path"].pop();
                    }
                }
                this.createRocket(muzzlePos, rocketData);
            }
            else if (weapon["bGrenade"])
            {
                var velocity = weapon["velocity"] ? weapon["velocity"] : 1500;
                this.createGrenade(muzzlePos, {
                    bImpact: true,
                    team: data["team"],
                    playerId: data["id"],
                    causerId: data["id"],
                    rotation: bulletRad,
                    velocity: velocity,
                    damage: weapon["damage"],
                    weaponId: weapon["id"],
                    radius: weapon["radius"]
                }, true);
            }
            else if (weapon["bProjectile"])
            {
                var velocity = 120;
                var offset = 60;
                this.createProjectile([_body.position[0] + (Math.cos(bulletRad) * offset), (_body.position[1] - 30) + (Math.sin(bulletRad) * offset)], bulletRad, data["team"], {
                    playerId: data["id"],
                    causerId: data["id"],
                    rotation: bulletRad,
                    velocity: velocity,
                    damage: weapon["damage"],
                    weaponId: weapon["id"]
                });
            }
            else if (weapon["bExploder"])
            {
                this.requestEvent({
                    eventId: GameServer.EVENT_PAWN_DAMAGE,
                    damageType: DamageType.DAMAGE_MELEE,
                    damageAmount: data["health"],
                    pawnId: data["id"],
                    attackerId: data["id"],
                    causerId: data["id"],
                    weaponId: weapon["id"],
                    bDirectlyCausedByPlayer: true
                });
            }
            else if (weapon["bFlame"])
            {
                var flameVel = weapon.velocity ? weapon.velocity : 2000;
                var flameSpeed = this.Random(flameVel, flameVel + 200);
                var flame = this.createFlame(muzzlePos, [Math.cos(bulletRad) * flameSpeed, Math.sin(bulletRad) * flameSpeed], data.team, data.id, weapon.id, weapon, weapon["fireTime"], true);
                flame.data.ticker = Math.round(4 * this.localData.settings.fps_mult);
            }
            else if (weapon.id == "crossbow")
            {
                var damage = weapon.damage;
                if (this.localData.bSurvival)
                {
                    damage *= 5;
                }
                this.createProjectile(muzzlePos, bulletRad, data["team"], {
                    playerId: data["id"],
                    causerId: data["id"],
                    rotation: bulletRad,
                    velocity: 200,
                    damage: damage,
                    weaponId: weapon["id"],
                    frameId: "arrow"
                });
            }
            else
            {
                var useDamage = weapon["damage"];
                if (bMelee && this.characterHasPerk(_body, Perks.PERK_WEAPON_AGGRESSION) && weapon["id"] != "riot_shield")
                {
                    useDamage *= 2;
                }
                if (weapon["bJumpRecoil"] && !data["bOnGround"])
                {
                    var recoil = weapon["recoil"] * (data["bWantsToCrouch"] ? 0.25 : 0.5);
                    bulletRad += this.ToRad(this.Random(-recoil, recoil));
                }
                var bIgnoreObstacles = (this.localData["bSurvival"] && data["team"] == 0) || bMelee;
                this.createBullet(muzzlePos[0], muzzlePos[1], bulletRad, weapon["range"], useDamage, data["id"], data["id"], weapon["id"], weapon, true, bMelee, bIgnoreObstacles);
            }
        }
        if (_body.data.type == "character")
        {
            if (_body.data.avatarData && _body.data.avatarData.body == "c4_vest")
            {
                this.killPawn(_body.data.id);
            }
        }
        //Post-recoil
        if (!weapon["bBoltAction"])
        {           
            var recoilMax = 2;
            var rand = this.Random(1, recoilMax);
            var scaleVal = data["scale"] == 1 ? -1 : 1;
            var recoilMult = (data["bWantsToCrouch"] ? 0.5 : 1) * (data["bADS"] ? 0.5 : 1);
            var recoilVal = weapon["recoil"] + (Math.abs(data.weapon["recoil"]) * 0.1);
            data.weapon["recoil"] += -(recoilVal * recoilMult) * (rand == 1 ? scaleVal : -scaleVal);          
        }
        var bExpose = data["bUseExposeTimer"] && !bSilenced && !bMelee && weapon.id != "crossbow";
        if (bExpose)
        {
            this.emitAISound(this.clone(_body.position), data["team"]);
            data["bExposed"] = true;
            data["exposedTimer"] = this.localData.settings.fps * 2;
        }

        if (weapon["type"] == Weapon.TYPE_MELEE)
        {
            this.requestEvent({
                eventId: GameServer.EVENT_PAWN_ACTION,
                pawnId: data["id"],
                type: GameServer.PAWN_FIRE_MELEE,
                recoil: weapon["recoil"]
            });
        }
        else
        {
            this.requestEvent({
                eventId: GameServer.EVENT_PLAYER_UPDATE_INVENTORY,
                pawnId: data["id"],
                index: data["currentInventoryIndex"],
                type: GameServer.INV_FIRE
            });
            this.requestEvent({
                eventId: GameServer.EVENT_PAWN_ACTION,
                pawnId: data["id"],
                type: GameServer.PAWN_FIRE_WEAPON,
                recoil: weapon["recoil"]
            });
        }
    }

    handleAICharacter(_body)
    {
        var data = _body.data;
        var ai = data["ai"];
        if (ai["bDisabled"])
        {
            return;
        }
        if (data["health"] > 0)
        {
            if (ai["ticker"] > 0)
            {
                ai["ticker"]--;
            }
            else
            {
                var tickerMax = this.localData.settings.fps;
                if (this.localData["bSurvival"])
                {
                    tickerMax = this.localData.settings.fps * (ai["botSkill"] >= BotSkill.SKILL_INSANE ? 1 : 2);
                }
                else if (this.localData["bBattlezone"])
                {
                    tickerMax = this.localData.settings.fps * 0.5;
                }
                else if (this.localData["bOperation"])
                {
                    tickerMax = this.localData.settings.fps;
                }
                else
                {
                    switch (ai["botSkill"])
                    {
                        case BotSkill.SKILL_GOD:
                        case BotSkill.SKILL_INSANE:
                            tickerMax = this.localData.settings.fps * (this.localData.bMultiplayer ? 0.5 : 1);
                            break;
                        default:
                            tickerMax = this.localData.settings.fps;
                            break;
                    }
                }
                switch (ai.botSkill)
                {
                    case BotSkill.SKILL_GOD:
                        ai.enemyDistMax = 1500;
                        ai.offsetX = this.Random(-15, 15);
                        ai.offsetY = this.Random(-15, 15);
                        break;
                    case BotSkill.SKILL_INSANE:
                        ai.enemyDistMax = 600;
                        ai.offsetX = this.Random(-40, 40);
                        ai.offsetY = this.Random(-40, 40);
                        break;
                    case BotSkill.SKILL_HARD:
                        ai.enemyDistMax = 500;
                        ai.offsetX = this.Random(-50, 50);
                        ai.offsetY = this.Random(-50, 50);
                        break;
                    case BotSkill.SKILL_NORMAL:
                        ai.enemyDistMax = 400;
                        ai.offsetX = this.Random(-60, 60);
                        ai.offsetY = this.Random(-60, 60);
                        break;
                    default:
                        ai.enemyDistMax = 300;
                        ai.offsetX = this.Random(-70, 70);
                        ai.offsetY = this.Random(-70, 70);
                        break;
                }
                ai["tickerMax"] = Math.ceil(tickerMax);
                ai["ticker"] = ai["tickerMax"];
            }
            if (ai["bUseActivityTimer"])
            {
                if (ai["activityTimer"] > 0)
                {
                    ai["activityTimer"]--;
                    if (ai["campPosition"])
                    {
                        var campDist = this.Dist(_body.position[0], _body.position[1], ai["campPosition"][0], ai["campPosition"][1]);
                        if (campDist < 200)
                        {
                            ai["activityTimer"]--;
                        }
                    }
                    else
                    {
                        ai["activityTimer"]--;
                    }
                }
                else
                {
                    ai["activityTimer"] = this.localData.settings.fps * 30;
                    ai["bCamp"] = false;
                    delete ai["campPosition"];
                    if (this.localData["bBattlezone"] && this.RandomBoolean())
                    {
                        ai["bPatrol"] = true;
                    }
                    if (data["bVIP"] || (ai["bCanCamp"] && !ai["bObjectiveTakesPriority"]))
                    {
                        var campChance = data["bVIP"] ? 1 : this.Random(1, 3 + ai["botSkill"]);
                        var bShouldCamp = true;
                        if (this.localData.gameModeData["id"] == GameMode.CAPTURE_THE_FLAG)
                        {
                            bShouldCamp = !data["bHasFlag"];
                        }
                        else if (this.localData.gameModeData.id == GameMode.INFECTED && data.team == 1)
                        {
                            bShouldCamp = false;
                        }
                        if (campChance == 1 && !data["bIsCapturingFlag"] && bShouldCamp && !this.isGuidingHostage(_body))
                        {
                            var map = this.getCurrentMapData();
                            var campSpots = map.campSpots;
                            if (campSpots)
                            {
                                campSpots = this.clone(campSpots);
                                campSpots.sort((a, b) =>
                                {
                                    //TODO: Sort by distance
                                    var distA = this.Dist(a[0], a[1], _body.position[0], _body.position[1]);
                                    var distB = this.Dist(b[0], b[1], _body.position[0], _body.position[1]);
                                    if (distA < distB) return -1;
                                    if (distA > distB) return 1;
                                    return 0;
                                });
                                campSpots.length = Math.min(campSpots.length, 3);
                                ai["campPosition"] = campSpots[this.Random(0, campSpots.length - 1)];
                                ai["bCamp"] = true;
                            }
                        }
                    }
                }
            }
            data["bWantsToCrouch"] = false;
            if (data["bFlashed"] || data["bStunned"])
            {
                data["bWantsToFire"] = false;
                data["bWantsToCrouch"] = false;
            }
            else
            {
                var startLOSPos = this.getLOSStartPos(_body);
                if (ai["currentEnemy"])
                {
                    var enemyPawn = this.getObjectById(ai["currentEnemy"]);
                    if (!enemyPawn || !enemyPawn.data || !enemyPawn.data["health"])
                    {
                        delete ai["currentEnemy"];
                        delete ai["bEnemyWithinRange"];
                        ai["ticker"] = 0;
                    }
                    else
                    {
                        var losTicker = Math.min(ai["tickerMax"], (this.localData["bSurvival"] || ai.botSkill <= BotSkill.SKILL_HARD ? this.localData.settings.fps : Math.round(this.localData.settings.fps * 0.5)));
                        if (ai["ticker"] % losTicker == 0)
                        {
                            var bPrev = ai["bHasEnemyLOS"];
                            var losPos = ai.skillLevel >= BotSkill.SKILL_HARD ? [enemyPawn.position[0], enemyPawn.position[1] - 20] : enemyPawn.position;
                            ai["bHasEnemyLOS"] = this.checkLineOfSight(startLOSPos, losPos, true, enemyPawn);
                            if (bPrev && !ai["bHasEnemyLOS"] && ai["botSkill"] >= BotSkill.SKILL_INSANE && !_body.data["bZombie"])
                            {
                                this.triggerCharacterJump(_body);
                            }
                        }
                    }
                    if (ai["bLOS"] && enemyPawn)
                    {
                        var distToEnemy = this.Dist(_body.position[0], _body.position[1], enemyPawn.position[0], enemyPawn.position[1]);
                        if (!ai["bHasEnemyLOS"] || distToEnemy > ai["maxRange"])
                        {
                            //console.log("Just lost!", enemyPawn.data.id);
                            if (this.localData.bOperation)
                            {
                                this.emitAISound(enemyPawn.position, enemyPawn.data["team"], null, 9);
                            }
                            delete ai["currentEnemy"];
                            delete ai["bEnemyWithinRange"];
                            ai["investigatePriority"] = 9;
                            ai["investigatePos"] = this.clone(enemyPawn.position);
                            ai["ticker"] = 0;
                        }
                    }
                    if (ai["currentEnemy"] && ai["investigatePos"])
                    {
                        delete ai["investigatePriority"];
                        delete ai["investigatePos"];
                    }
                }
                if (ai["ticker"] == 0)
                {
                    if (data.bHostage)
                    {
                        if (ai.followId)
                        {
                            var follow = this.getObjectById(ai.followId);
                            if (!follow)
                            {
                                ai.followId = null;
                            }
                            else if (this.Dist(follow.position[0], follow.position[1], _body.position[0], _body.position[1]) > 500)
                            {
                                ai.followId = null;
                            }
                        }
                        if (!ai.followId)
                        {
                            var rescuerTeam = this.localData.gameModeData.id == GameMode.RESCUE ? this.localData.gameModeData.rescueTeam : 0;
                            var pawns = this.getPawns();
                            for (var i = 0; i < pawns.length; i++)
                            {
                                var p = pawns[i];
                                if (p.data.type == "character" && !p.data.bHostage)
                                {
                                    var dist = this.Dist(p.position[0], p.position[1], _body.position[0], _body.position[1]);
                                    if (dist < 100)
                                    {
                                        if (p.data.team == rescuerTeam)
                                        {
                                            ai.followId = p.data.id;
                                            this.onEvent({
                                                eventId: GameServer.EVENT_GAME_UPDATE,
                                                gameModeData: {
                                                    bHostageFollowing: 1,
                                                    playerId: p.data.id,
                                                    hostageId: data.id
                                                }
                                            });
                                            this.onHostageInteract(_body);
                                            break;
                                        }
                                    }
                                }
                            }
                        }
                    }
                    else
                    {
                        var pawnTypes = data["bZombie"] ? ["character", "turret", "infestor"] : null;
                        var enemyPawn = this.getNearestEnemyPawn(_body, {
                            bIgnoreOutOfSight: data.ai["bIgnoreOutOfSight"],
                            bLOS: data.ai["bLOS"],
                            bPreferDistance: data.ai["bPreferDistance"],
                            pawnTypes: pawnTypes,
                            bAllTypes: data["bZombie"],
                            maxRange: data.ai["maxRange"]
                        });
                        ai["bHasLOS"] = false;
                        delete ai["enemyDist"];
                    }
                    if (enemyPawn)
                    {
                        if (this.localData["bOperation"] && this.localData.difficulty >= 3)
                        {
                            this.emitAISound(enemyPawn.position, enemyPawn.data["team"]);
                        }
                        ai["currentEnemy"] = enemyPawn.data["id"];
                        ai.enemyDist = this.Dist(_body.position[0], _body.position[1], enemyPawn.position[0], enemyPawn.position[1]);
                        if (ai.enemyDist)
                        {
                            let mult = Math.max(0, ai.enemyDist < 50 ? 0 : 0.25);
                            ai.enemyDistMult = Math.max(mult, ai.enemyDist / ai.enemyDistMax);
                        }
                        else
                        {
                            ai.enemyDistMult = 1;
                        }
                        ai["bHasLOS"] = this.checkLineOfSight(startLOSPos, [enemyPawn.position[0], enemyPawn.position[1] - 30], true, enemyPawn); //LocalServer.hasLineOfSight(_body, enemyPawn);
                        if (ai["bHasLOS"] && ai["bCamp"] && ai["bCampUntilLOS"])
                        {
                            ai["bCamp"] = false;
                            delete ai["campPosition"];
                        }
                        if (ai["returnPos"])
                        {
                            delete ai["returnPos"];
                        }
                        if (ai["patrolPoints"] && !ai.bStayPatrol)
                        {
                            if (this.localData["bOperation"])
                            {
                                delete ai["bPatrol"];
                                delete ai["patrolPoints"];
                            }
                            else
                            {
                                delete ai["bPatrol"];
                            }
                        }
                    }
                    else if (ai["bLOS"])
                    {
                        delete ai["currentEnemy"];
                        delete ai["bEnemyWithinRange"];
                        delete ai["bHasLOS"];

                        if (!_body.data.bIsReloading && this.characterCanReload(_body))
                        {
                            this.reloadCharacterWeapon(_body);
                        }
                    }
                    //Handle killstreaks
                    var ps = this.getPlayerStateById(data["id"]);
                    if (ps)
                    {
                        if (ps["controllableId"])
                        {
                            return;
                        }
                        else if (ps["killstreaks"].length > 0)
                        {
                            var killstreaks = ps.killstreaks;
                            for (var i = 0; i < killstreaks.length; i++)
                            {
                                var curKillstreakId = killstreaks[i];
                                if (this.canUseKillstreak(ps["id"], curKillstreakId))
                                {
                                    var bUse = true;
                                    var worldX = _body.position[0];
                                    var worldY = _body.position[1] - 200;
                                    switch (curKillstreakId)
                                    {
                                        case Killstreaks.KILLSTREAK_AIRSTRIKE:
                                        case Killstreaks.KILLSTREAK_BOMBARDMENT:
                                        case Killstreaks.KILLSTREAK_NAPALM:
                                        case Killstreaks.KILLSTREAK_STEALTH_BOMBER:
                                        case Killstreaks.KILLSTREAK_SENTRY_GUN_PLACE:
                                        case Killstreaks.KILLSTREAK_DEADSWITCH:
                                            bUse = enemyPawn != null;
                                            if (enemyPawn)
                                            {
                                                worldX = enemyPawn.position[0];
                                                worldY = enemyPawn.position[1];
                                            }
                                            break;
                                    }
                                    if (bUse)
                                    {
                                        ps["currentKillstreakIndex"] = i;
                                        this.requestEvent({
                                            eventId: GameServer.EVENT_PLAYER_USE_KILLSTREAK,
                                            playerId: ps["id"],
                                            worldX: worldX,
                                            worldY: worldY,
                                        });
                                        break;
                                    }
                                }
                            }
                        }
                    }
                    var moveToPos = null;
                    ai["destThreshold"] = 20;
                    switch (this.localData.gameModeData["id"])
                    {
                        case GameMode.HEADQUARTERS:
                        case GameMode.DOMINATION:
                            var flag = this.getAIBestDominationFlag(_body);
                            if (flag)
                            {
                                ai["destThreshold"] = 100;
                                moveToPos = flag.position;
                            }
                            break;

                        case GameMode.CAPTURE_THE_FLAG:
                            ai["destThreshold"] = 5;
                            if (data.team == 0 || data.team == 1)
                            {
                                var enemyFlag = this.getFlagCTF(data["team"] == 0 ? 1 : 0);
                                var homeFlag = this.getFlagCTF(data["team"]);
                            }
                            else
                            {
                                var randomFlag = Math.floor(this.Random(0, 1));
                                var enemyFlag = this.getFlagCTF(randomFlag);
                                var homeFlag = this.getFlagCTF(randomFlag == 0 ? 1 : 0);
                            }
                            if (enemyFlag.data["carrierId"] === data["id"])
                            {
                                data["bHasFlag"] = true;
                                ai["activityTimer"] = 0;
                                moveToPos = this.clone(homeFlag.position);
                            }
                            else
                            {
                                delete data["bHasFlag"];
                                if (homeFlag.data["bAwayFromHome"])
                                {
                                    var distToHomeFlag = this.Dist(homeFlag.position[0], homeFlag.position[1], _body.position[0], _body.position[1]);
                                    var distToEnemyFlag = this.Dist(enemyFlag.position[0], enemyFlag.position[1], _body.position[0], _body.position[1]);
                                    if (distToHomeFlag < distToEnemyFlag)
                                    {
                                        moveToPos = this.clone(homeFlag.position);
                                    }
                                    else
                                    {
                                        moveToPos = this.clone(enemyFlag.position);
                                        if (enemyFlag.data["carrierId"])
                                        {
                                            ai["destThreshold"] = 200;
                                        }
                                    }
                                }
                                else
                                {
                                    moveToPos = this.clone(enemyFlag.position);
                                    if (enemyFlag.data["carrierId"])
                                    {
                                        ai["destThreshold"] = 200;
                                    }
                                }
                            }
                            break;

                        case GameMode.DEFENDER:
                            var flag = this.getDefenderFlag();
                            if (flag)
                            {
                                if (flag.data["carrierId"] == data["id"])
                                {
                                    if (enemyPawn)
                                    {
                                        moveToPos = enemyPawn.position;
                                    }
                                    var ally = this.getNearestFriendlyPawn(_body, { pawnTypes: ["character"] });
                                    if (ally)
                                    {
                                        moveToPos = ally.position;
                                        ai["destThreshold"] = 100;
                                    }
                                }
                                else
                                {
                                    moveToPos = this.clone(flag.position);
                                    if (flag.data["carrierId"] && flag.data["team"] === data["team"])
                                    {
                                        ai["destThreshold"] = 300;
                                    }
                                }
                            }
                            break;

                        case GameMode.DEMOLITION:
                            if (enemyPawn)
                            {
                                moveToPos = enemyPawn.position;
                            }
                            var bomb = this.getBombCrate();
                            if (bomb)
                            {
                                if (data["team"] != this.localData.gameModeData["bombTeam"])
                                {
                                    if (bomb.data["bBombPlanted"] && !bomb.data["currentPawnId"])
                                    {
                                        moveToPos = bomb.position;
                                    }
                                    else if (ai["bObjectiveTakesPriority"])
                                    {
                                        moveToPos = bomb.position;
                                        ai["destThreshold"] = 300;
                                    }
                                }
                                else
                                {
                                    if (!bomb.data["bBombPlanted"] && !bomb.data["currentPawnId"])
                                    {
                                        moveToPos = bomb.position;
                                    }
                                    else if (ai["bObjectiveTakesPriority"])
                                    {
                                        moveToPos = bomb.position;
                                        ai["destThreshold"] = 300;
                                    }
                                }
                            }
                            break;

                        case GameMode.OP_HOSTAGE:
                            if (data.bHostage)
                            {
                                var rescueZone = this.getRescueZone();
                                var distToZone = this.Dist(_body.position[0], _body.position[1], rescueZone[0], rescueZone[1]);
                                if (distToZone < 200)
                                {
                                    this.rescueHostage(_body, ai.followId);
                                }
                            }
                            else
                            {
                                if (enemyPawn)
                                {
                                    moveToPos = enemyPawn.position;
                                }
                            }
                            break;

                        case GameMode.RESCUE:
                            if (data.bHostage)
                            {
                                var rescueZone = this.getRescueZone();
                                var distToZone = this.Dist(_body.position[0], _body.position[1], rescueZone[0], rescueZone[1]);
                                if (distToZone < 200)
                                {
                                    this.rescueHostage(_body, ai.followId);
                                }
                            }
                            else
                            {
                                var hostage = this.getNearestHostage(_body);
                                if (hostage)
                                {
                                    moveToPos = hostage.position;
                                    if (data.team == this.localData.gameModeData.rescueTeam)
                                    {
                                        ai["destThreshold"] = 50;
                                        if (this.isGuidingHostage(_body))
                                        {
                                            moveToPos = this.getCurrentMapData().spawns_team[0];
                                        }
                                    }
                                    else
                                    {
                                        ai["destThreshold"] = 200;
                                    }
                                }
                                else
                                {
                                    if (enemyPawn)
                                    {
                                        moveToPos = enemyPawn.position;
                                    }
                                }
                            }
                            break;

                        case GameMode.ASSASSINATION:
                            if (data["bVIP"])
                            {
                                //...
                            }
                            else if (data["team"] == this.localData.gameModeData.vipTeam)
                            {
                                var ally = this.getNearestFriendlyPawn(_body, { pawnTypes: ["character"], bVIP: true });
                                if (ally)
                                {
                                    ai["followId"] = ally.data["id"];
                                }
                                else if (enemyPawn)
                                {
                                    delete ai["followId"];
                                    moveToPos = enemyPawn.position;
                                }
                            }
                            else
                            {
                                if (enemyPawn)
                                {
                                    moveToPos = enemyPawn.position;
                                }
                            }
                            break;

                        case GameMode.SURVIVAL_BASIC:
                        case GameMode.SURVIVAL_CHAOS:
                        case GameMode.SURVIVAL_UNDEAD:
                        case GameMode.SURVIVAL_STAKEOUT:
                        case GameMode.SURVIVAL_PRO:
                            if (data["team"] === 0)
                            {
                                var ally = this.getNearestFriendlyPawn(_body, { pawnTypes: ["character"], bPlayerOnly: true });
                                if (ally)
                                {
                                    ai["followId"] = ally.data["id"];
                                }
                                else if (enemyPawn)
                                {
                                    delete ai["followId"];
                                    moveToPos = enemyPawn.position;
                                }
                            }
                            else
                            {
                                if (enemyPawn)
                                {
                                    moveToPos = enemyPawn.position;
                                }
                            }
                            break;

                        default:
                            if (enemyPawn)
                            {
                                moveToPos = enemyPawn.position;
                            }
                            break;

                    }

                    delete ai["interactableId"];
                    delete ai["bInteractableTakesPriority"];
                    if (ai["bCanInteract"])
                    {
                        var interactable = this.getBestInteractable(_body);
                        if (interactable)
                        {
                            ai["interactableId"] = interactable[0].data.id;
                            ai["bInteractableTakesPriority"] = interactable[1];
                            delete ai["bCamp"];
                            delete ai["campPosition"];
                            delete ai["followId"];
                        }
                    }

                    if (data["bIsCapturingFlag"])
                    {
                        //Continue to capture flag
                    }
                    else if (ai["interactableId"])
                    {
                        var interactable = this.getObjectById(ai["interactableId"]);
                        if (interactable)
                        {
                            moveToPos = interactable.position;
                            ai["destThreshold"] = 20;
                        }
                        else
                        {
                            delete ai["interactableId"];
                        }
                    }
                    else if (ai["followId"])
                    {
                        var followTarget = this.getObjectById(ai["followId"]);
                        if (followTarget)
                        {
                            moveToPos = followTarget.position;
                            ai["destThreshold"] = data.bHostage ? 50 : 200;
                        }
                    }
                    else if (ai["campPosition"])
                    {
                        moveToPos = ai["campPosition"];
                        ai["destThreshold"] = 30;
                    }
                    else if (ai["investigatePos"] && ai["bCanInvestigate"])
                    {
                        moveToPos = ai["investigatePos"];
                        ai["destThreshold"] = 50;
                    }
                    else if (ai["returnPos"] && ai["bCanInvestigate"])
                    {
                        moveToPos = ai["returnPos"];
                        ai["destThreshold"] = 50;
                    }
                    else if (ai["bPatrol"] && ai["patrolPoints"])
                    {
                        moveToPos = ai["patrolPoints"][0];
                        ai["destThreshold"] = 100;
                    }

                    ai["moveToPos"] = moveToPos;
                    var yOffset = data["type"] === "infestor" ? 30 : 0;
                    if (ai.pathTicker <= 0)
                    {
                        ai["path"] = this.getAIPath([_body.position[0], _body.position[1] + yOffset], moveToPos, _body, ai["destThreshold"], data["bIsOnLadder"]);
                        var pathTickerMax = 0;
                        if (!_body.data.bHostage)
                        {
                            switch (ai.botSkill)
                            {
                                case BotSkill.SKILL_EASY:
                                    pathTickerMax = 2;
                                    break;
                                case BotSkill.SKILL_NORMAL:
                                    pathTickerMax = 1;
                                    break;
                                case BotSkill.SKILL_GOD:
                                    pathTickerMax = 0;
                                    break;
                                default:
                                    pathTickerMax = 1;
                                    break;
                            }
                        }
                        ai.pathTicker = pathTickerMax;
                    }
                    else
                    {
                        ai.pathTicker--; 
                    }

                    //Handle inventory
                    var bestIndex = this.getBestInventoryIndex(_body, enemyPawn, ai["enemyDist"]);
                    if (bestIndex != data["currentInventoryIndex"])
                    {
                        this.requestEvent({
                            eventId: GameServer.EVENT_PLAYER_UPDATE_INVENTORY,
                            pawnId: data["id"],
                            type: GameServer.INV_CURRENT_INVENTORY_INDEX,
                            value: bestIndex
                        });
                    }

                    var item = data.inventory[data.currentInventoryIndex];

                    //Handle equipment
                    var equipment = data.equipment;
                    if (equipment && equipment["ammo"])
                    {
                        if (enemyPawn)
                        {
                            var enemyDist = ai["enemyDist"]; //this.Dist(_body.position[0], _body.position[1], enemyPawn.position[0], enemyPawn.position[1]);
                        }
                        switch (equipment["type"])
                        {
                            case Weapon.TYPE_GRENADE:
                                var bThrowGrenade = false;
                                if (enemyPawn)
                                {
                                    if (enemyDist > (ai["lookRange"] * 0.5) && enemyDist < ai["lookRange"])
                                    {
                                        //var pawnsInArea = this.getPawnsInArea(data["team"], enemyPawn.position, 300);
                                        bThrowGrenade = Math.random() > 0.95;
                                    }
                                    else if (!ai["bHasLOS"] && enemyDist < ai["lookRange"] * 0.5)
                                    {
                                        bThrowGrenade = Math.random() > 0.8;
                                    }
                                    else if (enemyPawn.data["type"] === "turret")
                                    {
                                        bThrowGrenade = Math.random() > 0.8;
                                    }
                                }
                                if (bThrowGrenade)
                                {
                                    var rad = this.Angle(_body.position[0], _body.position[1], enemyPawn.position[0], enemyPawn.position[1]);
                                    var halfDist = enemyDist * 0.3;
                                    this.useCharacterEquipment(_body, _body.position[0] + (Math.cos(rad) * halfDist), (_body.position[1] + (Math.sin(rad) * halfDist)) - (enemyDist * 0.3));
                                }
                                break;

                            case Weapon.TYPE_EXPLOSIVE:
                                if (!enemyPawn || enemyDist > (ai["lookRange"] * 0.5))
                                {
                                    this.useCharacterEquipment(_body, _body.position[0], _body.position[1]);
                                }
                                break;

                            case Weapon.TYPE_TACTICAL:
                                switch (equipment.id)
                                {
                                    case "knife":
                                        if (!ai["bFireCooldown"] && ai["bHasLOS"] && enemyDist < ai["lookRange"])
                                        {
                                            var rad = this.Angle(_body.position[0], _body.position[1], enemyPawn.position[0], enemyPawn.position[1]);
                                            this.useCharacterEquipment(_body, _body.position[0], _body.position[1] - (enemyDist * 0.1));
                                        }
                                        break;

                                    case "trophy":
                                        if (ai["bFireCooldown"] || ai["bHasLOS"] || (enemyDist < ai["lookRange"] * 0.5))
                                        {
                                            this.useCharacterEquipment(_body, _body.position[0], _body.position[1]);
                                        }
                                        break;

                                    case "stim":
                                        if (_body.data.health < (_body.data.maxHealth * 0.5))
                                        {
                                            this.useCharacterEquipment(_body, _body.position[0], _body.position[1]);
                                        }
                                        else
                                        {
                                            var injuredAlly = this.getNearestFriendlyPawn(_body, { maxRange: 100, bInjured: true });
                                            if (injuredAlly)
                                            {
                                                this.useCharacterEquipment(_body, _body.position[0], _body.position[1]);
                                            }
                                        }
                                        break;

                                    default:
                                        if (!enemyPawn || enemyDist > (ai["lookRange"] * 0.5))
                                        {
                                            this.useCharacterEquipment(_body, _body.position[0], _body.position[1]);
                                        }
                                        break;
                                }
                                break;
                        }
                    }
                }
                //End ai["ticker"] == 0

                var distToMovePos = undefined;
                moveToPos = ai["moveToPos"];
                if (moveToPos)
                {
                    distToMovePos = this.Dist(_body.position[0], _body.position[1], moveToPos[0], moveToPos[1]);
                }
                var moveDirX = 0;
                var moveDirY = 0;
                var bMovingBack = false;
                if (ai["path"])
                {
                    var node = ai["path"][0];
                    if (node && node.data)
                    {
                        if (!data["bIsOnLadder"] && !data["bLadderCooldown"])
                        {
                            var endNode = ai.path[ai.path.length - 1];
                            if (ai["ticker"] % 10 == 0)
                            {
                                var bHasEndNodeLOS = this.checkLineOfSight(_body.position, node.data.position);
                            }
                            if (bHasEndNodeLOS)
                            {
                                var distToEndNode = this.Dist(_body.position[0], _body.position[1], endNode.data.position[0], endNode.data.position[1]);
                                if (distToEndNode < ai["destThreshold"] && bHasEndNodeLOS)
                                {
                                    var bWithinEndNode = true;
                                }
                            }
                        }
                        if (bWithinEndNode)
                        {
                            ai["path"] = [];
                        }
                        else
                        {
                            var nodeThreshold = (node.data.threshold ? node.data.threshold : (data.type === "character" ? 30 : 40));
                            if (data["bIsOnLadder"] || data["bLadderCooldown"])
                            {
                                nodeThreshold = 10;
                            }
                            var nodeDist = this.Dist(node.data.position[0], node.data.position[1], _body.position[0], _body.position[1]);
                            if (nodeDist >= nodeThreshold)
                            {
                                if (Math.abs(node.data.position[0] - _body.position[0]) > 5)
                                {
                                    if (node.data.position[0] < _body.position[0])
                                    {
                                        moveDirX = -1;
                                    }
                                    else
                                    {
                                        moveDirX = 1;
                                    }
                                }
                                if (!data["bIsOnLadder"])
                                {
                                    var bShouldClimb = true;
                                    if (bShouldClimb)
                                    {
                                        if (node.data.position[1] > _body.position[1] + 100)
                                        {
                                            if (data["bOnGround"] && !data["bLadderCooldown"])
                                            {
                                                var ladder = this.getClimbableLadder(_body);
                                                if (ladder)
                                                {
                                                    this.startLadderClimb(_body, ladder);
                                                }
                                            }
                                        }
                                    }
                                }
                                if (data["bIsOnLadder"])
                                {
                                    if (node.data.position[1] < (_body.position[1] + 70))
                                    {
                                        moveDirY = -1;
                                    }
                                    else if (node.data.position[1] > (_body.position[1] + 100))
                                    {
                                        moveDirY = 1;
                                    }
                                    else
                                    {
                                        this.leaveLadder(_body);
                                    }
                                }
                            }
                            else
                            {                                
                                //Node reached
                                switch (node.data.type)
                                {
                                    case "node_walk":
                                        if (data["bIsOnLadder"])
                                        {
                                            this.triggerCharacterJump(_body);
                                        }
                                        break;

                                    case "node_jump":
                                        this.triggerCharacterJump(_body);
                                        break;

                                    case "node_climb":
                                        var bShouldClimb = true;
                                        if (bShouldClimb)
                                        {
                                            var nextNode = ai["path"][1];
                                            if (nextNode && nextNode.data.position[1] < (_body.position[1] - 10))
                                            {
                                                var ladder = this.getObjectById(node.data.ladderId);
                                                if (ladder)
                                                {
                                                    this.startLadderClimb(_body, ladder);
                                                }
                                            }
                                        }
                                        break;
                                }
                                ai["path"].splice(0, 1);
                            }
                        }
                        if (ai["path"].length === 0)
                        {
                            if (!ai["bCamp"])
                            {
                                if (ai["investigatePos"])
                                {
                                    delete ai["investigatePos"];
                                    delete ai["investigatePriority"];
                                }
                                if (ai["returnPos"])
                                {
                                    delete ai["returnPos"];
                                }
                            }
                            if (ai["bPatrol"] && ai["patrolPoints"])
                            {
                                ai.patrolPoints.push(ai.patrolPoints.shift());
                            }
                        }
                    }
                    else
                    {
                        //...
                    }
                }
                var interactable = this.getObjectById(ai["interactableId"]);
                if (interactable)
                {
                    var distToInteractable = this.Dist(_body.position[0], _body.position[1], interactable.position[0], interactable.position[1]);
                    if (distToInteractable < 5 || interactable.getAABB().overlaps(_body.getAABB()))
                    {
                        this.requestEvent({
                            eventId: GameServer.EVENT_PLAYER_INTERACT,
                            playerId: data.id,
                            pawnId: data.id,
                            interactableId: ai["interactableId"],
                            bServerSideOnly: true
                        });
                    }
                }
                var enemy = this.getObjectById(ai["currentEnemy"]);
                if (enemy)
                {
                    enemyDist = enemy ? this.Dist(_body.position[0], _body.position[1], enemy.position[0], enemy.position[1]) : 0;                    
                    //var bInLineOfSight = this.checkLineOfSight(startLOSPos, enemy.position, true, enemy);
                    var bPassLOS = true;
                    if (ai["bLOS"])
                    {
                        bPassLOS = ai["bHasEnemyLOS"]; //bInLineOfSight;
                    }
                }
                if (enemy && bPassLOS)
                {
                    var curWeapon = this.getCurrentCharacterInventoryItem(_body);
                    if (curWeapon["bProjectile"])
                    {
                        data["lookPos"] = [enemy.position[0], enemy.position[1] - (enemyDist * 0.14) + 20]; //Projectile trajectory
                    }
                    else if (curWeapon["bGrenade"])
                    {
                        data["lookPos"] = [enemy.position[0], enemy.position[1] - (enemyDist * 0.15) + 20]; //Grenade trajectory
                    }
                    else if (curWeapon["bRocket"])
                    {
                        data["lookPos"] = [enemy.position[0], enemy.position[1]];
                    }
                    else
                    {
                        if (enemyDist > 100)
                        {
                            switch (ai["botSkill"])
                            {
                                case BotSkill.SKILL_GOD:
                                case BotSkill.SKILL_INSANE:
                                    {
                                        //Aim for headshots
                                        if (enemy.data["type"] == "character")
                                        {
                                            if (enemy.data["shieldId"])
                                            {
                                                data["lookPos"] = [enemy.position[0], enemy.position[1] + 35];
                                            }
                                            else
                                            {
                                                data["lookPos"] = [enemy.position[0], enemy.position[1] - 12];
                                            }
                                        }
                                        else if (enemy.data["type"] === "infestor")
                                        {
                                            data["lookPos"] = [enemy.position[0], enemy.position[1] + 40];
                                        }
                                        else
                                        {
                                            data["lookPos"] = [enemy.position[0], enemy.position[1]];
                                        }
                                    }
                                    break;

                                default:
                                    if (enemy.data["type"] === "infestor")
                                    {
                                        data["lookPos"] = [enemy.position[0], enemy.position[1] + 20];
                                    }
                                    else
                                    {
                                        if (enemy.data["shieldId"])
                                        {
                                            data["lookPos"] = [enemy.position[0], enemy.position[1] + 25];
                                        }
                                        else
                                        {
                                            data["lookPos"] = [enemy.position[0], enemy.position[1] + (data["bWantsToCrouch"] ? -10 : 10)];
                                        }                                        
                                    }
                                    break;
                            }                           
                        }
                        else
                        {
                            if (enemy.data["type"] === "infestor")
                            {
                                data["lookPos"] = [enemy.position[0], enemy.position[1] + 20];
                            }
                            else
                            {
                                if (enemy.data["shieldId"])
                                {
                                    data["lookPos"] = [enemy.position[0], enemy.position[1] + 25];
                                }
                                else
                                {
                                    data["lookPos"] = [enemy.position[0], enemy.position[1] + 20];
                                }
                            }
                        }
                        if (ai.enemyDistMult)
                        {
                            if (ai.offsetX)
                            {
                                data.lookPos[0] += ai.offsetX * ai.enemyDistMult;
                            }
                            if (ai.offsetY)
                            {
                                data.lookPos[1] += ai.offsetY * ai.enemyDistMult;
                            }
                        }
                    }
                    item = this.getCurrentCharacterInventoryItem(_body);
                    ai["bEnemyWithinRange"] = enemyDist < Math.max(item["range"], ai["lookRange"]) && enemyDist < item["range"];
                    if (ai["bEnemyWithinRange"])
                    {
                        var bTriggerFire = true;
                        if (!ai["bHasEnemyLOS"]) //bInLineOfSight
                        {
                            bTriggerFire = false;
                        }
                        this.requestEvent({
                            eventId: GameServer.EVENT_PLAYER_TRIGGER_WEAPON,
                            playerId: data["id"],
                            value: this.hasInventoryAmmo(_body) && bTriggerFire,
                            worldPosition: data["lookPos"],
                            bServerSideOnly: true
                        });
                        if (data["type"] === "character")
                        {
                            if (data["bZombie"])
                            {
                                if (data["zombieType"] === Zombie.TYPE_SPRINTER)
                                {
                                    //...
                                }
                            }
                            else
                            {
                                if (enemyDist < 50)
                                {
                                    if (!data.ai["bFireCooldown"])
                                    {
                                        this.useCharacterMeleeAttack(_body);
                                    }
                                }
                            }
                        }
                        var bMoveToInteractable = interactable ? ai["bInteractableTakesPriority"] : false;
                        var bMoveBackFromEnemy = !data["bLadderCooldown"] && ai["bHasLOS"] && !bMoveToInteractable && (!ai.bObjectiveTakesPriority || data.bHero);
                        if (bMoveBackFromEnemy)
                        {
                            var enemyDistThreshold = item.range * (ai.bObjectiveTakesPriority ? 0.1 : 0.2);
                            if (ai["bCamp"] && distToMovePos < 100)
                            {
                                enemyDistThreshold = 100;
                            }
                            if (enemyDist < enemyDistThreshold)
                            {
                                var desiredMoveX = enemy.position[0] > _body.position[0] ? -1 : 1;
                                if (ai["ticker"] % 10 == 0)
                                {
                                    ai["bMoveCheck"] = this.checkLineOfSight([_body.position[0], _body.position[1]], [_body.position[0] + (50 * desiredMoveX), _body.position[1] + 50], false);
                                }
                                if (ai["bMoveCheck"] == true || ai["bMoveCheck"] == null)
                                {
                                    moveDirX = 0;
                                }
                                else
                                {
                                    moveDirX = desiredMoveX;
                                    bMovingBack = true;
                                }
                            }
                            else
                            {
                                moveDirX = 0;
                            }
                        }
                    }
                }
                else if (!enemy)
                {
                    data["bWantsToFire"] = false;
                    if (ai["investigatePos"])
                    {
                        data["lookPos"] = ai["investigatePos"];
                    }
                    else if (ai["moveToPos"])
                    {
                        data["lookPos"] = ai["moveToPos"];
                    }
                    if (data["lookPos"])
                    {
                        var distToLookPos = this.Dist(data["lookPos"][0], data["lookPos"][1], _body.position[0], _body.position[1]);
                        if (distToLookPos < 80)
                        {
                            data["lookPos"] = [_body.position[0] + (data["scale"] * 100), _body.position[1]];
                        }
                    }

                }

                data["bWantsToMove"] = false;
                if (!data["bOnGround"] && !data["bLadderCooldown"]) //this.isOnGround(_body)
                {
                    if (moveDirX != 0)
                    {
                        var nextNode = ai["path"] ? ai["path"][0] : null;
                        if (nextNode && nextNode.data)
                        {
                            var yDif = _body.position[1] - nextNode.data.position[1];
                            if (yDif < -50)
                            {
                                //moveDirX = 0;
                            }
                        }
                    }
                }
                if (data["bIsCapturingFlag"])
                {
                    moveDirX = 0;
                }
                switch (moveDirX)
                {
                    case 1:
                        this.handlePlayerInput(_body, {
                            keyId: "right",
                            value: true
                        });
                        break;
                    case -1:
                        this.handlePlayerInput(_body, {
                            keyId: "left",
                            value: true
                        });
                        break;

                    case 0:
                        if (!data["bZombie"] && !this.playerHasControllable(data["id"]) && !data["bLadderCooldown"] && this.characterCanCrouch(_body))
                        {
                            switch (ai["botSkill"])
                            {
                                case BotSkill.SKILL_HARD:
                                case BotSkill.SKILL_INSANE:
                                case BotSkill.SKILL_GOD:
                                    data["bWantsToCrouch"] = (ai["bCamp"] ? true : (ai.bHasLOS || ai.enemyDist > ai.lookRange || !ai.currentEnemy));
                                    break;
                                default:
                                    data["bWantsToCrouch"] = ai["bCamp"];
                                    break;
                            }
                        }
                        break;
                }
                switch (moveDirY)
                {
                    case 1:
                        this.handlePlayerInput(_body, {
                            keyId: "down",
                            value: true
                        });
                        break;
                    case -1:
                        this.handlePlayerInput(_body, {
                            keyId: "up",
                            value: true
                        });
                        break;
                }

                if (data["type"] === "character") //!data["bZombie"]
                {
                    data["bWantsToSprint"] = false;
                    var sprintMult = ai["botSkill"] >= BotSkill.SKILL_HARD ? 1 : 0.5;
                    if (ai["bHasLOS"] && ai["enemyDist"] < (item["range"] * sprintMult) && !this.isMeleeWeapon(item))
                    {
                        //Don't sprint
                    }
                    else if (moveDirX != 0 && !bMovingBack && data["bWantsToMove"] && !this.isGuidingHostage(_body) && !data.bVIP)
                    {
                        if (distToMovePos)
                        {
                            switch (ai["botSkill"])
                            {
                                case BotSkill.SKILL_GOD:
                                    data["bWantsToSprint"] = distToMovePos > 50;
                                    break;

                                case BotSkill.SKILL_INSANE:
                                    data["bWantsToSprint"] = distToMovePos > 100;
                                    break;

                                case BotSkill.SKILL_HARD:
                                    data["bWantsToSprint"] = distToMovePos > (ai["lookRange"] * 0.2);
                                    break;

                                case BotSkill.SKILL_NORMAL:
                                    data["bWantsToSprint"] = distToMovePos > ai["lookRange"];
                                    break;
                            }
                        }
                        data["bWantsToSprint"] = data["bWantsToSprint"] && this.characterCanSprint(_body);
                    }
                }

                if (ai["bFireCooldown"])
                {
                    if (ai["fireCooldownTimer"] > 0)
                    {
                        ai["fireCooldownTimer"]--;
                    }
                    else
                    {
                        ai["bFireCooldown"] = false;
                        ai["fireCooldownTimer"] = ai["fireCooldownTimerMax"];
                    }
                }
                else
                {
                    if (ai["fireBurstTimer"] > 0)
                    {
                        ai["fireBurstTimer"]--;
                    }
                    else
                    {
                        ai["bFireCooldown"] = true;
                        ai["fireBurstTimer"] = ai["fireBurstTimerMax"];
                    }
                }

                if (data["bWantsToFire"])
                {
                    if (!ai["bFireCooldown"])
                    {
                        bTriggerFire = true;
                        var curWeapon = data.inventory[data.currentInventoryIndex];
                        if (curWeapon["fireMode"] == Weapon.MODE_SEMI)
                        {
                            if (ai["semiCooldownTimer"] == 0)
                            {
                                ai["semiCooldownTimer"] = ai["semiCooldownTimerMax"];
                                bTriggerFire = true;
                            }
                            else
                            {
                                ai["semiCooldownTimer"]--;
                                bTriggerFire = false;
                            }
                        }
                        data["bWantsToFire"] = bTriggerFire;
                        if (data["bWantsToFire"])
                        {
                            var weapon = data["weapon"];
                            weapon["bFireHandler"] = true;
                        }
                    }
                    else
                    {
                        data["bWantsToFire"] = false;
                    }
                }
                else
                {
                    data["bWantsToFire"] = false;
                }

                /*
                if (ai["ticker"] == 0 && !ai["bObjectiveTakesPriority"])
                {
                    if (ai["currentEnemy"] && data["bWantsToFire"] && data["bWantsToInteract"])
                    {
                        if (ai["botSkill"] > BotSkill.SKILL_EASY)
                        {
                            this.stopCharacterInteract(_body);
                        }
                    }
                }
                */
            }

        }

        if (data["lookPos"])
        {
            var distX = data["lookPos"][0] - (_body.position[0]);
            var distY = data["lookPos"][1] - (_body.position[1]);
            var angle = Math.atan2(distY, distX);
            data["desiredAimRotation"] = angle; //If rounded, aim could be off
        }
    }

    handleTurret(_body)
    {
        var data = _body.data;
        var turretData = data["turretData"];
        var bWantedToFire = data.bWantsToFire;
        if (data["bUseExposeTimer"] && data["bExposed"])
        {
            if (data["exposedTimer"] > 0)
            {
                data["exposedTimer"]--;
            }
            else
            {
                data["bExposed"] = false;
            }
        }
        if (data["fireDelayTimer"] > 0)
        {
            data["bFireDelay"] = true;
            data["fireDelayTimer"]--;
        }
        else
        {
            data["bFireDelay"] = false;
        }
        if (data["bStunned"] || data["bFlashed"] || (this.isInSmoke(_body) && data["bAutomated"]))
        {
            data["desiredAimRotation"] = data["scale"] == 1 ? (this.ToRad(30) + _body.angle) : (this.ToRad(150) + _body.angle);
            data["bWantsToFire"] = false;
        }
        else if (data["ammo"] > 0)
        {
            var muzzlePos = this.getMuzzlePosition(_body);
            if (!data["bAutomated"])
            {
                //Player-controlled turrets
                if (!data["controllerId"])
                {
                    data["bWantsToFire"] = false;
                    data["desiredAimRotation"] = data["scale"] == 1 ? _body.angle : (this.ToRad(180) + _body.angle);
                }
                else
                {
                    data["desiredAimRotation"] = this.Angle(muzzlePos[0], muzzlePos[1], data["aimPos"][0], data["aimPos"][1]);
                }
            }
            else
            {
                //Automated turrets
                if (data["ticker"] > 0)
                {
                    data["ticker"]--;
                }
                else if (data["ticker"] == 0)
                {
                    data["bWantsToFire"] = false; 
                    if (!turretData["bDisabled"])
                    {
                        var enemy = this.getNearestEnemyPawn(_body, {
                            bTargetColdBlooded: false,
                            bIgnoreOutOfSight: data["bLOS"],
                            maxRange: data["maxRange"],
                            pawnTypes: data["enemyTypes"],
                            scale: data["bLimitScale"] ? data["scale"] : undefined,
                            bLOS: data["bLOS"]
                        });
                    }
                    var prevEnemy = data["enemyId"];
                    data["enemyId"] = enemy ? enemy.data.id : null;
                    if (data["weaponType"] == "rocket")
                    {
                        if (enemy && prevEnemy != data["enemyId"])
                        {
                            data["bFireDelay"] = true;
                            data["fireDelayTimer"] = this.localData.settings.fps;
                        }
                    }
                    data["ticker"] = this.localData.settings.fps;
                }       
                var currentEnemy = this.getObjectById(data["enemyId"]);
                if (currentEnemy)
                {          
                    data["bWantsToFire"] = true;
                    if (data["bLimitScale"])
                    {
                        if (data["scale"] == 1 && currentEnemy.position[0] < _body.position[0])
                        {
                            data["bWantsToFire"] = false;
                        }
                        else if (data["scale"] == -1 && currentEnemy.position[0] > _body.position[0])
                        {
                            data["bWantsToFire"] = false;
                        }
                    }                    
                    data["desiredAimRotation"] = this.Angle(muzzlePos[0], muzzlePos[1], currentEnemy.position[0], currentEnemy.position[1]);
                }
                if (!data["bWantsToFire"])
                {
                    data["desiredAimRotation"] = data["scale"] == 1 ? _body.angle : (this.ToRad(180) + _body.angle);
                }
            }
            if (data["bWantsToFire"] && !data["bFireDelay"] && this.matchInProgress())
            {
                var accuracy = data.accuracy;
                var aimRad = data["aimRotation"] + this.ToRad(this.Random(-accuracy, accuracy));
                switch (data["weaponType"])
                {
                    case "bullet":
                        var playerId = turretData["playerId"];
                        if (!data["bAutomated"])
                        {
                            playerId = data["controllerId"];
                        }
                        var bIgnoreObstacles = this.localData["bSurvival"] || data["bAutomated"];
                        var weaponData = null;
                        if (this.localData["bRanked"])
                        {
                            weaponData = {
                                damage: data.damage,
                                range: data.maxRange,
                                penetration: 1
                            };
                        }
                        this.createBullet(muzzlePos[0], muzzlePos[1], aimRad, data["maxRange"], data["damage"], playerId ? playerId : data["id"], data["id"], data["killstreakId"], weaponData, !data["bAutomated"], false, bIgnoreObstacles);
                        break;

                    case "grenade":
                        var playerId = data["controllerId"] ? data["controllerId"] : turretData["playerId"];
                        this.createGrenade(muzzlePos, {
                            bImpact: true,
                            team: data["team"],
                            playerId: playerId,
                            causerId: data["id"],
                            rotation: aimRad,
                            velocity: 1600,
                            damage: data["damage"],
                            weaponId: "thumper",
                            killstreakId: data["killstreakId"],
                            radius: 400
                        }, true);
                        break;

                    case "rocket":
                        this.createRocket(muzzlePos, {
                            type: Rocket.TYPE_DEFAULT,
                            team: data["team"],
                            playerId: turretData["playerId"],
                            causerId: data["id"],
                            rotation: aimRad,
                            enemyId: data["enemyId"],
                            weaponId: data["killstreakId"]
                        });
                        break;
                }
                if (data["bUseExposeTimer"])
                {
                    this.emitAISound(this.clone(_body.position), _body.data["team"]);
                    _body.data["bExposed"] = true;
                    _body.data["exposedTimer"] = this.localData.settings.fps * 2;
                }
                if (!data["bUnlimitedAmmo"])
                {
                    data["ammo"]--;
                }
                data["fireDelayTimer"] = data["fireRate"];
                this.requestEvent({
                    eventId: GameServer.EVENT_PAWN_ACTION,
                    pawnId: data["id"],
                    type: GameServer.PAWN_FIRE_WEAPON,
                    recoil: 2
                });
                this.emitAISound(muzzlePos, data["team"]);
            }
        }
        else
        {
            data["desiredAimRotation"] = this.ToRad(0);
            if (data["destroyTimer"] == undefined)
            {
                data["destroyTimer"] = this.localData.settings.fps;
            }
        }
        var target = this.WrapAngle(data["aimRotation"] - data["desiredAimRotation"], true);
        data["aimRotation"] -= target * data["aimSpeed"];
        if (data.bWantsToFire != bWantedToFire)
        {
            this.pushObjectDataUpdate(data.id, ["bWantsToFire"]);
        }
    }

    handleCar(_body)
    {
        var data = _body.data;
        var carData = data.carData;
        if (!_body.fixedRotation)
        {
            _body.angularVelocity = -_body.angle * 10;
        }
        if (!data["health"])
        {
            if (data["controllerId"])
            {
                var ps = this.getPlayerStateById(data["controllerId"]);
                this.clearPlayerControllable(ps);
            }
            return;
        }
        if (data["bBot"])
        {
            var enemy = this.getNearestEnemyPawn(_body, {
                bLOS: this.localData["bOperation"],
                bIgnoreOutOfSight: this.localData["bOperation"]
            });
            if (enemy)
            {
                data["moveX"] = enemy.position[0] > _body.position[0] ? 1 : -1;
                if (this.Dist(enemy.position[0], enemy.position[1], _body.position[0], _body.position[1]) < 75)
                {
                    data["bWantsToFire"] = true;
                }
            }
        }
        if (data["bWantsToFire"])
        {
            switch (carData.carType)
            {
                case Car.TYPE_RCXD:
                    this.requestEvent({
                        eventId: GameServer.EVENT_PAWN_DAMAGE,
                        damageType: DamageType.DAMAGE_MELEE,
                        damageAmount: data.health,
                        pawnId: data.id,
                        attackerId: data.id,
                        causerId: null,
                        weaponId: Killstreaks.KILLSTREAK_RCXD,
                        bDirectlyCausedByPlayer: false
                    });
                    break;
            }
        }
        var carSpeed = 2250;
        if (data["moveX"] != 0)
        {
            _body.applyForce([carSpeed * data["moveX"], 0]);
        }
        data["moveX"] = 0;
        this.constrainVelocity(_body, 500);
    }

    handleHelicopter(_body)
    {
        var data = _body.data;
        var heliData = data["heliData"];
        var destination = heliData["destination"];
        var dist = destination ? this.Dist(destination[0], destination[1], _body.position[0], _body.position[1]) : Number.MAX_VALUE;
        if (!data["health"])
        {
            if (data["controllerId"])
            {
                var ps = this.getPlayerStateById(data["controllerId"]);
                this.clearPlayerControllable(ps);
            }
            return;
        }
        if (data["burstDelayTimer"] > 0)
        {
            data["bBurstDelay"] = true;
            data["burstDelayTimer"]--;
        }
        else
        {
            data["bBurstDelay"] = false;
        }
        if (data["fireDelayTimer"] > 0)
        {
            data["bFireDelay"] = true;
            data["fireDelayTimer"]--;
        }
        else
        {
            data["bFireDelay"] = false;
        }
        if (data["rockets"] != null)
        {
            if (data["rocketDelayTimer"] > 0)
            {
                data["bRocketDelay"] = true;
                data["rocketDelayTimer"]--;
            }
            else
            {
                data["bRocketDelay"] = false;
            }
        }
        if (data["bBot"] && !data["bPlayerControlled"])
        {
            data["bWantsToFire"] = false;
        }
        if (data["bUseTimer"])
        {
            if (data["timer"] > 0)
            {
                data["timer"]--;
            }
            else
            {
                data["ammo"] = 0;
                this.pushObjectDataUpdate(data.id, ["ammo"]);
            }
        }
        switch (data["behaviour"])
        {
            case "deliver":
                if (dist < data["distThreshold"])
                {
                    if (data["bDestinationReached"])
                    {
                        if (data["bDestroy"])
                        {
                            this.removeNextStep(_body);
                            break;
                        }
                    }
                    else
                    {
                        console.log("Leave map");
                        _body.shapes[0].collisionMask = (CollisionGroups.PROJECTILE | CollisionGroups.PROJECTILE_AIR);
                        data["bDestinationReached"] = true;
                        data["bDestroy"] = true;
                        heliData["destination"] = [heliData["scale"] === 1 ? this.getCurrentMapData().width : 0, 0];
                        this.dropHelicopterCrate(_body);
                    }
                }
                break;

            case "attack":
                if (data["bDestroy"])
                {
                    if (dist < data["distThreshold"])
                    {
                        this.removeNextStep(_body);
                        break;
                    }
                }
                if (data["ticker"] > 0)
                {
                    data["ticker"]--;
                }
                else
                {                    
                    if (this.localData["bBattlezone"])
                    {
                        data["ticker"] = this.localData.settings.fps * 2;
                    }
                    else
                    {
                        data["ticker"] = this.localData.settings.fps * (data["bPlayerControlled"] ? 3 : 1);
                    }
                }
                var muzzlePos = this.getMuzzlePosition(_body);
                if (data["rockets"] > 0)
                {
                    if (data["bWantsToFireRocket"])
                    {
                        if (!data["bRocketDelay"])
                        {
                            this.createRocket(muzzlePos, {
                                type: Rocket.TYPE_DEFAULT,
                                team: data["team"],
                                playerId: heliData["playerId"] ? heliData["playerId"] : data["id"],
                                causerId: data["id"],
                                rotation: data["aimRotation"],
                                weaponId: data["killstreakId"]
                            });
                            data["rockets"]--;
                            data["rocketDelayTimer"] = this.localData.settings.fps;
                            this.requestEvent({
                                eventId: GameServer.EVENT_PAWN_ACTION,
                                pawnId: data["id"],
                                type: GameServer.PAWN_FIRE_ROCKET,
                                recoil: 10
                            });
                            this.emitAISound(muzzlePos, data["team"]);
                        }
                    }
                }
                if (data["ammo"] > 0)
                {
                    if (data["bControllable"] && !data["controllerId"])
                    {
                        data["ammo"] = 0;
                        this.pushObjectDataUpdate(data.id, ["ammo"]);
                    }                    
                    if (data["bBot"] && data["ticker"] == 0)
                    {
                        var enemyPawn = this.getNearestEnemyPawn(_body, {
                            bTargetColdBlooded: false,
                            maxRange: data["bMaxLookRange"] ? Number.MAX_VALUE : data["maxRange"],
                            pawnTypes: this.localData["bModeGame"] ? ["character", "infestor"] : null,
                            bLOS: this.localData["bOperation"] || this.localData["bBattlezone"],
                            bIgnoreOutOfSight: this.localData["bOperation"] || this.localData["bBattlezone"]
                        });
                        if (enemyPawn)
                        {
                            data["currentEnemy"] = enemyPawn.data.id;
                        }
                        else
                        {
                            delete data["currentEnemy"];
                        }
                        if (!data["bAirdrop"])
                        {
                            data["bExplore"] = enemyPawn == null;
                        }
                    }
                    var enemy = this.getObjectById(data["currentEnemy"]);
                    if (enemy)
                    {
                        var enemyDist = this.Dist(enemy.position[0], enemy.position[1], _body.position[0], _body.position[1]);
                        if (data["bBot"] && !data["bPlayerControlled"])
                        {
                            data["desiredAimRotation"] = this.Angle(muzzlePos[0], muzzlePos[1], enemy.position[0], enemy.position[1]);
                            data["aimPos"][0] = enemy.position[0];
                            data["aimPos"][1] = enemy.position[1];
                            var bLOS = this.checkLineOfSight(_body.position, enemy.position, true, enemy);
                            if (enemyDist < data["maxRange"] && bLOS)
                            {
                                data["bWantsToFire"] = true;
                                if (data["rockets"] > 0)
                                {
                                    data["bWantsToFireRocket"] = true;
                                }
                            }
                        }
                        if (!data["bExplore"] && !data["bAirdrop"] && data["bBot"])
                        {
                            if (data["bDrone"])
                            {
                                heliData["destination"] = [enemy.position[0], enemy.position[1] - 200];
                            }
                            else
                            {
                                //if (enemyDist < (data["maxRange"] * 0.8))
                                heliData["destination"] = [enemy.position[0], enemy.position[1] - (data["bPlayerControlled"] ? 500 : 400)];
                            }
                        }
                    }
                    else
                    {
                        if (data["bHasBurstDelay"])
                        {
                            data["burstTimer"] = data["burstTimerMax"];
                        }
                    }

                    if (data["bDefendOwner"])
                    {
                        if (data.heliData["playerId"])
                        {
                            var owner = this.getObjectById(data.heliData["playerId"]);
                            var ownerDist = owner ? this.Dist(owner.position[0], owner.position[1], _body.position[0], _body.position[1]) : 0;
                            if (!enemy || ownerDist > (data["maxRange"] * 0.5))
                            {
                                if (owner)
                                {
                                    heliData["destination"] = [owner.position[0], owner.position[1] - 400];
                                }
                            }
                        }
                        else if (enemy)
                        {
                            heliData["destination"] = [enemy.position[0] - data.muzzleOffsetX, enemy.position[1] - 300];
                        }
                    }

                    if (data["bExplore"])
                    {
                        if (dist < data["distThreshold"] || !destination)
                        {
                            if (data["exploreTimer"] > 0)
                            {
                                data["exploreTimer"]--;
                            }
                            else 
                            {
                                var map = this.getCurrentMapData();
                                var heliExploreSpots = map.heliExploreSpots;
                                if (heliExploreSpots)
                                {
                                    heliData["destination"] = heliExploreSpots[this.Random(0, heliExploreSpots.length - 1)]
                                    data["exploreTimer"] = this.localData.settings.fps * 5;
                                }
                            }
                        }
                    }
                    else if (data["bAirdrop"])
                    {
                        if (dist < data["distThreshold"])
                        {
                            var items = data.heliData["items"];
                            if (items && items.length > 0)
                            {
                                if (data["dropTimer"] > 0)
                                {
                                    data["dropTimer"]--;
                                }
                                else
                                {
                                    this.dropHelicopterCrate(_body);
                                    items.splice(0, 1);
                                    data["dropTimer"] = data["dropTimerMax"] ? data["dropTimerMax"] : (this.localData.settings.fps * 5);
                                }
                            }
                            else
                            {
                                if (data["defendTimer"] > 0)
                                {
                                    data["defendTimer"]--;
                                }
                                else
                                {
                                    console.log("Leave map");
                                    _body.shapes[0].collisionMask = (CollisionGroups.PROJECTILE | CollisionGroups.PROJECTILE_AIR);
                                    data["bDestinationReached"] = true;
                                    data["bDestroy"] = true;
                                    var mapWidth = this.getCurrentMapData().width;
                                    heliData["destination"] = [_body.position[0] > mapWidth * 0.5 ? mapWidth : 0, 0]; //Leave map
                                }
                            }
                        }
                    }

                    if (data["rocketTimerMax"] > 0)
                    {
                        if (data["rocketTimer"] > 0)
                        {
                            data["rocketTimer"]--;
                        }
                        else
                        {
                            data["rocketTimer"] = data["rocketTimerMax"];
                            data["weaponType"] = "rocket";
                        }
                    }
                    if (!data["bBurstDelay"])
                    {              
                        var bStunned = data["bDrone"] && data["bStunned"];
                        if (data["bWantsToFire"] && this.matchInProgress() && !bStunned)
                        {
                            if (!data["bFireDelay"] && !data["currentRocketId"])
                            {
                                switch (data["weaponType"])
                                {
                                    case "bullet":
                                        var numBullets = data["numBullets"] ? data["numBullets"] : 1;
                                        for (var i = 0; i < numBullets; i++)
                                        {
                                            var accuracy = data["accuracy"] != undefined ? data["accuracy"] : 0;
                                            this.createBullet(muzzlePos[0], muzzlePos[1], data["aimRotation"] + this.ToRad(this.Random(-accuracy, accuracy)), data["maxRange"], data["damage"], heliData["playerId"] ? heliData["playerId"] : data["id"], data["id"], data["killstreakId"], data["weaponData"], data["bPlayerControlled"], false, (this.localData["bSurvival"] && data["team"] == 0));
                                        }
                                        break;

                                    case "grenade":
                                        this.createGrenade(muzzlePos, {
                                            bImpact: true,
                                            team: data["team"],
                                            playerId: heliData["playerId"] ? heliData["playerId"] : data["id"],
                                            causerId: data["id"],
                                            rotation: data["aimRotation"],
                                            velocity: 1600,
                                            damage: data["damage"],
                                            weaponId: "thumper",
                                            killstreakId: data["killstreakId"],
                                            radius: 400
                                        });
                                        break;

                                    case "rocket":
                                        this.createRocket(muzzlePos, {
                                            type: Rocket.TYPE_DEFAULT,
                                            team: data["team"],
                                            playerId: heliData["playerId"] ? heliData["playerId"] : data["id"],
                                            causerId: data["id"],
                                            rotation: data["desiredAimRotation"],
                                            weaponId: data["killstreakId"],
                                            enemyId: data["rocketTimerMax"] ? data["currentEnemy"] : null
                                        });
                                        if (data["rocketTimerMax"])
                                        {
                                            data["weaponType"] = "bullet";
                                        }
                                        break;
                                }
                                if (!data["bUnlimitedAmmo"])
                                {
                                    data["ammo"]--;
                                }
                                data["fireDelayTimer"] = data["fireRate"];
                                var recoil = 2;
                                if (heliData["weaponId"])
                                {
                                    var weaponData = this.getWeaponData(heliData["weaponId"]);
                                    if (weaponData)
                                    {
                                        recoil = weaponData["recoil"];
                                    }
                                }
                                this.requestEvent({
                                    eventId: GameServer.EVENT_PAWN_ACTION,
                                    pawnId: data["id"],
                                    type: GameServer.PAWN_FIRE_WEAPON,
                                    recoil: recoil
                                });
                                this.emitAISound(muzzlePos, data["team"]);
                            }
                            if (data["bHasBurstDelay"])
                            {
                                if (data["burstTimer"] > 0)
                                {
                                    data["burstTimer"]--;
                                }
                                else
                                {
                                    data["burstDelayTimer"] = data["burstDelayTimerMax"];
                                    data["burstTimer"] = data["burstTimerMax"];
                                }
                            }
                        }
                    }
                }
                else
                {
                    if (_body["constraint"])
                    {
                        this.dropHelicopterCrate(_body);
                    }
                    if (!data["currentRocketId"])
                    {
                        if (!data["bDestroy"])
                        {
                            _body.fixedY = false; 
                            data["bDestroy"] = true;
                            if (data["bPlayerControlled"])
                            {
                                ps = this.getPlayerStateById(data["controllerId"]);
                                if (ps)
                                {
                                    this.clearPlayerControllable(ps);
                                }
                            }                            
                            if (data["bDrone"])
                            {
                                //data["health"] = 0;
                                //this.onPawnDeath(data["id"], data["health"], null, data["id"], { damageType: DamageType.DAMAGE_EXPLOSIVE }, false);
                                this.requestEvent({
                                    eventId: GameServer.EVENT_PAWN_DAMAGE,
                                    damageType: DamageType.DAMAGE_EXPLOSIVE,
                                    damageAmount: data["health"],
                                    pawnId: data["id"],
                                    attackerId: null,
                                    causerId: data["id"],
                                    weaponId: Killstreaks.KILLSTREAK_EMP,
                                    bDirectlyCausedByPlayer: false
                                });
                            }
                            else
                            {
                                console.log("Leave map");
                                _body.shapes[0].collisionMask = (CollisionGroups.PROJECTILE | CollisionGroups.PROJECTILE_AIR);
                                data["distThreshold"] = 200;
                                data["maxSpeed"] = 300;                                
                                var mapWidth = this.getCurrentMapData().width;
                                heliData["destination"] = [_body.position[0] > (mapWidth * 0.5) ? mapWidth : 0, 0];
                            }
                        }
                    }
                }
                break;
        }
        if (data["desiredAimRotation"] != undefined)
        {
            var target = this.WrapAngle(data["aimRotation"] - data["desiredAimRotation"], true);
            data["aimRotation"] -= target * data["aimSpeed"];
        }
        if (data["swayMax"] > 0)
        {
            if (data["swayDir"] == 1)
            {
                data["sway"]++;
                if (data["sway"] > data["swayMax"])
                {
                    data["swayDir"] = -1;
                }
            }
            else
            {
                data["sway"]--;
                if (data["sway"] < -data["swayMax"])
                {
                    data["swayDir"] = 1;
                }
            }
        }
        destination = heliData["destination"];
        if (destination)
        {
            var maxSpeed = data["maxSpeed"];
            var useDest = [destination[0], destination[1]];
            if (dist < (data["distThreshold"] + data["swayMax"]))
            {
                useDest[0] += data["sway"];
                useDest[1] += data["sway"];
            }
            var xDif = useDest[0] - _body.position[0];
            var vx = (xDif) - (_body.velocity[0] * data["heliVelocityXAdjust"]);
            var yDif = useDest[1] - _body.position[1];
            var vy = yDif - (_body.velocity[1] * 2);
            if (vx > 0)
            {
                vx = Math.min(vx, maxSpeed);
            }
            else
            {
                vx = Math.max(vx, -maxSpeed);
            }
            _body.applyForce([vx, vy], [0, 0]);
            this.constrainVelocity(_body, 500);
        }
        if (data["bDrone"])
        {
            _body.angularVelocity = -_body.angle * 10;
        }
        else
        {
            _body.angle = this.ToRad(_body.velocity[0] * data["angleMult"]);
            _body.position[1] = Math.min(_body.position[1], this.getHeliMaxY(data["bBot"]));
            _body.position[1] = Math.max(_body.position[1], 0);
        }
    }

    createBullet(_x, _y, _rotation, _range, _damage, _instigatorId, _causerId, _weaponId, _weaponData, _bDirectlyCausedByPlayer, _bMelee, _bIgnoreObstacles)
    {        
        var dist = _range;
        var vx = Math.cos(_rotation) * dist;
        var vy = Math.sin(_rotation) * dist;
        var causer = this.getObjectById(_causerId);
        var data = {
            eventId: GameServer.EVENT_SPAWN_BULLET,
            startX: Math.round(_x),
            startY: Math.round(_y),
            endX: Math.round(_x + vx),
            endY: Math.round(_y + vy),
            rotation: _rotation,
            team: causer ? causer.data["team"] : -1,
            damageAmount: _damage,
            controllerId: _instigatorId,
            causerId: _causerId,
            weaponId: _weaponId,
            weaponData: _weaponData
        }
        if (_bMelee) data.bMelee = true;
        if (_bDirectlyCausedByPlayer) data.bDirectlyCausedByPlayer = true;
        if (_bIgnoreObstacles) data.bIgnoreObstacles = true;
        if (this.hasMod(_weaponData, Mods.BARREL_SILENCER)) data.bSilenced = true;
        this.requestEvent(data);
    }

    createImpactEffects(_items)
    {
        if (this.localData["bMultiplayer"] && this.batchData.length >= Settings.BATCH_MAX)
        {
            return;
        }
        if (_items && _items.length > 0)
        {
            this.requestEvent({
                eventId: GameServer.EVENT_SPAWN_OBJECT,
                data: {
                    type: "impactEffect",
                    items: _items
                }
            });
        }
    }

    createImpactEffect(_x, _y, _rotation, _impactType, _intensity)
    {
        if (this.localData["bMultiplayer"] && this.batchData.length >= Settings.BATCH_MAX)
        {
            return;
        }
        this.requestEvent({
            eventId: GameServer.EVENT_SPAWN_OBJECT,
            data: {
                x: Math.round(_x),
                y: Math.round(_y),
                type: "impactEffect",
                rotation: this.RoundDecimal(_rotation),
                impactType: _impactType,
                intensity: _intensity
            }
        });
    }

    triggerCharacterJump(_body)
    {
        this.handlePlayerInput(_body, {
            keyId: "jump",
            value: true
        });
    }

    triggerMine(_body, _timer)
    {
        var data = _body.data;
        if (data["bJammed"])
        {
            return;
        }
        data["bTriggered"] = true;
        data["triggerTimer"] = _timer;  
        this.requestEvent({
            eventId: GameServer.EVENT_PAWN_ACTION,
            pawnId: data["id"],
            type: GameServer.PAWN_TRIGGER_MINE
        });
    }

    detonate(_body, _directHitId)
    {
        if (_body && _body.data)
        {
            var data = _body.data;
            if (data["bDetonated"])
            {
                return;
            }
            data["bDetonated"] = true;
            switch (data["type"])
            {
                case "obstacle":
                    if (data["obstacleId"] == "barrel_explosive")
                    {
                        this.createExplosion({
                            eventId: GameServer.EVENT_SPAWN_EXPLOSION,
                            x: _body.position[0],
                            y: _body.position[1],
                            radius: 400,
                            damage: 500,
                            playerId: data["playerId"] ? data["playerId"] : data["id"],
                            causerId: data["id"],
                            weaponId: "barrel",
                            bDirectlyCausedByPlayer: true,
                            directHitId: _directHitId
                        });
                        this.removeNextStep(_body);
                    }
                    break;

                case "equipment":
                    var weaponData = data["weaponData"];
                    if (weaponData)
                    {
                        var explosionX = _body.position[0];
                        var explosionY = _body.position[1] - 10;
                        switch (weaponData["id"])
                        {
                            case "claymore":
                                explosionX += 50 * data["scale"];
                                explosionY -= 10;
                                break;
                        }
                        this.createExplosion({
                            eventId: GameServer.EVENT_SPAWN_EXPLOSION,
                            x: explosionX,
                            y: explosionY,
                            radius: weaponData["radius"],
                            damage: weaponData["damage"],
                            playerId: data["ownerId"] ? data["ownerId"] : data["id"],
                            causerId: data["id"],
                            weaponId: weaponData["id"],
                            bDirectlyCausedByPlayer: true,
                            directHitId: _directHitId
                        });
                    }
                    this.removeNextStep(_body);
                    break;

                case "grenade":
                    var grenadeData = data["grenadeData"];
                    if (grenadeData["weaponId"] == "smoke")
                    {
                        this.emitAISound(_body.position);
                        _body.data["destroyTimer"] = this.localData.settings.fps * 8;
                        _body.data["bActivated"] = true;
                        this.pushObjectDataUpdate(_body.data["id"], ["bActivated"]);
                        this.createExplosion({
                            eventId: GameServer.EVENT_SPAWN_EXPLOSION,
                            x: _body.position[0],
                            y: _body.position[1],
                            radius: 200,
                            damage: 1,
                            playerId: grenadeData["playerId"] ? grenadeData["playerId"] : data["id"],
                            causerId: data["id"],
                            weaponId: grenadeData["weaponId"],
                            bDirectlyCausedByPlayer: true,
                            directHitId: _directHitId
                        });
                    }
                    else if (grenadeData["weaponId"] == "napalm" || grenadeData["weaponId"] == "molotov")
                    {
                        var weaponData = this.getWeaponData(grenadeData["weaponId"]);
                        var firePos = _body.previousPosition ? _body.previousPosition : _body.position;
                        this.createExplosion({
                            eventId: GameServer.EVENT_SPAWN_EXPLOSION,
                            x: firePos[0],
                            y: firePos[1],
                            radius: weaponData.radius,
                            damage: weaponData.damage,
                            playerId: grenadeData["playerId"] ? grenadeData["playerId"] : data["id"],
                            causerId: data["id"],
                            weaponId: grenadeData["weaponId"],
                            bDirectlyCausedByPlayer: true,
                            directHitId: _directHitId
                        });
                        var numFlames = 15;
                        for (var i = 0; i < numFlames; i++)
                        {
                            this.createFlame(_body.position, [this.Random(-500, 500), this.Random(-500, -100)], _body.data.team, grenadeData["playerId"] ? grenadeData["playerId"] : data["id"], grenadeData["weaponId"], null, weaponData.fireTime);
                        }
                        this.removeNextStep(_body);
                    }
                    else
                    {
                        if (data["minTimer"] > 0)
                        {
                            this.removeNextStep(_body);
                            this.createImpactEffect(_body.position[0], _body.position[1], _body.angle, "grenade", 1);
                        }
                        else
                        {
                            var grenadePos = _body.previousPosition;
                            if (grenadePos[0] === 0 && grenadePos[1] === 0)
                            {
                                grenadePos = _body.position;
                            }
                            grenadePos[1] -= 10;
                            var weaponId = grenadeData["killstreakId"] ? grenadeData["killstreakId"] : grenadeData["weaponId"];
                            this.createExplosion({
                                eventId: GameServer.EVENT_SPAWN_EXPLOSION,
                                x: grenadePos[0],
                                y: grenadePos[1],
                                radius: data["radius"],
                                damage: data["damage"],
                                playerId: grenadeData["playerId"] ? grenadeData["playerId"] : data["id"],
                                causerId: data["id"],
                                weaponId: weaponId,
                                bDirectlyCausedByPlayer: true
                            });
                            if (_body["constraint"])
                            {
                                this.localData.world.removeConstraint(_body["constraint"]);
                                delete _body["constraint"];
                            }
                            this.removeNextStep(_body);
                        }
                    }
                    break;

                case "rocket":
                    var rocketData = data["rocketData"];
                    var rocketPos = _body.previousPosition;
                    if (rocketPos[0] === 0 && rocketPos[1] === 0)
                    {
                        rocketPos = _body.position;
                    }
                    this.createExplosion({
                        eventId: GameServer.EVENT_SPAWN_EXPLOSION,
                        x: rocketPos[0],
                        y: rocketPos[1],
                        radius: data["radius"],
                        damage: data["damage"],
                        playerId: rocketData["playerId"] ? rocketData["playerId"] : data["id"],
                        causerId: data["id"],
                        weaponId: rocketData["weaponId"],
                        bDirectlyCausedByPlayer: true
                    });
                    switch (rocketData.type)
                    {
                        case Rocket.TYPE_NAPALM:
                            var numFlames = 10;
                            switch (rocketData["weaponId"])
                            {
                                case Killstreaks.KILLSTREAK_NAPALM:
                                    var flameTime = 15;
                                    break;
                                default:
                                    flameTime = 5;
                                    break;
                            }
                            for (var i = 0; i < numFlames; i++)
                            {
                                this.createFlame(_body.position, [this.Random(-500, 500), this.Random(-500, -100)], _body.data.team, rocketData["playerId"] ? rocketData["playerId"] : data["id"], rocketData["weaponId"], rocketData["weaponData"], flameTime);
                            }
                            break;
                    }
                    this.removeNextStep(_body);
                    break;

                case "crate":
                    if (data.interactData["type"] == Crate.CRATE_BOMB_GENERIC)
                    {
                        this.createExplosion({
                            eventId: GameServer.EVENT_SPAWN_EXPLOSION,
                            x: _body.position[0],
                            y: _body.position[1],
                            radius: 500,
                            damage: 500,
                            causerId: data["id"],
                            playerId: data["planterId"],
                            weaponId: "bomb" //Killstreaks.KILLSTREAK_DECOY
                        });
                        this.removeNextStep(_body);
                        var gameModeData = this.localData.gameModeData;
                        if (gameModeData["id"] == GameMode.OP_BOMB)
                        {
                            gameModeData["numBombs"]--;
                            this.onEvent({
                                eventId: GameServer.EVENT_GAME_UPDATE,
                                gameModeData: {
                                    numBombs: gameModeData["numBombs"]
                                }
                            });
                            if (gameModeData["numBombs"] === 0)
                            {
                                this.requestEvent({
                                    eventId: GameServer.EVENT_GAME_END,
                                    condition: MatchState.END_CONDITION_OBJECTIVE,
                                    winningTeam: 0
                                });
                            }
                        }
                    }
                    break;
            }
        }
    }

    removeNextStep(_body)
    {
        if (_body)
        {
            _body.data["bPendingRemoval"] = true;
            this.localData.toRemove.push(_body);
        }
    }

    createInfestor(_id, _position, _team, _infestorType)
    {
        var shared = this.getSharedData(_infestorType);
        var body = new this.p2.Body({
            mass: 1,
            fixedRotation: shared.fixedRotation,
            position: _position,
            damping: shared.damping,
            angularDamping: shared.angularDamping,
            allowSleep: true,
            sleepSpeedLimit: 1,
            sleepTimeLimit: 1
        });
        body.data = {
            id: _id,
            type: "infestor",
            infestorType: _infestorType,
            material: "flesh",
            damageMultipliers: {
                1: 1,
                2: 0.5,
                3: 1,
                4: 1.5
            },
            bZombie: true,
            health: 500,
            maxHealth: 500,
            team: _team,
            maxSpeed: shared.maxSpeed,
            jumpHeight: shared.jumpHeight,
            exposedTimer: 0,
            reloadTimer: 0,
            weapon: this.createWeaponObject(),
            currentInventoryIndex: 0,
            aimRotation: 0,
            aimSpeed: 0.5,
            aimSpeedMultiplier: 1,
            accuracyMultiplier: 1,
            reloadMultiplier: 1,
            speedMultiplier: 1,
            baseSpeedMultiplier: 1,
            desiredAimRotation: this.ToRad(this.RandomBoolean() ? 0 : 180),
            climbSpeedMultiplier: shared.climbSpeedMultiplier,
            xpReward: 200
        };

        var data = body.data;
        data["inventory"] = [this.getWeaponData(_infestorType)];
        this.setCharacterCurrentInventoryItem(body, 0);

        var shape = new this.p2.Box({
            width: shared.width,
            height: shared.height,
            collisionGroup: CollisionGroups.PAWN,
            collisionMask: CollisionGroups.GROUND | CollisionGroups.PLATFORM | CollisionGroups.PROJECTILE
        });
        body.addShape(shape);

        this.addWorldBody(body);
        return body;
    }

    createCharacter(_id, _position, _team, _avatarData, _inventory, _equipment, _perks)
    {
        var shared = this.getSharedData("character");
        var body = new this.p2.Body({
            mass: 1,
            fixedRotation: shared.fixedRotation,
            damping: shared.damping,
            position: _position,
            allowSleep: false
        });
        var charHealth = this.getCharacterHealth();
        body.data = {
            id: _id,
            type: "character",
            material: "flesh",
            damageMultipliers: {
                1: 1,
                2: 1,
                3: 1
            },
            health: charHealth,
            maxHealth: charHealth,
            team: _team,
            maxSpeed: shared.maxSpeed,
            climbSpeedMultiplier: shared.climbSpeedMultiplier,
            jumpHeight: shared.jumpHeight,
            avatarData: _avatarData,
            exposedTimer: 0,
            regenAmount: 1,
            regenTimer: 0,
            regenTimerMax: this.localData.settings.fps * 3,
            reloadTimer: 0,
            weapon: this.createWeaponObject(),
            currentInventoryIndex: 0,
            aimRotation: 0,
            aimSpeed: 0.2,
            aimSpeedMultiplier: 1,
            accuracyMultiplier: 1,
            reloadMultiplier: 1,
            desiredAimRotation: this.ToRad(this.RandomBoolean() ? 0 : 180),
            bRegenHealth: true,
            bUseExposeTimer: true,
            xpReward: 100,
            speedMultiplier: 1,
            baseSpeedMultiplier: 1,
            perks: []
        };

        if (_inventory)
        {
            var inventory = [];
            for (var i = 0; i < _inventory.length; i++)
            {
                var curItem = _inventory[i];
                var weaponData = this.getWeaponData(curItem["id"]);
                if (weaponData)
                {
                    if (curItem["mag"] != undefined)
                    {
                        weaponData["mag"] = curItem["mag"];
                    }
                    if (curItem["ammo"] != undefined)
                    {
                        weaponData["ammo"] = curItem["ammo"];
                    }
                    this.applyWeaponMods(weaponData, curItem["mods"]);
                    inventory.push(weaponData);
                }
            }
            body.data["inventory"] = inventory;
            this.setCharacterCurrentInventoryItem(body, 0);
        }
        else
        {
            console.warn("Character has no inventory");
        }
        if (_equipment)
        {
            body.data["equipment"] = this.getWeaponData(_equipment);
        }
        if (_perks)
        {
            body.data["perks"] = _perks;
            this.updateCharacterPerks(body);
        }

        var shape = new this.p2.Box({
            width: shared.width,
            height: shared.height,
            collisionGroup: CollisionGroups.PAWN,
            collisionMask: CollisionGroups.GROUND | CollisionGroups.PLATFORM | CollisionGroups.PROJECTILE
        });
        body.addShape(shape);

        shape.material = new this.p2.Material();
        var cm = new this.p2.ContactMaterial(
            shape.material,
            this.localData.materials["ground"],
            {
                friction: 0.5,
                restitution: 0
            }
        );
        this.localData.world.addContactMaterial(cm);

        this.addWorldBody(body);
        return body;
    }

    addWorldBody(_body)
    {
        var localData = this.localData;
        localData.world.addBody(_body);
        if (_body.data)
        {
            if (!_body.data.id)
            {                
                var newId = "a_" + this.getRandomUniqueId();
                _body.data.id = newId;
                console.warn("Missing id", _body.data, newId);
            }
            localData.objects[_body.data["id"]] = _body;
        }
    }

    hasMod(_weaponData, _modId)
    {        
        if (_weaponData && _modId)
        {
            switch (_modId)
            {
                case Mods.BARREL_SILENCER:
                    if (_weaponData.bSilenced)
                    {
                        return true;
                    }
                    break;
            }
            var mods = _weaponData["mods"];
            if (mods)
            {
                var keys = Object.keys(mods);
                for (var i = 0; i < keys.length; i++)
                {
                    let key = keys[i];
                    if (mods[key] == _modId)
                    {
                        return true;
                    }
                }
            }
        }
        else
        {
            //console.warn("Invalid weaponData or modId:", _weaponData, _modId);
        }
        return false;
    }

    applyWeaponMods(_weaponData, _mods, _pawnId)
    {
        var weaponData = _weaponData;
        weaponData["mods"] = {};
        if (_mods)
        {
            //Reset all weapon properties
            var defaultWeaponData = this.getWeaponData(_weaponData["id"]);

            var prevBarrelId = weaponData["barrelId"];
            var prevBarrelAmmo = weaponData["barrelAmmo"];

            delete weaponData["barrelId"];
            delete weaponData["barrelAmmo"];
            delete weaponData["barrelAmmoMax"];
            delete weaponData["bSlug"];
            delete weaponData["bSpeedLoader"];
            delete weaponData["bHighCaliber"];
            delete weaponData["bImpact"];

            weaponData["fireMode"] = defaultWeaponData["fireMode"];
            weaponData["accuracy"] = defaultWeaponData["accuracy"];
            weaponData["fireRate"] = defaultWeaponData["fireRate"];
            weaponData["burstFireRate"] = defaultWeaponData["burstFireRate"];
            weaponData["boltDelayTimer"] = defaultWeaponData["boltDelayTimer"];
            weaponData["recoil"] = defaultWeaponData["recoil"];
            weaponData["speedModifier"] = defaultWeaponData["speedModifier"];
            weaponData["range"] = defaultWeaponData["range"];
            weaponData["penetration"] = defaultWeaponData["penetration"];
            weaponData["damage"] = defaultWeaponData["damage"];
            weaponData["radius"] = defaultWeaponData["radius"];
            weaponData["magSize"] = defaultWeaponData["magSize"];
            weaponData["lookModifier"] = defaultWeaponData["lookModifier"];
            weaponData["headshotMultiplier"] = defaultWeaponData["headshotMultiplier"] ? defaultWeaponData["headshotMultiplier"] : 1;
            if (defaultWeaponData["bAirOnly"])
            {
                weaponData["bAirOnly"] = defaultWeaponData["bAirOnly"];
            }

            weaponData.mods[Mods.TYPE_BASE] = _mods[Mods.TYPE_BASE];
            var accuracyMult = (weaponData["type"] === Weapon.TYPE_SHOTGUN ? 0.9 : 0.6);
            var damperMult = 0.75;
            switch (_mods[Mods.TYPE_BASE])
            {
                case Mods.BASE_SHIELD_DAMAGE:
                    weaponData["damage"] = Math.round(defaultWeaponData["damage"] * 1.5);
                    break;
                case Mods.BASE_SHIELD_RAPID_FIRE:
                    switch (weaponData.id)
                    {
                        default:
                            weaponData["fireRate"] = Math.floor(defaultWeaponData["fireRate"] * 0.5);
                            break;
                    }
                    break;
                case Mods.BASE_DEADEYE:
                    weaponData["accuracy"] = Math.floor(defaultWeaponData["accuracy"] * accuracyMult);
                    break;
                case Mods.BASE_RAPID_FIRE:
                    if (weaponData["bZombie"])
                    {
                        weaponData["fireRate"] = Math.max(1, Math.round(defaultWeaponData["fireRate"] * 0.5));
                    }
                    else
                    {
                        weaponData["fireRate"] = Math.ceil(defaultWeaponData["fireRate"] < 10 ? (defaultWeaponData["fireRate"] - 1) : (defaultWeaponData["fireRate"] * 0.7));
                        weaponData["fireRate"] = Math.max(1, weaponData["fireRate"] - (weaponData["fireRate"] % (1 / this.localData.settings.fps_mult)));
                    }
                    if (weaponData["type"] != Weapon.TYPE_MELEE)
                    {                        
                        if (weaponData["bBoltAction"])
                        {
                            weaponData["boltDelayTimer"] = defaultWeaponData["boltDelayTimer"] * 0.8;
                        }
                        if (weaponData["burstFireRate"])
                        {
                            weaponData["burstFireRate"] = Math.ceil(defaultWeaponData["burstFireRate"] * 0.8);
                            weaponData["accuracy"] = defaultWeaponData["accuracy"] + 0.5;
                        }
                        else
                        {
                            var rapidMult = this.RoundDecimal(Math.max(0, 1 - (weaponData["fireRate"] * 0.05)));
                            if (this.localData["bSurvival"] || this.localData["bBattlezone"])
                            {
                                rapidMult *= 0.1;
                            }
                            weaponData["accuracy"] = defaultWeaponData["accuracy"] + rapidMult;
                            weaponData["recoil"] = Math.max(1, defaultWeaponData["recoil"]) + rapidMult;
                        }
                    }
                    if (!this.localData["bSurvival"])
                    {
                        if (weaponData["fireRate"] <= 4)
                        {
                            weaponData["damage"] = Math.round(weaponData["damage"] * 0.75);
                        }
                    }
                    break;
                case Mods.BASE_DAMPER:
                    weaponData["recoil"] = Math.floor(weaponData["recoil"] * damperMult);
                    break;
                case Mods.BASE_SPEED:
                    var speedAdd = 0.2;
                    if (weaponData["id"] == "riot_shield")
                    {
                        speedAdd = 0.25;
                    }
                    weaponData["speedModifier"] = defaultWeaponData["speedModifier"] + speedAdd;
                    break;
                case Mods.BASE_RANGE:
                    if (weaponData["bZombie"] || this.isMeleeWeapon(weaponData))
                    {
                        weaponData["range"] = defaultWeaponData["range"] + 20;
                    }
                    else if (weaponData.id == "flamethrower")
                    {                        
                        var numRange = 300;
                        var lookMod = 0.1;
                        weaponData["velocity"] = weaponData["velocity"] + numRange;
                    }
                    else
                    {
                        numRange = 200;
                        lookMod = 0.25;
                        switch (weaponData["type"])
                        {
                            case Weapon.TYPE_SNIPER:
                                lookMod = 0.1;
                                break;

                            case Weapon.TYPE_SHOTGUN:
                                numRange = 100;
                                lookMod = 0.2;
                                break;
                        }                        
                    }
                    if (numRange)
                    {
                        weaponData["range"] = defaultWeaponData["range"] + numRange;                        
                    }
                    if (lookMod)
                    {
                        weaponData["lookModifier"] = defaultWeaponData["lookModifier"] + lookMod;
                    }
                    break;

                case Mods.BASE_MODE_SELECTOR:
                    //...
                    break;

                case Mods.BASE_BURST_FIRE:
                    weaponData["fireMode"] = Weapon.MODE_BURST;
                    weaponData["fireRate"] = Math.max(1, Math.round((defaultWeaponData["fireRate"] - 1) * (defaultWeaponData["fireRate"] > 6 ? 0.6 : 0.8)));
                    weaponData["burstFireRate"] = Math.max(weaponData["type"] == Weapon.TYPE_LMG ? 20 : 18, Math.round(defaultWeaponData["fireRate"] * 3.2));
                    weaponData["accuracy"] = this.RoundDecimal(weaponData["accuracy"] * accuracyMult);
                    weaponData["recoil"] = this.RoundDecimal(weaponData["recoil"] * 0.8);
                    weaponData["range"] = weaponData["range"] + 100;
                    weaponData["lookModifier"] = weaponData["lookModifier"] + 0.15;
                    break;
                case Mods.BASE_FULL_AUTO:
                    var prevFireMode = weaponData["fireMode"];
                    weaponData["fireMode"] = Weapon.MODE_AUTO;
                    weaponData["fireRate"] = Math.ceil(defaultWeaponData["fireRate"] * 1.5);
                    if (this.localData["bSurvival"])
                    {
                        weaponData["recoil"] = weaponData["recoil"] + 1;
                        weaponData["accuracy"] = weaponData["accuracy"] + 1;
                    }
                    else
                    {
                        weaponData["recoil"] = weaponData["recoil"] + 2;
                        weaponData["accuracy"] = weaponData["accuracy"] + 2;
                        if (prevFireMode == Weapon.MODE_BURST)
                        {
                            weaponData["accuracy"] += 1;
                        }
                    }
                    break;
                case Mods.BASE_SINGLE_FIRE:
                    weaponData["fireMode"] = Weapon.MODE_SEMI;                    
                    if (weaponData["type"] == Weapon.TYPE_SHOTGUN)
                    {
                        weaponData["accuracy"] = this.RoundDecimal(weaponData["accuracy"] * 0.8);
                        weaponData["fireRate"] = this.RoundDecimal(defaultWeaponData["fireRate"] * 1.5);
                    }
                    else
                    {
                        weaponData["accuracy"] = this.RoundDecimal(weaponData["accuracy"] * accuracyMult);
                        weaponData["recoil"] = this.RoundDecimal(weaponData["recoil"] * 0.8);
                        weaponData["fireRate"] = defaultWeaponData["fireRate"] >= 8 ? 10 : 8;  
                    }
                    weaponData["range"] = weaponData["range"] + 100;
                    weaponData["lookModifier"] = weaponData["lookModifier"] + 0.15;
                    break;
            }
            var ps = this.getPlayerStateById(_pawnId);
            //if (ps && ps.bDev)
            var barrelKeys = [
                Mods.TYPE_BARREL,
                Mods.TYPE_BARREL + "2",
                Mods.TYPE_BARREL + "3"
            ];
            for (var i = 0; i < barrelKeys.length; i++)
            {
                let barrelKey = barrelKeys[i];
                if (barrelKey)
                {
                    weaponData.mods[barrelKey] = _mods[barrelKey];
                }
                else
                {
                    continue;
                }
                switch (_mods[barrelKey])
                {
                    case Mods.BARREL_SILENCER:
                        weaponData["recoil"] = Math.round(weaponData["recoil"] * 0.95);
                        break;
                    case Mods.BARREL_LASER:
                        weaponData["accuracy"] = Math.floor(weaponData["accuracy"] * accuracyMult);
                        break;
                    case Mods.BARREL_GRIP:
                    case Mods.BARREL_COMPENSATOR:
                        weaponData["recoil"] = Math.floor(weaponData["recoil"] * damperMult);
                        break;
                    case Mods.BARREL_BOOSTER:
                        weaponData["penetration"] = weaponData["penetration"] + (this.localData["bSurvival"] ? 2 : 1);
                        break;
                    case Mods.BARREL_ACCELERATOR:
                        weaponData["range"] = weaponData["range"] + 200;
                        weaponData["recoil"] += 0.2;
                        break;
                    case Mods.BARREL_GP25:
                        weaponData["barrelId"] = Mods.BARREL_GP25;
                        weaponData["barrelAmmo"] = 4;
                        weaponData["barrelAmmoMax"] = weaponData["barrelAmmo"];
                        break;
                    case Mods.BARREL_M203:
                        weaponData["barrelId"] = Mods.BARREL_M203;
                        weaponData["barrelAmmo"] = 4;
                        weaponData["barrelAmmoMax"] = weaponData["barrelAmmo"];
                        break;
                    case Mods.BARREL_MASTERKEY:
                        weaponData["barrelId"] = Mods.BARREL_MASTERKEY;
                        weaponData["barrelAmmo"] = 8;
                        weaponData["barrelAmmoMax"] = weaponData["barrelAmmo"];
                        break;
                }
            }
            if (weaponData["barrelId"] && weaponData["barrelId"] == prevBarrelId && prevBarrelAmmo)
            {
                weaponData["barrelAmmo"] = Math.min(prevBarrelAmmo, weaponData["barrelAmmoMax"]);
            }
            weaponData.mods[Mods.TYPE_AMMO] = _mods[Mods.TYPE_AMMO];
            switch (_mods[Mods.TYPE_AMMO])
            {
                case Mods.AMMO_PIERCING:
                    weaponData["penetration"] = weaponData["penetration"] + (this.localData["bSurvival"] ? 2 : 1);
                    break;
                case Mods.AMMO_FMJ:
                    var fmjMult = 1.2;
                    if (weaponData["bZombie"])
                    {
                        fmjMult = 1.5;
                    }
                    else if (this.localData["bSurvival"])
                    {
                        fmjMult = 1.8;
                    }
                    weaponData["damage"] = Math.round(defaultWeaponData["damage"] * fmjMult);
                    break;
                case Mods.AMMO_EXTENDED:                
                    switch (weaponData.id)
                    {
                        default:
                            weaponData["magSize"] = Math.floor(defaultWeaponData["magSize"] * 1.5);   
                            break;
                    }
                    weaponData["mag"] = weaponData["magSize"];
                    break;
                case Mods.AMMO_HOLLOW_POINT:
                    var hsMult = defaultWeaponData["headshotMultiplier"] ? defaultWeaponData["headshotMultiplier"] : 1;
                    weaponData["headshotMultiplier"] = hsMult + (this.localData["bSurvival"] ? 1.5 : 0.5);
                    break;
                case Mods.AMMO_LAUNCHER_RADIUS:
                    if (weaponData["type"] == Weapon.TYPE_LAUNCHER)
                    {
                        weaponData["radius"] = defaultWeaponData["radius"] + (this.localData.bSurvival ? 200 : 100);
                    }
                    else
                    {
                        /*
                        weaponData["mag"] = weaponData["magSize"] = 100;
                        weaponData["ammo"] = weaponData["mag"];
                        weaponData["fireRate"] = 0;
                        weaponData["fireMode"] = Weapon.MODE_AUTO;
                        weaponData["speedModifier"] = 2;
                        weaponData["recoil"] = 0.001;
                        weaponData["bBoltAction"] = false;
                        var char = this.getObjectById(_pawnId);
                        if (char)
                        {
                            
                        }
                        */
                    }
                    break;
                case Mods.AMMO_LAUNCHER_EXPLOSIVE:
                    if (weaponData["type"] == Weapon.TYPE_LAUNCHER)
                    {
                        weaponData["damage"] = Math.round(defaultWeaponData["damage"] * (this.localData.bSurvival ? 5 : 1.4));
                    }
                    else
                    {
                        /*
                        weaponData["radius"] = 150;
                        weaponData["bRocket"] = true;
                        */
                    }
                    break;
                case Mods.AMMO_SLUG:
                    if (weaponData["type"] == Weapon.TYPE_SHOTGUN)
                    {
                        weaponData["damage"] = Math.round(defaultWeaponData["damage"] * (this.localData["bSurvival"] ? 10 : 5));
                        weaponData["accuracy"] = Math.round(defaultWeaponData["accuracy"] * 0.5);
                        weaponData["recoil"] += 0.5;
                        weaponData["bSlug"] = true;
                        weaponData["range"] = weaponData["range"] - 100;
                    }
                    break;
                case Mods.AMMO_SPEED_LOADER:
                    if (weaponData["bSingleRoundLoaded"])
                    {
                        weaponData["bSpeedLoader"] = true;
                    }
                    break;
                case Mods.AMMO_HIGH_CALIBER:
                    weaponData["bHighCaliber"] = true;
                    break;
                case Mods.AMMO_IMPACT:
                    weaponData["bImpact"] = true;
                    break;
                case Mods.AMMO_NAPALM:
                    if (weaponData["type"] == Weapon.TYPE_LAUNCHER)
                    {
                        weaponData["rocketType"] = Rocket.TYPE_NAPALM;
                        if (!this.localData["bSurvival"])
                        {
                            weaponData["damage"] = Math.round(weaponData["damage"] * 0.5);
                        }
                        weaponData["fireDamage"] = 15;
                        weaponData["fireTime"] = 6;
                    }
                    else
                    {
                        weaponData["bFlame"] = true;
                    }
                    break;
            }
        }
    }

    createRocket(_position, _rocketData)
    {
        var body = new this.p2.Body({
            mass: 0.1,
            position: _position,
            angle: _rocketData["rotation"],
            gravityScale: 0
        });
        var damage = 0;
        var radius = 0;
        var velocity = 0;
        var bControllable = false;
        var bAirOnly = false;
        var weaponId = _rocketData["weaponId"];
        var localData = this.localData;
        var destroyTimer = this.localData.settings.fps * 5;
        switch (weaponId)
        {
            case Killstreaks.KILLSTREAK_HELLFIRE:
                destroyTimer = this.localData.settings.fps * 10;
                damage = localData["bSurvival"] ? 3000 : 1000;
                radius = 500;
                velocity = 0;
                bControllable = true;
                break;

            case Killstreaks.KILLSTREAK_REAPER:
                damage = localData["bSurvival"] ? 1000 : 500;
                radius = localData["bSurvival"] ? 600 : 300;
                velocity = 200;
                break;

            case Killstreaks.KILLSTREAK_COBRA_CONTROLLABLE:
                damage = localData["bSurvival"] ? 500 : 300;
                radius = 400;
                velocity = 200;
                break;

            case Killstreaks.KILLSTREAK_PAVE_LOW:
                damage = 500;
                radius = 400;
                velocity = 200;
                var bAutoLock = true;
                break;

            case Killstreaks.KILLSTREAK_AIRSTRIKE:
                damage = localData["bSurvival"] ? 800 : 300;
                radius = 400;
                velocity = 150;
                break;

            case Killstreaks.KILLSTREAK_NAPALM:
                damage = localData["bSurvival"] ? 500 : 200;
                radius = 300;
                velocity = 150;
                break;

            case Killstreaks.KILLSTREAK_BOMBARDMENT:
                damage = localData["bSurvival"] ? 800 : 300;
                radius = 500;
                velocity = 200;
                break;

            case Killstreaks.KILLSTREAK_STEALTH_BOMBER:
                damage = localData["bSurvival"] ? 1000 : 350;
                radius = 450;
                velocity = 200;
                break;

            case Killstreaks.KILLSTREAK_SAM_TURRET:
                damage = this.localData["bSurvival"] ? 250 : 500;
                radius = 100;
                velocity = 150;
                bAutoLock = true;
                break;

            case "javelin":
                var weaponData = this.getWeaponData(weaponId);
                damage = _rocketData["damage"] ? _rocketData["damage"] : weaponData["damage"];
                radius = _rocketData["radius"] ? _rocketData["radius"] : weaponData["radius"];
                velocity = 50;
                var path = _rocketData["path"];
                bAirOnly = _rocketData["bAirOnly"];
                break;

            default:
                var weaponData = this.getWeaponData(weaponId);
                damage = _rocketData["damage"] ? _rocketData["damage"] : weaponData["damage"];
                radius = _rocketData["radius"] ? _rocketData["radius"] : weaponData["radius"];
                bAirOnly = _rocketData["bAirOnly"];
                bControllable = weaponData["bControllable"];
                velocity = 150;
                break;
        }
        body.data = {
            id: this.getRandomUniqueId(),
            destroyTimer: destroyTimer,
            type: "rocket",
            damage: damage,
            radius: radius,
            team: _rocketData["team"],
            rocketData: _rocketData
        };
        if (path)
        {
            body.data["path"] = path;
        }
        if (bAutoLock)
        {
            body.data["bAutoLock"] = true;
        }
        if (bControllable)
        {
            body.data["bControllable"] = bControllable;
            body.data["health"] = 20;
        }
        var shape = new this.p2.Box({
            width: 20,
            height: 8,
            collisionGroup: CollisionGroups.PROJECTILE,
            collisionMask: CollisionGroups.GROUND | CollisionGroups.PAWN | CollisionGroups.PAWN_AIR | CollisionGroups.DRONE
        });
        shape.sensor = true;
        if (weaponId == Killstreaks.KILLSTREAK_SAM_TURRET)
        {
            shape.collisionGroup = CollisionGroups.PROJECTILE_AIR;
            shape.collisionMask = CollisionGroups.PAWN_AIR | CollisionGroups.DRONE;
        }
        body.addShape(shape);
        this.addWorldBody(body);

        if (velocity)
        {
            var rad = _rocketData["rotation"];
            body.applyImpulse([Math.cos(rad) * velocity, Math.sin(rad) * velocity], 0, 0);
        }

        if (bAirOnly)
        {
            var pawn = this.getObjectById(_rocketData["playerId"]);
            if (pawn)
            {
                body.data.rocketData["enemyId"] = pawn.data["lockOnTargetId"];
            }
        }
        if (bControllable)
        {
            var ps = this.getPlayerStateById(_rocketData["playerId"]);
            if (ps)
            {
                body.data["team"] = ps["team"];
                this.setPlayerControllable(ps, body);
            }
        }

        this.requestEvent({
            eventId: GameServer.EVENT_SPAWN_ROCKET,
            position: body.position,
            velocity: body.velocity,
            angularVelocity: body.angularVelocity,
            rotation: body.angle,
            data: body.data
        });
        return body;
    }

    createProjectile(_position, _rotation, _team, _projectileData)
    {
        var localData = this.localData;
        var body = new this.p2.Body({
            mass: 0.1,
            position: _position,
            angle: _rotation,
            angularDamping: 0.2
        });
        var weaponData = this.getWeaponData(_projectileData["weaponId"]);
        body.data = {
            id: this.getRandomUniqueId(),
            type: "projectile",
            team: _team,
            damage: weaponData["damage"],
            projectileData: _projectileData,
        };
        var bCollidePawns = true;
        switch (weaponData["id"])
        {
            case "crossbow":
                var shape = new this.p2.Box({
                    width: 30,
                    height: 10
                });
                body.gravityScale = 0.25;
                break;

            case "knife":
                shape = new this.p2.Circle({
                    radius: 10
                });
                body.gravityScale = 0.5;
                break;

            default:
                shape = new this.p2.Circle({
                    radius: 10
                });
                break;
        }        
        shape.sensor = true;
        shape.collisionGroup = CollisionGroups.PROJECTILE;
        shape.collisionMask = bCollidePawns ? (CollisionGroups.SHIELD | CollisionGroups.GROUND | CollisionGroups.PAWN | CollisionGroups.PAWN_AIR | CollisionGroups.DRONE) : (CollisionGroups.SHIELD | CollisionGroups.GROUND | CollisionGroups.PAWN_AIR | CollisionGroups.DRONE)
        body.addShape(shape);
        this.addWorldBody(body);

        var rad = _projectileData["rotation"];
        var speed = _projectileData["velocity"];
        body.applyImpulse([Math.cos(rad) * speed, Math.sin(rad) * speed], 0, 0);

        this.requestEvent({
            eventId: GameServer.EVENT_SPAWN_PROJECTILE,
            position: body.position,
            rotation: body.angle,
            velocity: body.velocity,
            angularVelocity: body.angularVelocity,
            data: body.data
        });

        return body;
    }

    isInSmoke(_body)
    {
        if (_body)
        {
            var grenades = this.getSmokeGrenades();
            for (var i = 0; i < grenades.length; i++)
            {
                var grenade = grenades[i];
                var dist = this.Dist(grenade.position[0], grenade.position[1], _body.position[0], _body.position[1]);
                if (dist <= this.getSharedData("smokeSize"))
                {
                    return true;
                }
            }
        }
        return false;
    }

    createFlame(_position, _velocity, _team, _playerId, _weaponId, _weaponData = null, _time = 5, _bFromWeapon = false)
    {
        var body = new this.p2.Body({
            mass: 1,
            fixedRotation: true,
            position: _position,
            velocity: _velocity,
            damping: _bFromWeapon ? 0.92 : 0.8,
            allowSleep: true,
            sleepSpeedLimit: 10
        });
        body.data = {
            id: this.getRandomUniqueId(),
            x: _position[0],
            y: _position[1],
            type: "flame",
            team: _team,
            damage: 10,
            playerId: _playerId,
            weaponId: _weaponId,
            destroyTimer: Math.round(this.localData.settings.fps * _time),
            ticker: 20 * this.localData.settings.fps_mult,
            bFromWeapon: _bFromWeapon
        };
        if (!this.localData.bMultiplayer)
        {
            body.data.ticker = this.localData.settings.fps;
        }
        if (_bFromWeapon)
        {
            body.data.cooldownTimer = 5;
        }
        switch (_weaponId)
        {
            case Killstreaks.KILLSTREAK_NAPALM:
                body.data.damage = 20;
                break;

            default:
                var weaponData = _weaponData ? _weaponData : this.getWeaponData(_weaponId);
                if (weaponData)
                {
                    body.data.damage = weaponData.fireDamage ? weaponData.fireDamage : weaponData.damage;
                }
                break;
        }
        var collisionGroup = CollisionGroups.FLAME;
        var collisionMask = CollisionGroups.GROUND;
        var shape = new this.p2.Circle({
            radius: 20,
            collisionGroup: collisionGroup,
            collisionMask: collisionMask
        });
        body.addShape(shape);

        var flames = this.getFlames();
        if (flames.length > Settings.FLAMES_MAX)
        {
            this.removeNextStep(flames[0]);
        }

        this.addWorldBody(body);
        this.onEvent({
            eventId: GameServer.EVENT_SPAWN_OBJECT,
            data: body.data
        });
        return body;
    }

    createGrenade(_position, _grenadeData, _bMinimumDistance)
    {
        var localData = this.localData;
        var body = new this.p2.Body({
            mass: 1,
            position: _position,
            damping: 0.2,
            angularDamping: 0.7,
            allowSleep: true,
            sleepSpeedLimit: 5,
            sleepTimeLimit: 1
        });
        var weaponData = _grenadeData["weaponData"] ? _grenadeData["weaponData"] : this.getWeaponData(_grenadeData["weaponId"]);
        var bRemoteDetonation = weaponData ? weaponData["bRemoteDetonation"] : false;
        body.data = {
            id: this.getRandomUniqueId(),
            type: "grenade",
            team: _grenadeData["team"],
            damage: _grenadeData["damage"] ? _grenadeData["damage"] : weaponData["damage"],
            radius: _grenadeData["radius"] ? _grenadeData["radius"] : weaponData["radius"],
            bDetonationTimerEnabled: !_grenadeData["bStartDetonationAfterHit"],
            detonationTimer: (weaponData ? weaponData["detonationTimer"] : this.localData.settings.fps) * this.localData.settings.fps_mult,
            bRemoteDetonation: bRemoteDetonation,
            grenadeData: _grenadeData
        };
        if (_bMinimumDistance)
        {
            if (!this.localData["bSurvival"])
            {
                body.data["minTimer"] = 10 * this.localData.settings.fps_mult;
            }
        }
        var bCollidePawns = _grenadeData["bImpact"] || weaponData["bCollidePawns"];
        //var bCollidePawns = !_grenadeData["bIgnorePawns"];
        var size = 20;
        if (bRemoteDetonation)
        {
            body.data.bDetonationTimerEnabled = false;
            body.allowSleep = false;
            body.data["health"] = 1;
            var shape = new this.p2.Box({
                width: size,
                height: size
            });
        }
        else
        {
            var shape = new this.p2.Box({
                width: size,
                height: size
            });
        }
        if (_grenadeData["bImpact"])
        {
            shape.sensor = true;
        }
        shape.collisionGroup = CollisionGroups.PROJECTILE;        
        if (bCollidePawns)
        {
            shape.collisionMask = CollisionGroups.GROUND | CollisionGroups.PAWN | CollisionGroups.PAWN_AIR | CollisionGroups.SHIELD | CollisionGroups.DRONE | CollisionGroups.CAR;
        }
        else if (bRemoteDetonation)
        {
            shape.collisionMask = CollisionGroups.GROUND | CollisionGroups.PLATFORM | CollisionGroups.SHIELD | CollisionGroups.DRONE | CollisionGroups.CAR;
        }
        else
        {
            shape.collisionMask = CollisionGroups.GROUND | CollisionGroups.SHIELD | CollisionGroups.DRONE;
        }
        body.addShape(shape);
        var world = localData.world;
        this.addWorldBody(body);

        shape.material = new this.p2.Material();
        var cm = new this.p2.ContactMaterial(
            shape.material,
            localData.materials["ground"],
            {
                friction: 1,
                restitution: bRemoteDetonation ? 0.1 : 0.25,
                stiffness: Number.MAX_VALUE
            }
        );
        world.addContactMaterial(cm);

        var rad = _grenadeData["rotation"];
        var speed = _grenadeData["velocity"];
        body.angularVelocity = (speed * 0.01);
        body.applyImpulse([Math.cos(rad) * speed, Math.sin(rad) * speed], 0, 0);

        this.requestEvent({
            eventId: GameServer.EVENT_SPAWN_GRENADE,
            position: body.position,
            velocity: body.velocity,
            angularVelocity: body.angularVelocity,
            data: body.data
        });

        return body;
    }

    createTurret(_id, _position, _scale, _team, _turretData)
    {
        var shared = this.getSharedData(_turretData["type"]);
        var body = new this.p2.Body({
            mass: 1,
            position: _position,
            damping: shared.damping,
            angularDamping: shared.angularDamping,
            allowSleep: true,
            sleepSpeedLimit: 5,
            sleepTimeLimit: 1,
            velocity: [0, 1]
        });
        body.data = {
            id: _id,
            x: _position[0],
            y: _position[1],
            type: "turret",
            material: "metal",
            damageMultipliers: {
                1: 0.2,
                2: this.localData["bSurvival"] ? 1 : 2,
                3: 1,
                4: 0.1
            },
            scale: _scale,
            team: _team,
            aimRotation: this.ToRad(-90),
            desiredAimRotation: this.ToRad(-90),
            aimPos: [0, 0],
            aimSpeed: 0.2 / this.localData.settings.fps_mult,
            bWantsToFire: false,
            bFireDelay: false,
            fireDelayTimer: 0,
            accuracy: 2,
            bAutomated: true,
            fireRate: 1,
            weaponType: "bullet",
            maxRange: 1250,
            enemyTypes: null,
            bLimitScale: true,
            bUnlimitedAmmo: _turretData["bUnlimitedAmmo"],
            turretData: _turretData,
            muzzleOffsetY: -(shared.height * 0.5),
            xpReward: 100,
            bUseExposeTimer: !this.localData["bSurvival"] && !this.localData["bSandbox"] && !this.isTutorial(),
            bLOS: true
        };
        var data = body.data;
        data["bExposed"] = !data["bUseExposeTimer"];        
        var health = 200;
        switch (_turretData["type"])
        {
            case Turret.TYPE_SAM:
                data["aimSpeed"] = 0.5;
                data["killstreakId"] = Killstreaks.KILLSTREAK_SAM_TURRET;
                data["fireRate"] = this.localData.settings.fps * 3;
                data["ammo"] = 10;
                data["accuracy"] = 0;
                data["weaponType"] = "rocket";
                data["maxRange"] = 4000;
                data["enemyTypes"] = ["helicopter"];
                data["bLimitScale"] = false;
                data["bLOS"] = false;
                break;

            case Turret.TYPE_SENTRY:
                data["killstreakId"] = Killstreaks.KILLSTREAK_SENTRY_GUN;
                data["fireRate"] = Math.round(4 * this.localData.settings.fps_mult);
                data["ammo"] = 1000;
                data["maxRange"] = this.localData["bSurvival"] ? 2000 : (this.localData["bOperation"] ? 1250 : 1500);
                data["weaponType"] = "bullet";
                data["damage"] = 30;
                data["enemyTypes"] = ["character", "infestor"];
                break;

            case Turret.TYPE_REMOTE:
                data["killstreakId"] = Killstreaks.KILLSTREAK_REMOTE_TURRET;
                data["accuracy"] = 3;
                data["bAutomated"] = false;
                data["maxRange"] = 1800;
                data["fireRate"] = Math.floor(3 * this.localData.settings.fps_mult);
                data["ammo"] = 500;
                data["weaponType"] = "bullet";
                data["damage"] = 40;
                data["muzzleOffsetY"] -= 12;
                health = 100;
                break;

            case Turret.TYPE_BALLISTIC:
                data["killstreakId"] = Killstreaks.KILLSTREAK_ADVANCED_TURRET;
                data["accuracy"] = 1;
                data["bAutomated"] = false;
                data["maxRange"] = 2000;
                data["fireRate"] = Math.round(10 * this.localData.settings.fps_mult);
                data["ammo"] = this.localData["bModeGame"] ? 100 : 250;
                data["weaponType"] = "bullet";
                data["damage"] = this.localData["bModeGame"] ? 60 : 200;
                break;

            case Turret.TYPE_GRENADE:
                data["killstreakId"] = Killstreaks.KILLSTREAK_GRENADE_TURRET;
                data["accuracy"] = 1;
                data["bAutomated"] = false;
                data["maxRange"] = 2000;
                data["fireRate"] = Math.round(20 * this.localData.settings.fps_mult);
                data["ammo"] = this.localData["bModeGame"] ? 50 : 100;
                data["weaponType"] = "grenade";
                data["damage"] = this.localData["bModeGame"] ? 200 : 800;
                break;
        }
        if (data["bAutomated"])
        {
            data["ticker"] = 0;
        }
        data["health"] = data["maxHealth"] = health;
        data["ammoMax"] = data["ammo"];
        var shape = new this.p2.Box({
            width: shared.width,
            height: shared.height,
            collisionGroup: CollisionGroups.PAWN,
            collisionMask: CollisionGroups.GROUND | CollisionGroups.PLATFORM | CollisionGroups.PROJECTILE
        });
        body.addShape(shape);

        this.addWorldBody(body);
        this.requestEvent({
            eventId: GameServer.EVENT_SPAWN_TURRET,
            position: body.position,
            velocity: body.velocity,
            angularVelocity: body.angularVelocity,
            rotation: body.angle,
            data: body.data
        });

        var playerId = _turretData["playerId"];
        if (playerId)
        {
            var turrets = this.getTurrets(playerId, _turretData["type"]);
            if (turrets.length > Settings.TURRETS_MAX)
            {
                this.removeNextStep(turrets[0]);
            }
        }

        return body;
    }

    createSpawner(_x, _y, _data)
    {
        var body = new this.p2.Body({
            mass: 0,
            position: [_x, _y]
        });
        body.data = {
            id: this.getRandomUniqueId(),
            type: "spawner",
            team: _data["team"],
            spawnerId: _data["spawnerId"],
            timerMax: this.localData.settings.fps * (this.localData.bOperation ? 4 : 3),
            timer: 0
        };
        this.addWorldBody(body);
        return body;
    }

    createCar(_position, _team, _data)
    {
        var body = new this.p2.Body({
            mass: 1,
            position: _position,
            damping: 0,
            angularDamping: 0.2,
            allowSleep: true,
            sleepSpeedLimit: 5,
            sleepTimeLimit: 1,
            gravityScale: 2
        });
        var bControllable = true;
        body.data = {
            id: this.getRandomUniqueId(),
            type: "car",
            carType: _data.carType,
            material: "metal",
            damageMultipliers: {
                1: 1,
                2: 1,
                3: 10,
                4: 10
            },
            team: _team,
            carData: _data,
            healthMax: 100,
            moveX: 0,
            bBot: _data.bBot,
            killstreakId: Killstreaks.KILLSTREAK_RCXD,
            xpReward: 100
        };
        body.data.health = body.data.healthMax;
        var shared = this.getSharedData(_data.carType);
        var shape = new this.p2.Box({
            width: shared.width,
            height: shared.height,
            collisionGroup: CollisionGroups.CAR,
            collisionMask: CollisionGroups.GROUND | CollisionGroups.PLATFORM | CollisionGroups.PROJECTILE | CollisionGroups.PROJECTILE_AIR
        });
        body.addShape(shape);
        this.addWorldBody(body);
        this.requestEvent({
            eventId: GameServer.EVENT_SPAWN_OBJECT,
            position: body.position,
            data: body.data
        });
        if (bControllable)
        {
            var ps = this.getPlayerStateById(_data["playerId"]);
            if (ps)
            {
                body.data["team"] = ps["team"];
                this.setPlayerControllable(ps, body);
            }
        }
        return body;
    }

    createHelicopter(_position, _team, _heliData)
    {
        var body = new this.p2.Body({
            mass: 1,
            position: _position,
            gravityScale: 0
        });
        body.data = {
            id: this.getRandomUniqueId(),
            type: "helicopter",
            material: "metal",
            damageMultipliers: {
                1: 0.5,
                2: 0.9,
                3: 2,
                4: 0.1
            },
            sway: this.Random(0, 99),
            swayDir: this.RandomBoolean() ? 1 : -1,
            swayMax: 100,
            team: _team,
            moveSpeed: 600,
            maxSpeed: 300,
            weaponType: "bullet",
            bBot: true,
            distThreshold: 60,
            heliVelocityXAdjust: 1.5,
            aimRotation: this.ToRad(0),
            aimSpeed: 0.2 / this.localData.settings.fps_mult,
            aimPos: [0, 0],
            heliData: _heliData,
            angleMult: 0.015
        };
        var data = body.data;
        var bSurvivalAlly = false;
        if (_team == 0 && this.localData["bSurvival"])
        {
            bSurvivalAlly = true;
            data.damageMultipliers[DamageType.DAMAGE_BULLET] = 0.25;
        }
        data["killReward"] = _heliData["killReward"];
        var health = 100;
        var bControllable = false;
        switch (_heliData["type"])
        {
            case Helicopter.TYPE_MH6:
                health = 750;
                data["heliVelocityXAdjust"] = 2;
                data["behaviour"] = "deliver";
                data["xpReward"] = 100;
                break;

            case Helicopter.TYPE_MH6_ATTACK:
                health = this.localData["bSurvival"] ? 750 : 1250;
                data["bUseTimer"] = this.localData["bModeGame"];
                data["heliVelocityXAdjust"] = 0.5;
                data["killstreakId"] = Killstreaks.KILLSTREAK_MH6;
                data["muzzleOffsetX"] = 70;
                data["muzzleOffsetY"] = 15;
                data["fireDelayTimer"] = 0;
                data["fireRate"] = Math.round(4 * this.localData.settings.fps_mult);
                data["damage"] = bSurvivalAlly ? 40 : 20;
                data["accuracy"] = 5;
                data["ammo"] = 1000;
                data["maxRange"] = 2000;
                data["behaviour"] = "attack";
                data["bDefendOwner"] = true;
                data["bHasBurstDelay"] = true;
                data["burstTimerMax"] = this.localData.settings.fps * 2;
                data["burstDelayTimerMax"] = this.localData.settings.fps * 2;
                data.heliData["weaponId"] = "skorpion";
                data.heliData["style"] = Helicopter.TYPE_MH6;
                break;

            case Helicopter.TYPE_MH6_GRENADE:
                health = 1000;
                data["weaponType"] = "grenade";
                data["bBot"] = false;
                data["bUseTimer"] = this.localData["bModeGame"];
                data["bPlayerControlled"] = true;
                data["distThreshold"] = 300;
                data["killstreakId"] = Killstreaks.KILLSTREAK_MH6_GRENADE;
                data["muzzleOffsetX"] = 70;
                data["muzzleOffsetY"] = 12;
                data["fireDelayTimer"] = 0;
                data["fireRate"] = Math.round(15 * this.localData.settings.fps_mult);
                data["damage"] = this.localData["bSurvival"] ? 500 : 200;
                data["accuracy"] = 5;
                data["ammo"] = this.localData["bSurvival"] ? (this.localData["bUseMoneyMultiplier"] ? 200 : 100) : 60;
                data["maxRange"] = 2000;
                data["behaviour"] = "attack";
                data.heliData["weaponId"] = "mgl";
                data.heliData["style"] = Helicopter.TYPE_MH6;
                bControllable = true;
                break;

            case Helicopter.TYPE_SCOUT:
                health = 2000;
                //data["bExplore"] = true;
                //data["exploreTimer"] = 0;
                data["moveSpeed"] = 500;
                data["bBot"] = false;
                data["bPlayerControlled"] = true;
                data["bUseTimer"] = this.localData["bModeGame"];
                data["distThreshold"] = 300;
                data["killstreakId"] = Killstreaks.KILLSTREAK_SCOUT;
                data["muzzleOffsetX"] = 170;
                data["muzzleOffsetY"] = 40;
                data["fireDelayTimer"] = 0;
                data["fireRate"] = Math.round(12 * this.localData.settings.fps_mult);
                data["damage"] = bSurvivalAlly ? 150 : 80;
                data["accuracy"] = 2;
                data["ammo"] = this.localData["bSurvival"] ? 500 : 200;
                data["maxRange"] = 2250;
                data["bMaxLookRange"] = true;
                data["behaviour"] = "attack";
                data.heliData["weaponId"] = "samr";
                data["xpReward"] = 200;
                bControllable = true;
                break;

            case Helicopter.TYPE_COBRA:
                health = 1500;
                data["bUseTimer"] = this.localData["bModeGame"];
                //data["timer"] = this.localData.settings.fps * 90;
                data["heliVelocityXAdjust"] = 2;
                data["killstreakId"] = Killstreaks.KILLSTREAK_COBRA;
                data["muzzleOffsetX"] = 140;
                data["muzzleOffsetY"] = 45;
                data["fireDelayTimer"] = 0;
                data["fireRate"] = Math.round(4 * this.localData.settings.fps_mult);
                data["damage"] = bSurvivalAlly ? 45 : 25;
                data["accuracy"] = 3;
                data["ammo"] = 1000;
                data["maxRange"] = 1500;
                data["behaviour"] = "attack";
                data["bDefendOwner"] = true;
                data["bHasBurstDelay"] = true;
                data["burstTimerMax"] = this.localData.settings.fps * 1.5;
                data["burstDelayTimerMax"] = this.localData.settings.fps * 2;
                data.heliData["weaponId"] = "m249";
                data.heliData["style"] = Helicopter.TYPE_COBRA;
                data["xpReward"] = 200;
                break;

            case Helicopter.TYPE_COBRA_CONTROLLABLE:
                health = 2000;
                data["bBot"] = false;
                data["bUseTimer"] = this.localData["bModeGame"];
                data["bPlayerControlled"] = true;
                data["distThreshold"] = 300;
                data["killstreakId"] = Killstreaks.KILLSTREAK_COBRA_CONTROLLABLE;
                data["muzzleOffsetX"] = 140;
                data["muzzleOffsetY"] = 45;
                data["fireDelayTimer"] = 0;
                data["fireRate"] = Math.round(2 * this.localData.settings.fps_mult);
                data["damage"] = this.localData["bSurvival"] ? (this.localData["bUseMoneyMultiplier"] ? 320 : 160) : 40;
                data["accuracy"] = 3;
                data["ammo"] = this.localData["bModeGame"] ? 500 : 1500;
                data["rockets"] = this.localData["bSurvival"] ? 10 : 5;                
                data["maxRange"] = 2000;
                data["behaviour"] = "attack";
                data.heliData["weaponId"] = "ak47";
                data.heliData["style"] = Helicopter.TYPE_COBRA;
                bControllable = true;
                break;

            case Helicopter.TYPE_REAPER:
                health = 1000;
                data["angleMult"] = 0.025;
                data["swayMax"] = 50;
                data["weaponType"] = "rocket";
                data["bBot"] = false;
                data["bUseTimer"] = this.localData["bModeGame"];
                data["bPlayerControlled"] = true;
                data["moveSpeed"] = 800;
                data["heliVelocityXAdjust"] = 3;
                data["killstreakId"] = Killstreaks.KILLSTREAK_REAPER;
                data["muzzleOffsetY"] = 20;
                data["fireDelayTimer"] = 0;
                data["fireRate"] = Math.round((this.localData["bSurvival"] ? 30 : 60) * this.localData.settings.fps_mult);
                data["ammo"] = this.localData["bSurvival"] ? (this.localData["bUseMoneyMultiplier"] ? 100 : 50) : 25;
                data["maxRange"] = 4000;
                data["behaviour"] = "attack";
                data.heliData["weaponId"] = "smaw";
                data["xpReward"] = 400;
                bControllable = true;
                break;            

            case Helicopter.TYPE_BLACKHAWK:
                health = 2000;
                data["bBot"] = false;
                data["bUseTimer"] = this.localData["bModeGame"];
                data["bPlayerControlled"] = true;
                data["distThreshold"] = 300;
                data["killstreakId"] = Killstreaks.KILLSTREAK_CHOPPER_GUNNER;
                data["muzzleOffsetX"] = 100;
                data["muzzleOffsetY"] = 45;
                data["fireDelayTimer"] = 0;
                data["fireRate"] = Math.round(5 * this.localData.settings.fps_mult);
                data["damage"] = this.localData["bUseMoneyMultiplier"] ? 120 : 50;
                data["accuracy"] = 3;
                data["ammo"] = 500;
                data["maxRange"] = 2500;
                data["behaviour"] = "attack";
                data.heliData["weaponId"] = "m240";
                data["xpReward"] = 300;
                bControllable = true;
                break;

            case Helicopter.TYPE_BLACKHAWK_SNIPER:
                health = 2000;
                data["swayMax"] = 25;
                data["bBot"] = false;
                data["bUseTimer"] = this.localData["bModeGame"];
                data["bPlayerControlled"] = true;
                data["distThreshold"] = 600;
                data["killstreakId"] = Killstreaks.KILLSTREAK_HELI_SNIPER;
                data["muzzleOffsetX"] = 100;
                data["muzzleOffsetY"] = 45;
                data["fireDelayTimer"] = 0;
                data["fireRate"] = Math.round(75 * this.localData.settings.fps_mult);
                data["damage"] = this.localData["bUseMoneyMultiplier"] ? 800 : 200;
                data["accuracy"] = 0;
                data["ammo"] = 50;
                data["maxRange"] = 2500;
                data["behaviour"] = "attack";
                data.heliData["weaponId"] = "r700";
                data.heliData["style"] = Helicopter.TYPE_BLACKHAWK;
                data["xpReward"] = 300;
                bControllable = true;
                break;

            case Helicopter.TYPE_PAVE_LOW:
                health = 3000;
                data["bUseTimer"] = this.localData["bModeGame"];
                data["rocketTimerMax"] = this.localData.settings.fps * 15;
                //data["timer"] = this.localData.settings.fps * 120;
                data["heliVelocityXAdjust"] = 1;
                data["maxSpeed"] = 100;
                data["killstreakId"] = Killstreaks.KILLSTREAK_PAVE_LOW;
                data["distThreshold"] = 100;
                data["muzzleOffsetX"] = 200;
                data["muzzleOffsetY"] = 130;
                data["fireDelayTimer"] = 0;
                data["fireRate"] = Math.round(10 * this.localData.settings.fps_mult);
                data["damage"] = this.localData["bUseMoneyMultiplier"] ? 100 : 35;
                data["accuracy"] = 2;
                data["ammo"] = 500;
                data["maxRange"] = this.localData["bUseMoneyMultiplier"] ? 2500 : 1500;
                data["bMaxLookRange"] = true;
                data["behaviour"] = "attack";
                data["bExplore"] = this.localData["bModeGame"]; //true;
                data["exploreTimer"] = 0;
                data["bHasBurstDelay"] = true;
                data["burstTimerMax"] = this.localData.settings.fps * 3;
                data["burstDelayTimerMax"] = this.localData.settings.fps * 5;
                data.heliData["weaponId"] = "m16a4";
                data["xpReward"] = 300;
                break;

            case Helicopter.TYPE_OSPREY:
                health = bSurvivalAlly ? 4000 : 3000;
                data["heliVelocityXAdjust"] = 1;
                data["killstreakId"] = Killstreaks.KILLSTREAK_ESCORT_AIRDROP;
                data["distThreshold"] = 200;
                data["muzzleOffsetX"] = 0;
                data["muzzleOffsetY"] = 155;
                data["fireDelayTimer"] = 0;
                data["fireRate"] = Math.round((this.localData.bSurvival ? 10 : 12) * this.localData.settings.fps_mult);
                data["damage"] = this.localData["bUseMoneyMultiplier"] ? 200 : 35;
                data["accuracy"] = 2;
                data["ammo"] = 5000;
                data["maxRange"] = bSurvivalAlly ? 1500 : 1400;
                data["behaviour"] = "attack";
                data["bAirdrop"] = true;
                data["dropTimer"] = this.localData.settings.fps * 5;
                data["defendTimer"] = this.localData.settings.fps * 30;
                data.heliData["weaponId"] = "msg90";
                data["xpReward"] = 300;                
                break;

            case Helicopter.TYPE_DRAGONFIRE:
                health = 400;
                data["angleMult"] = 0.03;
                data["bBot"] = false;
                data["bDrone"] = true;
                data["bUseTimer"] = this.localData["bModeGame"];
                data["bPlayerControlled"] = true;
                data["moveSpeed"] = 800;
                data["heliVelocityXAdjust"] = 1;
                data["killstreakId"] = Killstreaks.KILLSTREAK_DRAGONFIRE;
                data["muzzleOffsetY"] = 0;
                data["fireDelayTimer"] = 0;
                data["fireRate"] = Math.floor(2 * this.localData.settings.fps_mult);
                data["damage"] = bSurvivalAlly ? 50 : 25;
                data["ammo"] = this.localData["bSurvival"] ? 1000 : 500;
                data["accuracy"] = 5;
                data["maxRange"] = 1200;
                data["bMaxLookRange"] = true;
                data["bIgnoreLOS"] = true;
                data["behaviour"] = "attack";
                data["swayMax"] = 50;
                data.heliData["weaponId"] = "vector";
                data["xpReward"] = 200;
                bControllable = true;
                data["weaponData"] = {
                    id: data.killstreakId,
                    damage: data.damage,
                    range: data.maxRange,
                    type: Weapon.TYPE_SMG,
                    penetration: 1
                }
                break;
        }
        data["health"] = data["maxHealth"] = health;
        if (data["bUseTimer"] && !data["timer"])
        {
            data["timer"] = this.localData.settings.fps * 180;
        }
        if (!data["weaponData"])
        {
            data["weaponData"] = {
                id: data.killstreakId,
                damage: data.damage,
                range: data.maxRange,
                type: Weapon.TYPE_SMG,
                penetration: 1
            }
        }
        if (data["rockets"])
        {
            data["rocketsMax"] = data["rockets"];
            data["rocketDelayTimer"] = 0;
            //data["bRocketDelay"] = false;
        }
        if (data["behaviour"] == "attack")
        {
            data["ticker"] = 0;
        }
        if (data["ammo"])
        {
            data["ammoMax"] = data["ammo"];
        }
        if (data["bHasBurstDelay"])
        {
            data["burstTimer"] = data["burstTimerMax"];
            data["burstDelayTimer"] = 0;
            data["bBurstDelay"] = false;
        }
        if (data["bPlayerControlled"])
        {
            data["bShowPlayer"] = true;
        }
        var physicsId = _heliData["style"] ? _heliData["style"] : _heliData["type"];
        var shared = this.getSharedData(physicsId);
        var bCollide = true; //data["bDrone"] && !this.localData["bOperation"];
        if (data.behaviour == "deliver" || data.bAirdrop)
        {
            bCollide = false;
        }
        var shape = new this.p2.Box({
            width: shared.width,
            height: shared.height,
            collisionGroup: bCollide ? CollisionGroups.DRONE : CollisionGroups.PAWN_AIR,
            collisionMask: bCollide ? (CollisionGroups.GROUND | CollisionGroups.PROJECTILE | CollisionGroups.PROJECTILE_AIR) : (CollisionGroups.PROJECTILE | CollisionGroups.PROJECTILE_AIR)
        });
        data["bCollide"] = bCollide == true ? 1 : 0;
        body.addShape(shape);
        this.addWorldBody(body);
        if (bControllable)
        {
            body.data["bControllable"] = true;
            var ps = this.getPlayerStateById(_heliData["playerId"]);
            if (ps)
            {
                _heliData["avatarData"] = ps["avatarData"];
                this.setPlayerControllable(ps, body);
            }
        }
        var items = _heliData["items"];
        if (items && !data["bAirdrop"])
        {
            var item = items[0];
            switch (item["type"])
            {
                case "crate":
                    var crate;
                    switch (item["crateType"])
                    {
                        case Crate.CRATE_AMMO:
                            crate = this.createAmmoCrate(body.position[0], body.position[1], _heliData["playerId"]);
                            break;

                        case Crate.CRATE_DECOY:
                            crate = this.createDecoyCrate(body.position[0], body.position[1], _heliData["playerId"]);
                            break;

                        case Crate.CRATE_WEAPON:
                            var items = item.items;
                            if (!items)
                            {
                                var weaponData = item["weaponData"];
                                if (!weaponData)
                                {
                                    weaponData = this.getWeaponData(item.weaponId, item.mods);
                                }
                                items = [weaponData];
                            }
                            crate = this.createItemCrate(body.position[0], body.position[1], _heliData["playerId"], items);
                            break;

                        case Crate.CRATE_PERK:
                            crate = this.createPerkCrate(body.position[0], body.position[1], _heliData["playerId"], item["perkId"]);
                            break;

                        case Crate.CRATE_SHARD:
                            crate = this.createShardCrate(body.position[0], body.position[1], item["shards"]);
                            break;

                        case Crate.CRATE_XP:
                            crate = this.createXPCrate(body.position[0], body.position[1], item["xp"]);
                            break;

                        case Crate.CRATE_LIFE:
                            crate = this.createLifeCrate(body.position[0], body.position[1], item["lives"]);
                            break;

                        case Crate.CRATE_KILLSTREAK:
                            if (item["killstreakId"])
                            {
                                crate = this.createKillstreakCrate(body.position[0], body.position[1], item["killstreakId"], _heliData["playerId"]);
                            }
                            else
                            {
                                crate = this.createKillstreakCrate(body.position[0], body.position[1], undefined, _heliData["playerId"]);
                            }
                            break;
                    }
                    if (crate)
                    {
                        crate.mass = 0.1;
                        crate.updateMassProperties();
                        crate.angularDamping = 0.5;
                        crate.shapes[0].collisionMask = 0;
                        var crateOffset = _heliData["type"] == Helicopter.TYPE_SCOUT ? 120 : 80;
                        crate.position[1] += crateOffset;
                        crate.data["bEnabled"] = false;
                        crate.data["bOnRope"] = true;
                        var constraint = new this.p2.RevoluteConstraint(body, crate, {
                            worldPivot: [body.position[0], body.position[1]]
                        });
                        constraint.setStiffness(100);
                        constraint.upperLimit = this.ToRad(45);
                        constraint.upperLimitEnabled = true;
                        constraint.lowerLimit = this.ToRad(-45);
                        constraint.lowerLimitEnabled = true;
                        this.localData.world.addConstraint(constraint);
                        body["constraint"] = constraint;
                        body.data["crateId"] = crate.data["id"];
                        this.pushObjectDataUpdate(crate.data.id, ["bEnabled", "bOnRope"]);
                    }
                    break;
            }
        }
        this.requestEvent({
            eventId: GameServer.EVENT_SPAWN_HELICOPTER,
            position: body.position,
            data: body.data
        });
        return body;
    }

    setInteractableEnabled(_body, _bEnabled)
    {
        if (_body)
        {
            //TODO
        }
    }

    getRescueZone()
    {
        switch (this.localData.gameModeData.id)
        {
            case GameMode.OP_HOSTAGE:
                if (this.localData.gameModeData.rescueZone)
                {
                    return this.localData.gameModeData.rescueZone;
                }
                return this.localData.operation.data.player.position;
                break;

            default:
                return this.getCurrentMapData().spawns_team[0];
                break;
        }
    }

    createDroppedWeapon(_id, _position, _rotation, _scale, _interactData, _velocity, _angularVelocity)
    {
        var body = new this.p2.Body({
            mass: 1,
            position: _position,
            angle: _rotation,
            allowSleep: true,
            sleepSpeedLimit: 10,
            sleepTimeLimit: 1
        });
        body.data = {
            id: _id,
            type: "droppedWeapon",
            scale: _scale,
            interactData: _interactData
        };
        var weaponData = _interactData["weaponData"];
        if (weaponData.bBarrel)
        {
            weaponData.bBarrel = false;
        }
        var atlasData = this.getWorldWeaponData(weaponData["id"]);
        var shape = new this.p2.Box({
            width: atlasData.w,
            height: atlasData.h,
            collisionMask: CollisionGroups.GROUND | CollisionGroups.PLATFORM
        });
        body.addShape(shape);
        this.addWorldBody(body);
        if (weaponData["ammo"] == 0 && weaponData["mag"] == 0)
        {
            body.data["destroyTimer"] = this.localData.settings.fps;
        }
        if (_velocity)
        {
            body.applyImpulse([_velocity[0], _velocity[1]], 0, 0);
        }
        if (_angularVelocity)
        {
            //body.angularVelocity = _angularVelocity;
        }
        this.onEvent({
            eventId: GameServer.EVENT_SPAWN_DROPPED_WEAPON,
            position: body.position,
            rotation: body.angle,
            velocity: body.velocity,
            angularVelocity: body.angularVelocity,
            data: body.data
        });
        var objects = this.localData.world.bodies;
        var num = 0;
        var oldWeapon;
        for (var i = 0; i < objects.length; i++)
        {
            var wpn = objects[i];
            if (wpn.data && wpn.data["type"] == "droppedWeapon")
            {
                if (!oldWeapon)
                {
                    oldWeapon = objects[i];
                }
                if (!wpn.data.bPersistant)
                {
                    num++;
                    if (num > 8)
                    {
                        this.removeNextStep(oldWeapon);
                        break;
                    }
                }
            }
        }
        return body;
    }

    createExplosion(_data)
    {
        this.requestEvent(_data);
    }

    createEquipment(_position, _team, _scale, _ownerId, _weaponData)
    {
        var shared = this.getSharedData(_weaponData["id"]);
        var body = new this.p2.Body({
            mass: shared["mass"] ? shared["mass"] : 1,
            damping: 0.9,
            position: _position,
            allowSleep: true,
            sleepSpeedLimit: 1,
            sleepTimeLimit: 1,
            velocity: [0, 1]
        });
        body.data = {
            id: this.getRandomUniqueId(),
            x: _position[0],
            y: _position[1],
            type: "equipment",
            health: _weaponData["health"] ? _weaponData["health"] : 1,
            team: _team,
            scale: _scale,
            ownerId: _ownerId,
            weaponData: _weaponData
        };
        if (_weaponData["id"] == "trophy")
        {
            body.data["material"] = "metal";
            body.data["blockNum"] = 2;
            body.data["bCanMelee"] = true;
        }
        else if (_weaponData["id"] == "tac_insert")
        {
            body.fixedRotation = true;
        }
        if (_weaponData["radius"])
        {
            body.data["radius"] = _weaponData["radius"];
        }
        if (_weaponData["bMine"])
        {
            switch (_weaponData["id"])
            {
                case "claymore":
                    body.data["bUseScale"] = true;
                    body.data["triggerRange"] = 200;
                    break;

                case "betty":
                    body.data["triggerRange"] = 60;
                    break;

                default:
                    body.data["triggerRange"] = 100;
                    break;
            }
        }
        var shape = new this.p2.Box({
            width: shared.width,
            height: shared.height,
            collisionGroup: CollisionGroups.PAWN,
            collisionMask: CollisionGroups.GROUND | CollisionGroups.PLATFORM | CollisionGroups.PROJECTILE
        });
        body.addShape(shape);

        var numMax = 4;
        switch (_weaponData["id"])
        {
            case "jammer":
            case "sensor":
            case "trophy":
                numMax = 2;
                break;
        }
        var arr = this.getEquipmentByPlayerId(_ownerId, _weaponData["id"]);
        if (arr.length >= numMax)
        {
            this.removeNextStep(arr[0]);
        }

        this.addWorldBody(body);
        this.onEvent({
            eventId: GameServer.EVENT_SPAWN_EQUIPMENT,
            position: body.position,
            data: body.data
        });        
        return body;
    }

    resetFlag(_body)
    {
        if (_body)
        {
            var data = _body.data;
            data.bIsBeingCaptured = false;
            data.captureTimer[0] = data.captureTimerMax;
            data.captureTimer[1] = data.captureTimerMax;
            data.pointTimer = 0;
            data.team = null;
            this.pushObjectDataUpdate(data.id, ["bIsBeingCaptured", "pointTimer", "team", "captureTimer"]);
        }
    }

    createFlagDomination(_num, _captureTime)
    {
        var map = this.getCurrentMapData();
        var pos = map.flags_domination[_num];
        if (this.localData.gameModeData["id"] == GameMode.HEADQUARTERS)
        {
            var hq = map.flags_headquarters;
            if (hq)
            {
                pos = hq[this.Random(0, hq.length - 1)];
            }
        }
        var body = new this.p2.Body({
            mass: 0,
            position: pos,
            fixedRotation: true
        });
        var str = ["a", "b", "c"];
        var captureTime = this.localData.settings.fps * _captureTime;
        body.data = {
            id: "flag_" + _num,
            x: body.position[0],
            y: body.position[1],
            type: "flag_domination",
            num: _num,
            str: str[_num],
            team: null,
            bIsBeingCaptured: false,
            captureTimer: [
                captureTime,
                captureTime
            ],
            captureTimerMax: captureTime,
            pointTimer: 0,
            pointTimerMax: this.localData.settings.fps * 2
        };
        var shape = new this.p2.Box({
            width: 250,
            height: 100,
            collisionGroup: CollisionGroups.PAWN,
            collisionMask: CollisionGroups.GROUND
        });
        body.addShape(shape);
        this.addWorldBody(body);
        this.onEvent({
            eventId: GameServer.EVENT_SPAWN_FLAG,
            position: body.position,
            data: body.data
        });
        return body;
    }

    createFlagCTF(_team)
    {
        var map = this.getCurrentMapData();
        var body = new this.p2.Body({
            mass: 10,
            position: map.flags_ctf[_team],
            fixedRotation: true,
            allowSleep: true,
            sleepSpeedLimit: 1,
            sleepTimeLimit: 1
        });
        body.data = {
            id: "flag_" + _team,
            type: "flag_ctf",
            team: _team,
            bAwayFromHome: false
        };
        var shape = new this.p2.Box({
            width: 32,
            height: 100,
            collisionGroup: CollisionGroups.PAWN,
            collisionMask: CollisionGroups.GROUND | CollisionGroups.PLATFORM
        });
        body.addShape(shape);
        this.addWorldBody(body);
        this.onEvent({
            eventId: GameServer.EVENT_SPAWN_FLAG,
            position: body.position,
            data: body.data
        });
        return body;
    }

    createFlagDefender()
    {
        var map = this.getCurrentMapData();
        var pos = map.flag_defender;
        var hq = map.flags_headquarters;
        if (hq)
        {
            pos = hq[this.Random(0, hq.length - 1)];
        }
        var body = new this.p2.Body({
            mass: 10,
            position: pos,
            fixedRotation: true,
            allowSleep: true,
            sleepSpeedLimit: 1,
            sleepTimeLimit: 1
        });
        body.data = {
            id: "flag_defender",
            type: "flag_defender",
            team: null,
            pointTimer: 0,
            pointTimerMax: this.localData.settings.fps * 2,
        };
        var shape = new this.p2.Box({
            width: 32,
            height: 100,
            collisionGroup: CollisionGroups.PAWN,
            collisionMask: CollisionGroups.GROUND | CollisionGroups.PLATFORM
        });
        body.addShape(shape);
        this.addWorldBody(body);
        this.onEvent({
            eventId: GameServer.EVENT_SPAWN_FLAG,
            position: body.position,
            data: body.data
        });
        return body;
    }

    createReviver(_id, _position, _velocity, _va, _bBleedTimer, _interactData)
    {
        var body = new this.p2.Body({
            mass: 10,
            damping: 0.7,
            position: _position
        });
        body.data = {
            id: _id,
            x: _position[0],
            y: _position[1],
            type: "reviver",
            bLimitInteractions: true,
            interactData: _interactData
        };
        if (_bBleedTimer)
        {
            var bleedTimerMax = 30;
            if (this.localData["bOperation"])
            {
                bleedTimerMax = 30 - (this.localData["difficulty"] * 5);
            }
            body.data["bleedTimerMax"] = this.localData.settings.fps * bleedTimerMax;
            body.data["bleedTimer"] = body.data["bleedTimerMax"];
        }
        var shape = new this.p2.Box({
            width: 20,
            height: 20,
            collisionMask: CollisionGroups.GROUND | CollisionGroups.PLATFORM
        });
        body.addShape(shape);
        this.addWorldBody(body);

        body.applyImpulse([_velocity[0], _velocity[1]], 0, 0);
        body.angularVelocity = _va;

        this.onEvent({
            eventId: GameServer.EVENT_SPAWN_REVIVER,
            position: body.position,
            velocity: body.velocity,
            data: body.data
        });
        return body;
    }

    createInfo(_position, _interactData)
    {
        var body = new this.p2.Body({
            mass: 0,
            position: _position,
            allowSleep: true,
            sleepSpeedLimit: 1,
            sleepTimeLimit: 1
        });
        body.data = {
            id: this.getRandomUniqueId(),
            x: _position[0],
            y: _position[1],
            type: "info",
            interactData: _interactData,
            timeTrigger: _interactData.timeTrigger
        };
        var useWidth = _interactData.width ? _interactData.width : 50;
        var useHeight = _interactData.height ? _interactData.height : 50;
        if (_interactData.size)
        {
            useWidth = useHeight = _interactData.size;
        }
        var shape = new this.p2.Box({
            width: useWidth,
            height: useHeight,
            collisionMask: CollisionGroups.PAWN
        });
        body.addShape(shape);
        this.addWorldBody(body);
        return body;
    }

    createScavengerPack(_position, _interactData)
    {
        var shared = this.getSharedData("scavenger_pack");
        var body = new this.p2.Body({
            mass: 1,
            position: _position,
            allowSleep: true,
            sleepSpeedLimit: 1,
            sleepTimeLimit: 1,
            velocity: [0, 1]
        });
        body.data = {
            id: this.getRandomUniqueId(),
            x: _position[0],
            y: _position[1],
            type: "scavenger_pack",
            interactData: _interactData
        };
        var shape = new this.p2.Box({
            width: shared.width,
            height: shared.height,
            collisionMask: CollisionGroups.GROUND | CollisionGroups.PLATFORM
        });
        body.addShape(shape);
        this.addWorldBody(body);
        this.onEvent({
            eventId: GameServer.EVENT_SPAWN_OBJECT,
            position: body.position,
            data: body.data
        });
        var packs = this.getScavengerPacks();
        if (packs.length > Settings.SCAVENGER_PACKS_MAX)
        {
            this.removeNextStep(packs[0]);
        }
        return body;
    }

    createLootPack(_position, _interactData)
    {
        var shared = this.getSharedData("scavenger_pack");
        var body = new this.p2.Body({
            mass: 1,
            position: _position,
            allowSleep: true,
            sleepSpeedLimit: 1,
            sleepTimeLimit: 1,
            velocity: [0, 1]
        });
        body.data = {
            id: this.getRandomUniqueId(),
            x: _position[0],
            y: _position[1],
            type: "loot_pack",
            interactData: _interactData
        };
        var shape = new this.p2.Box({
            width: shared.width,
            height: shared.height,
            collisionMask: CollisionGroups.GROUND | CollisionGroups.PLATFORM
        });
        body.addShape(shape);
        this.addWorldBody(body);
        this.onEvent({
            eventId: GameServer.EVENT_SPAWN_OBJECT,
            position: body.position,
            data: body.data
        });
        var packs = this.getLootPacks();
        if (packs.length > Settings.SCAVENGER_PACKS_MAX)
        {
            this.removeNextStep(packs[0]);
        }
        body.applyImpulse([this.Random(-100, 100), 0], 0, 0);
        return body;
    }

    createCrate(_id, _position, _interactData, _mass = 1)
    {
        var body = new this.p2.Body({
            mass: _mass,
            position: _position,
            allowSleep: true,
            sleepSpeedLimit: 1,
            sleepTimeLimit: 1
        });
        body.data = {
            id: _id,
            x: _position[0],
            y: _position[1],
            type: "crate",
            interactData: _interactData,
            team: _interactData["team"],
            bEnabled: true
        };
        if (this.localData["bModeGame"] || this.localData["bBattlezone"])
        {
            if (_interactData["type"] != Crate.CRATE_STORE && _interactData["type"] != Crate.CRATE_BOMB && _interactData["type"] != Crate.CRATE_BOMB_GENERIC)
            {
                body.data["destroyTimer"] = this.localData.settings.fps * 180;
            }
        }
        var shape = new this.p2.Box({
            width: 60,
            height: 24,
            collisionMask: CollisionGroups.GROUND | CollisionGroups.PLATFORM
        });
        body.addShape(shape);
        this.addWorldBody(body);
        this.onEvent({
            eventId: GameServer.EVENT_SPAWN_CRATE,
            position: body.position,
            data: body.data,
            mass: _mass
        });
        var crates = this.getDisposableCrates();
        if (crates.length > Settings.CRATES_MAX)
        {
            this.removeNextStep(crates[0]);
        }
        return body;
    }

    createDestructableObject(_id, _position, _data)
    {
        var body = new this.p2.Body({
            mass: _data["mass"],
            fixedRotation: _data["fixedRotation"],
            damping: 0.5,
            angularDamping: 0.9,
            position: _position
        });
        body.data = {
            id: _id,
            x: _position[0],
            y: _position[1],
            type: "destructableObject",
            material: _data["material"],
            damageMultipliers: _data["damageMultipliers"],
            health: _data["health"],
            playerId: _data["playerId"],
            destructableData: _data
        };
        var collisionGroup = undefined;
        var collisionMask = CollisionGroups.GROUND | CollisionGroups.PLATFORM | CollisionGroups.PROJECTILE;
        if (_data["bCollidePawns"])
        {
            collisionGroup = CollisionGroups.PROJECTILE;
            collisionMask = CollisionGroups.GROUND | CollisionGroups.PLATFORM | CollisionGroups.PROJECTILE | CollisionGroups.PAWN;
        }
        var shape = new this.p2.Box({
            width: _data["width"],
            height: _data["height"],
            collisionGroup: collisionGroup,
            collisionMask: collisionMask
        });
        body.addShape(shape);
        this.addWorldBody(body);
        this.onEvent({
            eventId: GameServer.EVENT_SPAWN_OBJECT,
            data: body.data
        });
        return body;
    }

    createShield(_charId)
    {
        var char = this.getObjectById(_charId);
        if (!char)
        {
            return null;
        }
        var body = new this.p2.Body({
            damping: 0,
            angularDamping: 0,
            gravityScale: 0,
            position: char.position
        });
        body.data = {
            id: this.getRandomUniqueId(),
            type: "shield",
            material: "metal",
            playerId: _charId,
            team: char.data["team"],
            bActive: true
        };
        var shape = new this.p2.Box({
            width: 25,
            height: 60,
            collisionGroup: CollisionGroups.SHIELD,
            collisionMask: CollisionGroups.PROJECTILE
        });
        //shape.sensor = true;
        body.addShape(shape);
        this.addWorldBody(body);
        this.onEvent({
            eventId: GameServer.EVENT_SPAWN_OBJECT,
            data: body.data
        });
        return body;
    }

    createDeployableCover(_id, _position, _playerId)
    {
        var ps = this.getPlayerStateById(_playerId);
        var shared = this.getSharedData("deployable_cover");
        this.createDestructableObject(_id, _position, {
            type: "deployable_cover",
            mass: 10,
            fixedRotation: true,
            material: "metal",
            width: shared.width,
            height: shared.height,
            health: 100,
            damageMultipliers: {
                1: 0.15,
                2: 1,
                3: 1
            },
            playerId: _playerId,
            team: ps ? ps.team : null
        });
        var objects = this.getDeployableCovers(_playerId);
        if (objects.length > 2)
        {
            this.removeNextStep(objects[0]);
        }
    }

    createLargeBox(_id, _position)
    {
        this.createDestructableObject(_id, _position, {
            type: "box_large",
            mass: 10,
            width: 69,
            height: 69,
            health: 200,
            bCollidePawns: true
        });
    }

    createSmallBox(_id, _position)
    {
        this.createDestructableObject(_id, _position, {
            type: "box_small",
            mass: 5,
            width: 35,
            height: 35,
            health: 100,
            bCollidePawns: true
        });
    }

    createStoreCrate(_x, _y) 
    {
        var crate = this.createCrate(this.getRandomUniqueId(), [_x, _y],
            {
                type: Crate.CRATE_STORE,
                team: 0
            },
            0
        );
        crate.data["bSkipServerUpdate"] = true;
        return crate;
    }

    createBombCrate(_bombTeam) 
    {
        var map = this.getCurrentMapData();
        var pos = map.spawns_bomb[this.Random(0, map.spawns_bomb.length - 1)];
        var crate = this.createCrate("crate_bomb", [pos[0], pos[1] + 24],
            {
                type: Crate.CRATE_BOMB,
                team: _bombTeam == 0 ? 1 : 0,
                interactTime: this.localData.gameModeData["plantTime"]
            },
            0
        );
        crate.data["bLimitInteractions"] = true;
        crate.data["interactTeam"] = _bombTeam;
        return crate;
    }

    createGenericBombCrate(_id, _x, _y, _team, _interactTeam) 
    {
        var crate = this.createCrate(_id, [_x, _y],
            {
                type: Crate.CRATE_BOMB_GENERIC,
                team: _team,
                interactTime: this.localData.settings.fps * 3
            },
            1
        );
        crate.data["bombTimer"] = this.localData.settings.fps * 5;
        crate.data["bLimitInteractions"] = true;
        crate.data["interactTeam"] = _interactTeam;
        return crate;
    }

    createAmmoCrate(_x, _y, _playerId, _team = 0) 
    {
        var ps = this.getPlayerStateById(_playerId);
        var crate = this.createCrate(this.getRandomUniqueId(), [_x, _y],
            {
                type: Crate.CRATE_AMMO,
                ownerId: _playerId,
                team: ps ? ps["team"] : (this.localData["bBattlezone"] ? Battlezone.TEAM_AIRDROPS : _team),
                interactTime: Math.round(this.localData.settings.fps * 0.5)
            }
        );
        return crate;
    }

    createDecoyCrate(_x, _y, _playerId, _team = 0) 
    {
        var ps = this.getPlayerStateById(_playerId);
        var fraud = [
            Killstreaks.KILLSTREAK_COUNTER_UAV,
            Killstreaks.KILLSTREAK_UAV,
            Killstreaks.KILLSTREAK_HELLFIRE,
            Killstreaks.KILLSTREAK_AIRSTRIKE,
            Killstreaks.KILLSTREAK_NAPALM,
            Killstreaks.KILLSTREAK_STEALTH_BOMBER,
            Killstreaks.KILLSTREAK_MH6,
            Killstreaks.KILLSTREAK_MH6_GRENADE,
            Killstreaks.KILLSTREAK_COBRA,
            Killstreaks.KILLSTREAK_COBRA_CONTROLLABLE,
            Killstreaks.KILLSTREAK_CHOPPER_GUNNER,
            Killstreaks.KILLSTREAK_REAPER,
            Killstreaks.KILLSTREAK_SENTRY_GUN_PLACE,
            Killstreaks.KILLSTREAK_SAM_TURRET_PLACE,
            Killstreaks.KILLSTREAK_HELI_SNIPER,
            Killstreaks.KILLSTREAK_PAVE_LOW,
            Killstreaks.KILLSTREAK_EMP,
            Killstreaks.KILLSTREAK_SCOUT,
            Killstreaks.KILLSTREAK_JUGGERNAUT_RECON_USE,
            Killstreaks.KILLSTREAK_JUGGERNAUT_USE,
            Killstreaks.KILLSTREAK_DRAGONFIRE
        ];
        var crate = this.createCrate(this.getRandomUniqueId(), [_x, _y],
            {
                type: Crate.CRATE_DECOY,
                ownerId: _playerId,
                team: ps ? ps["team"] : _team,
                interactTime: Math.round(this.localData.settings.fps * 0.5),
                fraudKillstreakId: fraud[this.Random(0, fraud.length - 1)]
            }
        );
        if (this.isTeamGameMode())
        {
            crate.data["interactTeam"] = crate.data["team"] == 0 ? 1 : 0;
        }
        return crate;
    }

    createItemCrate(_x, _y, _playerId, _items, _team = 0) 
    {
        var ps = this.getPlayerStateById(_playerId);
        var items = [];
        for (var i = 0; i < _items.length; i++)
        {
            items.push(_items[i]);
        }
        var crate = this.createCrate(this.getRandomUniqueId(), [_x, _y],
            {
                type: Crate.CRATE_WEAPON,
                items: items,
                ownerId: _playerId,
                team: ps ? ps["team"] : (this.localData["bBattlezone"] ? Battlezone.TEAM_AIRDROPS : _team),
                interactTime: Math.round(this.localData.settings.fps * 0.5)
            }
        );
        return crate;
    }

    stopCharacterInteract(_pawn)
    {
        if (_pawn.data["interactableId"])
        {
            var interactable = this.getObjectById(_pawn.data["interactableId"]);
            if (interactable && interactable.data["bLimitInteractions"])
            {
                delete interactable.data["currentPawnId"];
            }
        }
        _pawn.data["bWantsToInteract"] = false;
        delete _pawn.data["interactableId"];
        delete _pawn.data["interactTimer"];        
        this.requestEvent({
            eventId: GameServer.EVENT_PAWN_ACTION,
            pawnId: _pawn.data["id"],
            type: GameServer.PAWN_END_INTERACTION
        });
    }

    createShardCrate(_x, _y, _shards = 1) 
    {
        var crate = this.createCrate(this.getRandomUniqueId(), [_x, _y],
            {
                type: Crate.CRATE_SHARD,
                shards: _shards,
                team: Battlezone.TEAM_AIRDROPS,
                interactTime: Math.round(this.localData.settings.fps * 0.5)
            }
        );
        return crate;
    }

    createXPCrate(_x, _y, _xp = 1) 
    {
        var crate = this.createCrate(this.getRandomUniqueId(), [_x, _y],
            {
                type: Crate.CRATE_XP,
                xp: _xp,
                team: Battlezone.TEAM_AIRDROPS,
                interactTime: Math.round(this.localData.settings.fps * 0.5)
            }
        );
        return crate;
    }

    createLifeCrate(_x, _y, _lives = 1) 
    {
        var crate = this.createCrate(this.getRandomUniqueId(), [_x, _y],
            {
                type: Crate.CRATE_LIFE,
                lives: _lives,
                team: Battlezone.TEAM_AIRDROPS,
                interactTime: Math.round(this.localData.settings.fps * 0.5)
            }
        );
        return crate;
    }

    createPerkCrate(_x, _y, _playerId, _perkId, _team) 
    {
        var ps = this.getPlayerStateById(_playerId);
        var crate = this.createCrate(this.getRandomUniqueId(), [_x, _y],
            {
                type: Crate.CRATE_PERK,
                perkId: _perkId,
                ownerId: _playerId,
                team: ps ? ps["team"] : (this.localData["bBattlezone"] ? Battlezone.TEAM_AIRDROPS : _team),
                interactTime: Math.round(this.localData.settings.fps * 0.5)
            }
        );
        return crate;
    }

    createKillstreakCrate(_x, _y, _killstreakId, _playerId, _team)
    {
        var killstreakId = _killstreakId;
        if (!killstreakId)
        {
            var killstreaks = {};
            if (this.localData["bSurvival"])
            {
                var wave = Math.min(this.localData.gameModeData["wave"], 100);
                killstreaks[Killstreaks.KILLSTREAK_HELLFIRE] = 15;
                killstreaks[Killstreaks.KILLSTREAK_RCXD] = 10;
                killstreaks[Killstreaks.KILLSTREAK_NAPALM] = 15;
                killstreaks[Killstreaks.KILLSTREAK_AIRSTRIKE] = 20;
                killstreaks[Killstreaks.KILLSTREAK_STEALTH_BOMBER] = 20;
                killstreaks[Killstreaks.KILLSTREAK_BOMBARDMENT] = 10 + (wave * 0.5);
                killstreaks[Killstreaks.KILLSTREAK_MH6] = 6 + wave;
                killstreaks[Killstreaks.KILLSTREAK_DRAGONFIRE] = 6 + wave;
                killstreaks[Killstreaks.KILLSTREAK_COBRA] = 4 + (wave * 0.5);
                killstreaks[Killstreaks.KILLSTREAK_SCOUT] = 4 + (wave * 0.5);  
                killstreaks[Killstreaks.KILLSTREAK_PAVE_LOW] = 2 + (wave * 0.25);
                killstreaks[Killstreaks.KILLSTREAK_REMOTE_TURRET] = 12 + (wave * 0.5); 
                killstreaks[Killstreaks.KILLSTREAK_ADVANCED_TURRET] = 8 + (wave * 0.5);
                killstreaks[Killstreaks.KILLSTREAK_GRENADE_TURRET] = 4 + (wave * 0.5);
                killstreaks[Killstreaks.KILLSTREAK_HELI_SNIPER] = 2;
                killstreaks[Killstreaks.KILLSTREAK_CHOPPER_GUNNER] = 2;
                killstreaks[Killstreaks.KILLSTREAK_MH6_GRENADE] = 1;
                killstreaks[Killstreaks.KILLSTREAK_COBRA_CONTROLLABLE] = 1;
                killstreaks[Killstreaks.KILLSTREAK_REAPER] = 1;
                killstreaks[Killstreaks.KILLSTREAK_DEADSWITCH] = wave * 0.1;
                killstreaks[Killstreaks.KILLSTREAK_SENTRY_GUN_PLACE] = wave;
                killstreaks[Killstreaks.KILLSTREAK_SAM_TURRET_PLACE] = wave;
            }
            else
            {
                killstreaks[Killstreaks.KILLSTREAK_UAV] = 10;
                killstreaks[Killstreaks.KILLSTREAK_COUNTER_UAV] = 10;
                killstreaks[Killstreaks.KILLSTREAK_SAM_TURRET_PLACE] = 5;
                killstreaks[Killstreaks.KILLSTREAK_AMMO] = 3;
                killstreaks[Killstreaks.KILLSTREAK_HELLFIRE] = 7;
                killstreaks[Killstreaks.KILLSTREAK_NAPALM] = 7;
                killstreaks[Killstreaks.KILLSTREAK_RCXD] = 5;
                killstreaks[Killstreaks.KILLSTREAK_AIRSTRIKE] = 6;                
                killstreaks[Killstreaks.KILLSTREAK_SENTRY_GUN_PLACE] = 4;
                killstreaks[Killstreaks.KILLSTREAK_REMOTE_TURRET] = 5;
                killstreaks[Killstreaks.KILLSTREAK_STEALTH_BOMBER] = 5;
                killstreaks[Killstreaks.KILLSTREAK_DRAGONFIRE] = 5;
                killstreaks[Killstreaks.KILLSTREAK_HELI_SNIPER] = 3;
                killstreaks[Killstreaks.KILLSTREAK_EMP] = 3;
                killstreaks[Killstreaks.KILLSTREAK_COBRA] = 4;
                killstreaks[Killstreaks.KILLSTREAK_MH6] = 4;
                killstreaks[Killstreaks.KILLSTREAK_SCOUT] = 4;
                killstreaks[Killstreaks.KILLSTREAK_CHOPPER_GUNNER] = 2;
                killstreaks[Killstreaks.KILLSTREAK_PAVE_LOW] = 2;
                killstreaks[Killstreaks.KILLSTREAK_BOMBARDMENT] = 2;
                killstreaks[Killstreaks.KILLSTREAK_REAPER] = 2;
                killstreaks[Killstreaks.KILLSTREAK_JUGGERNAUT_USE] = 2;
                killstreaks[Killstreaks.KILLSTREAK_JUGGERNAUT_RECON_USE] = 2;
                killstreaks[Killstreaks.KILLSTREAK_ADVANCED_TURRET] = 2;
                killstreaks[Killstreaks.KILLSTREAK_GRENADE_TURRET] = 2;
                killstreaks[Killstreaks.KILLSTREAK_COBRA_CONTROLLABLE] = 1;
                killstreaks[Killstreaks.KILLSTREAK_MH6_GRENADE] = 1;  
            }
            killstreakId = this.getRandomProperty(killstreaks);
        }
        var ps = this.getPlayerStateById(_playerId);
        var crate;
        switch (killstreakId)
        {
            case Killstreaks.KILLSTREAK_AMMO:
                crate = this.createAmmoCrate(_x, _y, _playerId, _team);
                break;

            default:
                crate = this.createCrate(this.getRandomUniqueId(), [_x, _y],
                    {
                        type: Crate.CRATE_KILLSTREAK,
                        killstreakId: killstreakId,
                        ownerId: _playerId,
                        team: ps ? ps["team"] : this.localData["bBattlezone"] ? Battlezone.TEAM_AIRDROPS : _team,
                        interactTime: Math.round(this.localData.settings.fps * 0.5)
                    }
                );
                break;
        }
        return crate;
    }

    getRandomProperty(input)
    {
        var arr = [];
        for (var item in input)
        {
            if (input.hasOwnProperty(item))
            {
                for (var i = 0; i < input[item]; i++)
                {
                    arr.push(item);
                }
            }
        }
        return arr[Math.floor(Math.random() * arr.length)];
    }

    removeBody(_body)
    {
        if (_body)
        {
            this.localData.world.removeBody(_body);
        }
    }

    addBody(_body)
    {
        if (_body)
        {
            this.localData.world.addBody(_body);
        }
    }

    removeObject(_body)
    {
        if (_body)
        {
            if (_body["constraint"])
            {
                this.localData.world.removeConstraint(_body["constraint"]);
                delete _body["constraint"];
            }
            var data = _body.data;
            var id = data ? data["id"] : undefined;
            var type = data ? data["type"] : undefined;
            delete _body.data;
            this.localData.world.removeBody(_body);
            if (id)
            {
                var players = this.localData["playerStates"];
                for (var i = 0; i < players.length; i++)
                {
                    var ps = players[i];
                    if (ps["controllableId"] == id)
                    {
                        this.clearPlayerControllable(ps);
                        break;
                    }
                }
                if (type == "rocket")
                {
                    var pawns = this.getPawns();
                    for (i = 0; i < pawns.length; i++)
                    {
                        var curPawn = pawns[i];
                        if (curPawn.data["currentRocketId"] == id)
                        {
                            delete curPawn.data["currentRocketId"];
                            break;
                        }
                    }
                }
                delete this.localData.objects[id];
                this.onEvent({
                    eventId: GameServer.EVENT_REMOVE_OBJECT,
                    id: id
                });
            }
        }
    }

    playerHasControllable(_playerId)
    {
        var ps = this.getPlayerStateById(_playerId);
        if (ps)
        {
            return ps["controllableId"];
        }
        return false;
    }

    setPlayerControllable(_player, _controllable)
    {
        if (_player)
        {
            if (_controllable)
            {
                _player["controllableId"] = _controllable.data["id"];
                _controllable.data["controllerId"] = _player["id"];

                var pawn = this.getObjectById(_player["id"]);
                this.cancelCharacterBoltPull(pawn);
                this.cancelCharacterReload(pawn);
                switch (_controllable.data["type"])
                {
                    case "turret":
                        if (pawn)
                        {
                            pawn.data["bWantsToMove"] = false;
                            pawn.velocity = [0, 0];
                            if (_controllable.data.turretData.type != Turret.TYPE_REMOTE)
                            {
                                pawn.position[0] = _controllable.position[0] - (_controllable.data["scale"] * 35);
                            }
                            pawn.wakeUp();
                        }
                        break;

                    case "helicopter":
                        if (this.localData["bSurvival"] || this.localData["bSandbox"])
                        {
                            pawn.data["bUntargetable"] = true;
                            pawn.data["bInvisible"] = true;
                            this.pushObjectDataUpdate(pawn.data.id, ["bUntargetable", "bInvisible"]);
                        }
                        break;

                    case "car":
                        if (this.localData["bSurvival"] || this.localData["bSandbox"])
                        {
                            pawn.data["bUntargetable"] = true;
                            pawn.data["bInvisible"] = true;
                            this.pushObjectDataUpdate(pawn.data.id, ["bUntargetable", "bInvisible"]);
                        }
                        break;

                    case "rocket":
                        if (this.localData["bSurvival"] || this.localData["bSandbox"])
                        {
                            pawn.data["bUntargetable"] = true;
                            pawn.data["bInvisible"] = true;
                            this.pushObjectDataUpdate(pawn.data.id, ["bUntargetable", "bInvisible"]);
                        }
                        break;
                }
                this.requestEvent({
                    eventId: GameServer.EVENT_PAWN_ACTION,
                    pawnId: _player["id"],
                    type: GameServer.PAWN_OPEN_LAPTOP
                });
            }
        }
    }

    clearPlayerControllable(_player)
    {
        if (_player)
        {
            var controllable = this.getObjectById(_player["controllableId"]);
            if (controllable)
            {
                controllable.data["controllerId"] = null;
            }
            _player["controllableId"] = null;
            this.onEvent({
                eventId: GameServer.EVENT_PLAYER_UPDATE,
                playerId: _player["id"],
                data: {
                    controllableId: null
                }
            });
            var pawn = this.getObjectById(_player["id"]);
            if (pawn)
            {
                if (this.localData["bSurvival"] || this.localData["bSandbox"])
                {
                    var bInvisible = pawn.data["bInvisible"];
                    pawn.data["bUntargetable"] = false;
                    pawn.data["bInvisible"] = false;
                    this.pushObjectDataUpdate(pawn.data.id, ["bUntargetable", "bInvisible"]);
                    if (bInvisible)
                    {
                        //this.localData.world.addBody(pawn);
                    }
                }
                this.requestEvent({
                    eventId: GameServer.EVENT_PAWN_ACTION,
                    pawnId: _player["id"],
                    type: GameServer.PAWN_CLOSE_LAPTOP
                });
            }
        }
    }

    removeObjectById(_id)
    {
        var object = this.getObjectById(_id);
        if (object)
        {
            this.removeNextStep(object);
        }
    }

    getCharacterSpeedMultiplier(_body)
    {
        return _body.data.speedMultiplier * _body.data.baseSpeedMultiplier;
    }

    handlePlayerInput(_body, _data)
    {
        if (!_body || !_data)
        {
            return;
        }
        var keyId = _data["keyId"];
        var value = _data["value"];
        var pawn = _body;
        if (pawn)
        {
            var maxSpeed = pawn.data["maxSpeed"] * this.getCharacterSpeedMultiplier(pawn);
            if (pawn.data["bStunned"])
            {
                maxSpeed = maxSpeed * 0.2;
                //moveSpeed = 10;
            }
            else if (!pawn.data["bIsOnLadder"])
            {
                if (pawn.data["bWantsToSprint"])
                {
                    maxSpeed = maxSpeed * this.characterHasPerk(pawn, Perks.PERK_PLAYER_LIGHTWEIGHT) ? 2.2 : 2;
                }
                else if (pawn.data["bWantsToCrouch"])
                {
                    var mult = this.characterHasPerk(pawn, Perks.PERK_PLAYER_NINJA) ? 1 : 0.7;
                    maxSpeed = maxSpeed * mult;
                }
            }

            switch (keyId)
            {
                case "look":
                    pawn.data["desiredAimRotation"] = value["angle"];
                    pawn.data["lookPos"] = value["pos"];
                    if (value.char && !pawn.data.bBot)
                    {
                        pawn.data.clientPos = value.char;
                        if (this.matchInProgress())
                        {
                            //Set position based on client position
                            if (!this.localData.bMultiplayer || 1)
                            {
                                pawn.position = value.char;
                            }
                        }
                    }
                    break;

                case "melee":
                    this.useCharacterMeleeAttack(pawn);
                    break;

                case "left":
                    pawn.data["bWantsToMove"] = value && this.characterCanMove(pawn);
                    if (value)
                    {
                        pawn.data["moveX"] = -1;
                    }
                    else
                    {
                        pawn.velocity[0] = 0;
                    }
                    break;

                case "right":
                    pawn.data["bWantsToMove"] = value && this.characterCanMove(pawn);
                    if (value)
                    {
                        pawn.data["moveX"] = 1;
                    }
                    else
                    {
                        pawn.velocity[0] = 0;
                    }
                    break;

                case "up":
                    if (value && !pawn.data["bIsOnLadder"] && this.characterCanClimb(pawn))
                    {
                        var ladder = this.getClimbableLadder(pawn);
                        if (ladder)
                        {
                            var ladderOffset = (ladder.data.height * 0.5) - 30;
                            if (pawn.position[1] > (ladder.position[1] - ladderOffset))
                            {
                                this.startLadderClimb(pawn, ladder);
                            }
                        }
                    }
                    if (pawn.data["bIsOnLadder"])
                    {
                        pawn.data["bWantsToClimb"] = value;
                        //var climbMult = 0.5;
                        //if (pawn.velocity[1] > -(maxSpeed * climbMult)) pawn.applyImpulse([0, -(moveSpeed)]);
                        if (value)
                        {
                            pawn.data["moveY"] = -1;
                        }
                    }
                    break;

                case "down":
                    if (value && !pawn.data["bIsOnLadder"] && this.characterCanClimb(pawn))
                    {
                        var ladder = this.getClimbableLadder(pawn);
                        if (ladder)
                        {
                            var ladderOffset = (ladder.data.height * 0.5) - 30;
                            if (pawn.position[1] < (ladder.position[1] + ladderOffset))
                            {
                                this.startLadderClimb(pawn, ladder);
                            }
                        }
                    }
                    if (pawn.data["bIsOnLadder"])
                    {
                        pawn.data["bWantsToClimb"] = value;
                        //var climbMult = 0.5;
                        //if (pawn.velocity[1] < (maxSpeed * climbMult)) pawn.applyImpulse([0, (moveSpeed)]);
                        if (value)
                        {
                            pawn.data["moveY"] = 1;
                        }
                    }
                    break;

                case "jump":
                    if (value && this.characterCanJump(pawn))
                    {
                        if (pawn.data["bIsOnLadder"])
                        {
                            this.leaveLadder(pawn);
                        }
                        pawn.velocity[1] = -pawn.data["jumpHeight"];
                        pawn.wakeUp();

                        this.requestEvent({
                            eventId: GameServer.EVENT_PAWN_ACTION,
                            pawnId: pawn.data.id,
                            type: GameServer.PAWN_JUMP
                        });
                    }
                    break;

                case "crouch":
                    pawn.data["bWantsToCrouch"] = value && this.characterCanCrouch(pawn);
                    if (pawn.data["bIsOnLadder"] && !pawn.data["bBot"])
                    {
                        this.leaveLadder(pawn);
                        pawn.wakeUp();
                    }
                    break;

                case "sprint":
                    pawn.data["bWantsToSprint"] = value && this.characterCanSprint(pawn);
                    break;

                case "weapon":
                    var item = this.getCurrentCharacterInventoryItem(pawn);
                    if (item)
                    {
                        if (this.characterIsFree(pawn))
                        {
                            if (this.hasMod(item, Mods.BASE_MODE_SELECTOR))
                            {
                                item["bAirOnly"] = !item["bAirOnly"];
                                item["lookModifier"] = item["bAirOnly"] ? 2.5 : 2;
                                this.requestEvent({
                                    eventId: GameServer.EVENT_PLAYER_UPDATE_INVENTORY,
                                    pawnId: pawn.data.id,
                                    index: pawn.data.currentInventoryIndex,
                                    type: GameServer.INV_AMMO_ADD,
                                    value: 0,
                                    sfxId: "wpn_bolt_open"
                                });
                            }
                        }
                    }
                    break;

                case "ads":
                    pawn.data["bAds"] = value == true;
                    break;

                case "reload":
                    this.reloadCharacterWeapon(pawn, true);
                    break;

                case "killstreak_next":
                    if (value)
                    {
                        this.cyclePlayerCurrentKillstreakIndex(pawn.data["id"], 1);
                    }
                    break;

                case "killstreak_prev":
                    if (value)
                    {
                        this.cyclePlayerCurrentKillstreakIndex(pawn.data["id"], -1);
                    }
                    break;
            }
        }
    }

    cyclePlayerCurrentKillstreakIndex(_playerId, _val)
    {
        var ps = this.getPlayerStateById(_playerId);
        if (ps)
        {
            var killstreaks = ps["killstreaks"];
            if (killstreaks.length > 1)
            {
                var prev = ps["currentKillstreakIndex"];
                ps["currentKillstreakIndex"] = Math.max(0, Math.min(killstreaks.length - 1, ps["currentKillstreakIndex"] + _val));
                if (prev !== ps["currentKillstreakIndex"])
                {
                    this.onEvent({
                        eventId: GameServer.EVENT_PLAYER_UPDATE,
                        playerId: _playerId,
                        data: {
                            currentKillstreakIndex: ps["currentKillstreakIndex"]
                        }
                    });
                }
            }
        }
    }

    handleControllableInput(_body, _data)
    {
        if (!_body || !_data)
        {
            return;
        }
        var type = _body.data["type"];
        var keyId = _data["keyId"];
        var value = _data["value"];
        var data = _body.data;
        var map = this.getCurrentMapData();
        switch (type)
        {
            case "car":
                switch (keyId)
                {
                    case "left":
                        if (value && _body.position[0] > 0) _body.data["moveX"] = -1; //_body.applyForce([-carSpeed, 0]);
                        break;

                    case "right":
                        if (value && _body.position[0] < map.width) _body.data["moveX"] = 1; //_body.applyForce([carSpeed, 0]);
                        break;
                }
                break;

            case "helicopter":
                if (!data["bBot"] && !data["bNoInput"])
                {
                    var heliSpeed = (data["bPlayerControlled"] ? data["moveSpeed"] : 400);
                    heliSpeed = Math.round(heliSpeed * this.localData.settings.fps_mult);                    
                    switch (keyId)
                    {
                        case "left":
                            if (value && _body.position[0] > 0)
                            {
                                _body.applyForce([-heliSpeed, 0]);
                            }
                            break;

                        case "right":
                            if (value && _body.position[0] < map.width)
                            {                                
                                _body.applyForce([heliSpeed, 0]);
                            }
                            break;

                        case "up":
                            if (value && _body.position[1] > 0)
                            {
                                _body.applyForce([0, -heliSpeed]);
                            }
                            break;

                        case "down":
                            if (value && _body.position[1] < map.height)
                            {
                                _body.applyForce([0, heliSpeed]);
                            }
                            break;

                        case "ads":
                            switch (data["killstreakId"])
                            {
                                case Killstreaks.KILLSTREAK_COBRA_CONTROLLABLE:
                                    data["bWantsToFireRocket"] = value == true;
                                    break;

                                case Killstreaks.KILLSTREAK_SCOUT:
                                    if (value)
                                    {
                                        if (_body["constraint"])
                                        {
                                            this.dropHelicopterCrate(_body);
                                        }
                                    }
                                    break;
                            }                            
                            break;
                    }
                    if (data["bPlayerControlled"])
                    {
                        var padding = 500;
                        var x = Math.max(padding, Math.min(map.width - padding, _body.position[0]));
                        var y = Math.max(padding, Math.min(1500, _body.position[1]));
                        data.heliData.destination = [x, y];
                    }
                }
                break;
        }
    }

    removeSpawnProtection(_playerId)
    {
        var curPlayerData = this.getPlayerStateById(_playerId);
        if (curPlayerData)
        {
            if (curPlayerData["timer_spawnProtection"] != undefined)
            {
                delete curPlayerData["timer_spawnProtection"];
                curPlayerData["bSpawnProtection"] = false;
                this.onEvent({
                    eventId: GameServer.EVENT_PLAYER_UPDATE,
                    playerId: curPlayerData["id"],
                    data: {
                        bSpawnProtection: curPlayerData["bSpawnProtection"]
                    }
                });
            }
        }
    }

    stopAllTimers()
    {
        var localData = this.localData;
        if (localData["timer_game"])
        {
            var timer = localData["timer_game"];
            clearInterval(timer);
            delete localData["timer_game"];
        }
        if (localData["timer_preGame"])
        {
            timer = localData["timer_preGame"];
            clearInterval(timer);
            delete localData["timer_preGame"];
        }
        if (localData["timer_wave"])
        {
            timer = localData["timer_wave"];
            clearInterval(timer);
            delete localData["timer_wave"];
        }
        if (localData["timer_waveSpawn"])
        {
            timer = localData["timer_waveSpawn"];
            clearInterval(timer);
            delete localData["timer_waveSpawn"];
        }
        var players = localData["playerStates"];
        for (var i = 0; i < players.length; i++)
        {
            var player = players[i];
            timer = player["timer_respawn"];
            if (timer)
            {
                delete player["timer_respawn"];
            }
            timer = player["timer_spawnProtection"];
            if (timer)
            {
                delete player["timer_spawnProtection"];
            }
        }
    }

    onFlagReturned(_flag, _playerId)
    {
        var ps = this.getPlayerStateById(_playerId);
        if (ps)
        {
            ps["returns"]++;
            this.onEvent({
                eventId: GameServer.EVENT_PLAYER_UPDATE,
                playerId: _playerId,
                data: {
                    returns: ps["returns"]
                }
            });
            this.onEvent({
                eventId: GameServer.EVENT_PLAYER_FLAG,
                playerId: _playerId,
                team: _flag.data["team"],
                type: "returned"
            });
        }
        this.addAnnouncerMessage("flag_returned", _flag.data["team"]);
    }

    onFlagDropped(_flag, _playerId)
    {
        _flag.wakeUp();
        this.onEvent({
            eventId: GameServer.EVENT_PLAYER_FLAG,
            playerId: _playerId,
            team: _flag.data["team"],
            type: "dropped"
        });
        switch (this.localData.gameModeData["id"])
        {
            case GameMode.CAPTURE_THE_FLAG:
                this.addAnnouncerMessage("flag_dropped", _flag.data["team"]);
                break;

            case GameMode.DEFENDER:
                this.localData.gameModeData["flagTeam"] = null;
                this.onEvent({
                    eventId: GameServer.EVENT_GAME_UPDATE,
                    gameModeData: {
                        flagTeam: null
                    }
                });
                this.addAnnouncerMessage("flagd_dropped", _flag.data["team"]);
                break;
        }
    }

    onFlagPickedUp(_flag, _playerId)
    {
        this.onEvent({
            eventId: GameServer.EVENT_PLAYER_FLAG,
            playerId: _playerId,
            team: _flag.data["team"],
            type: "picked_up"
        });
        this.addAnnouncerMessage("flag_has", _flag.data["team"] == 0 ? 1 : 0);
    }

    onDefenderFlagPickedUp(_flag, _playerId)
    {
        var ps = this.getPlayerStateById(_playerId);
        this.onEvent({
            eventId: GameServer.EVENT_PLAYER_FLAG,
            playerId: _playerId,
            team: _flag.data["team"],
            type: "picked_up"
        });
        if (ps)
        {
            this.localData.gameModeData["flagTeam"] = ps.team;
            this.onEvent({
                eventId: GameServer.EVENT_GAME_UPDATE,
                gameModeData: {
                    flagTeam: ps.team
                }
            });
            this.addAnnouncerMessage("flagd_achieve", ps.team);
        }
    }

    onFlagPoint(_team, _carrierId)
    {
        if (_team != undefined)
        {
            var localData = this.localData;
            var scores = localData.gameModeData["scores"];
            scores[_team]++;
            this.onEvent({
                eventId: GameServer.EVENT_GAME_UPDATE,
                gameModeData: {
                    scores: scores,
                    pointTeam: _team
                }
            });
            if (scores[_team] >= localData.gameModeData["scoreLimit"])
            {
                this.requestEvent({
                    eventId: GameServer.EVENT_GAME_END,
                    condition: MatchState.END_CONDITION_SCORE,
                    winningTeam: _team
                });
            }
        }
        if (_carrierId != undefined)
        {
            var ps = this.getPlayerStateById(_carrierId);
            if (ps)
            {
                if (ps["score"] >= 0)
                {
                    ps["score"]++;
                    this.onEvent({
                        eventId: GameServer.EVENT_PLAYER_UPDATE,
                        playerId: _carrierId,
                        data: {
                            score: ps["score"]
                        }
                    });
                }
            }
        }
    }

    onFlagCaptured(_flag, _playerIds)
    {
        var team = _flag.data["team"];
        var localData = this.localData;
        if (_playerIds)
        {
            for (var i = 0; i < _playerIds.length; i++)
            {
                var ps = this.getPlayerStateById(_playerIds[i]);
                if (ps)
                {
                    ps["captures"]++;
                    this.onEvent({
                        eventId: GameServer.EVENT_PLAYER_UPDATE,
                        playerId: _playerIds[i],
                        data: {
                            captures: ps["captures"]
                        }
                    });
                }
            }
            var eventData = {
                eventId: GameServer.EVENT_PLAYER_FLAG,
                team: _flag.data["team"],
                playerIds: _playerIds,
                type: "captured",
                flagNum: _flag.data["num"]
            };
            this.onEvent(eventData);
        }
        switch (localData.gameModeData["id"])
        {
            case GameMode.CAPTURE_THE_FLAG:
                var scores = localData.gameModeData["scores"];
                scores[team]++;
                this.onEvent({
                    eventId: GameServer.EVENT_GAME_UPDATE,
                    gameModeData: {
                        scores: scores
                    }
                });
                if (scores[team] >= localData.gameModeData["scoreLimit"])
                {
                    this.requestEvent({
                        eventId: GameServer.EVENT_GAME_END,
                        condition: MatchState.END_CONDITION_SCORE,
                        winningTeam: team
                    });
                }
                this.addAnnouncerMessage("flag_captured", _flag.data["team"]);
                break;

            case GameMode.DOMINATION:
                this.addAnnouncerMessage(_flag.data["str"] + "_captured", _flag.data["team"]);
                break;

            case GameMode.HEADQUARTERS:
                var gameModeData = this.localData.gameModeData;
                var flagTeam = _flag.data["team"];                
                if (gameModeData["hqTeam"] != null)
                {
                    this.addScore(flagTeam, 10);
                    this.winRound(MatchState.END_CONDITION_HEADQUARTERS, -1);
                }
                else
                {
                    gameModeData["hqTeam"] = flagTeam;
                }
                this.onEvent({
                    eventId: GameServer.EVENT_GAME_UPDATE,
                    gameModeData: {
                        hqTeam: gameModeData["hqTeam"],
                        scores: gameModeData.scores
                    }
                });
                this.addAnnouncerMessage("hq_captured", flagTeam);
                break;
        }
    }

    isTeamGameMode()
    {
        var data = this.getGameModeData(this.localData.gameModeData["id"]);
        if (data)
        {
            return data["bTeam"];
        }
        return false;
    }

    allowsKillstreaks()
    {
        var data = this.getGameModeData(this.localData.gameModeData["id"]);
        if (data)
        {
            return data["bAllowKillstreaks"];
        }
        return true;
    }

    onPlayerKill(_playerId, _damageAmount, _victimId, _causerId, _damageInfo, _bHeadshot)
    {
        var localData = this.localData;
        var ps = this.getPlayerStateById(_playerId);
        var bSuicide = _playerId == _victimId;
        var bAddToKills = true;
        if (!bSuicide && _damageInfo["bDirectlyCausedByPlayer"])
        {
            var killer = this.getObjectById(_playerId);
            if (killer && this.characterHasPerk(killer, Perks.PERK_WEAPON_VAMPIRE))
            {
                killer.data["health"] = Math.min(killer.data["health"] + 100, killer.data["maxHealth"]);
                this.pushObjectDataUpdate(killer.data.id, ["health"]);
            }
        }
        var victim = this.getObjectById(_victimId);
        if (ps)
        {
            var killedBy = ps["killedBy"];
            if (killedBy)
            {
                var index = killedBy.indexOf(_victimId);
                if (index >= 0)
                {
                    var bRevenge = true;
                    killedBy.splice(index);
                }
            }            
            var bTeamKill = !bSuicide && (victim ? ps["team"] == victim.data["team"] : false);
            if (!bSuicide && !bTeamKill)
            {                
                var bVictimIsCharacter = victim ? victim.data["type"] == "character" : false;
                bAddToKills = localData["bModeGame"] ? bVictimIsCharacter : true;
                if (bAddToKills)
                {
                    ps["kills"]++;
                    if (_bHeadshot)
                    {
                        ps["headshots"]++;
                    }
                    if (_damageInfo["bMelee"])
                    {
                        ps["melees"]++;
                    }
                    ps["multiKillTimer"] = this.localData.settings.fps;
                    ps["multiKillCount"]++;
                    var victimPlayerState = this.getPlayerStateById(_victimId);
                    if (this.isTeamGameMode())
                    {
                        ps["avengerTimer"] = this.localData.settings.fps;
                        if (victimPlayerState)
                        {
                            if (victimPlayerState["avengerTimer"] > 0)
                            {
                                var bAvenger = true;
                            }                            
                        }
                        if (victim)
                        {
                            var damagedBy = victim.data["damagedBy"];
                            if (damagedBy && damagedBy.length > 0)
                            {
                                for (var i = 0; i < damagedBy.length; i++)
                                {
                                    if (damagedBy[i] != _playerId)
                                    {
                                        let assistPlayer = this.getPlayerStateById(damagedBy[i]);
                                        if (assistPlayer)
                                        {
                                            assistPlayer["assists"]++;
                                            this.onEvent({
                                                eventId: GameServer.EVENT_PLAYER_UPDATE,
                                                playerId: damagedBy[i],
                                                data: {
                                                    assists: assistPlayer["assists"],
                                                }
                                            });
                                        }
                                    }
                                }
                            }
                        }
                    }
                    if (localData["bKillstreaks"])
                    {
                        if (victimPlayerState)
                        {
                            var nextKillstreak = victimPlayerState["currentKillstreak"] + 1;
                            if (victimPlayerState.desiredKillstreaks && victimPlayerState.desiredClassData)
                            {
                                var victimKillstreaks = victimPlayerState.desiredKillstreaks[victimPlayerState.desiredClassData["killstreak"]];
                                if (victimKillstreaks)
                                {
                                    for (var i = 0; i < victimKillstreaks.length; i++)
                                    {
                                        var curKillstreak = this.getKillstreakData(victimKillstreaks[i]);
                                        if (curKillstreak && curKillstreak["kills"] == nextKillstreak)
                                        {
                                            var bBuzzKill = true;
                                            break;
                                        }
                                    }
                                }
                            }
                        }
                        var causer = this.getObjectById(_causerId);
                        if (causer)
                        {
                            switch (causer.data["type"])
                            {
                                case "character":
                                case "grenade":
                                case "rocket":
                                case "projectile":
                                default:
                                    if (ps["bHasPawn"])
                                    {
                                        ps["currentKillstreak"]++;
                                        if (ps.desiredKillstreaks && ps.desiredClassData)
                                        {
                                            var killstreaks = ps.desiredKillstreaks[ps.desiredClassData["killstreak"]];
                                        }
                                        if (killstreaks)
                                        {
                                            var maxKillstreaks = 3;
                                            for (var i = 0; i < killstreaks.length; i++)
                                            {
                                                if (i >= maxKillstreaks)
                                                {
                                                    break;
                                                }
                                                var curKillstreak = this.getKillstreakData(killstreaks[i]);
                                                if (curKillstreak && curKillstreak["kills"] == ps["currentKillstreak"])
                                                {
                                                    this.requestEvent({
                                                        eventId: GameServer.EVENT_PLAYER_EARN_KILLSTREAK,
                                                        playerId: ps.id,
                                                        killstreakId: curKillstreak.id
                                                    });
                                                    break;
                                                }
                                            }
                                        }
                                    }
                                    break;
                            }
                        }
                    }
                }
                var eventObj = {
                    eventId: GameServer.EVENT_PLAYER_UPDATE,
                    playerId: _playerId,
                    data: {
                        kills: ps["kills"],
                        headshots: ps["headshots"],
                        melees: ps["melees"],
                        currentKillstreak: ps["currentKillstreak"],
                        currentKillstreakIndex: ps["currentKillstreakIndex"],
                        bRevenge: bRevenge,
                        bAvenger: bAvenger,
                        bBuzzKill: bBuzzKill
                    }
                };
                if (localData["bBattlezone"])
                {
                    var xpReward = 100;
                    switch (victim.data.type)
                    {
                        case "helicopter":
                            xpReward = victim.data.maxHealth;
                            break;

                        case "turret":
                            xpReward = 1000;
                            break;

                        default:
                            let curPlayer = this.getPlayerStateById(victim.data.id);
                            if (curPlayer)
                            {
                                xpReward = 1000;
                            }
                            else if (victim.data.killReward)
                            {
                                xpReward = victim.data.killReward;
                            }
                            xpReward = Math.max(victim.data.maxHealth, xpReward);
                            break;
                    }
                    this.addBattlezoneLoot(ps.id, xpReward, 0);
                    eventObj.data.xp = ps.xp;
                }
                else if (localData["bSurvival"])
                {
                    var victim = this.getObjectById(_victimId);
                    var object = this.getObjectById(_playerId);
                    if (object && object.data && object.data["team"] == 0 && victim.data["team"] != 0)
                    {
                        var gameModeData = localData.gameModeData;
                        gameModeData["kills"]++;
                        gameModeData["waveKills"]++;

                        if (_damageInfo["bHeadshot"])
                        {
                            if (_damageInfo["bDirectlyCausedByPlayer"])
                            {
                                this.addPlayerMoneyMultiplier(ps["id"], 0.1);
                            }
                            gameModeData["waveHeadshots"]++;
                        }
                        else if (_damageInfo["bMelee"])
                        {
                            this.addPlayerMoneyMultiplier(ps["id"], 0.1);
                            gameModeData["waveMelees"]++;
                        }
                        else if (victim.data["type"] == "character" || victim.data["type"] == "infestor")
                        {
                            if (ps["multiKillCount"] < 2 && _damageInfo["bDirectlyCausedByPlayer"])
                            {
                                if (_damageInfo["damageType"] == DamageType.DAMAGE_BULLET && !_damageInfo["bHeli"] && !_damageInfo["bTurret"])
                                {
                                    this.resetPlayerMoneyMultiplier(ps["id"]);
                                }
                            }
                        }

                        if (localData["bUseMoneyMultiplier"])
                        {
                            eventObj.data.moneyMultiplier = ps["moneyMultiplier"];
                        }

                        this.onEvent({
                            eventId: GameServer.EVENT_GAME_UPDATE,
                            gameModeData: {
                                wave: gameModeData["wave"],
                                kills: gameModeData["kills"]
                            }
                        });

                        if (_damageInfo["moneyReward"])
                        {
                            var moneyReward = this.RoundToNearest(_damageInfo["moneyReward"] * ps["moneyMultiplier"]);
                            this.addPlayerMoney(_playerId, moneyReward);
                        }
                    }
                }
                else
                {
                    var gameModeData = {};
                    if (victim && victim.data.type == "character")
                    {
                        if (localData["bModeGame"] && !localData.gameModeData["bFirstBlood"])
                        {
                            gameModeData["firstBloodPlayerId"] = _playerId;
                            localData.gameModeData["bFirstBlood"] = true;
                        }
                    }
                    switch (localData.gameModeData["id"])
                    {
                        case GameMode.ASSASSINATION:
                            if (ps.bVIP)
                            {
                                ps.score++;
                                eventObj.data.score = ps.score;
                            }
                            break;

                        case GameMode.GUN_GAME:
                            if (bAddToKills)
                            {
                                var gunGameWeapons = this.localData.gameModeData["weapons"];
                                if (_damageInfo["weaponId"] == gunGameWeapons[ps["gunIndex"]].id)
                                {
                                    var updateObj = {
                                        playerId: ps["id"]
                                    };
                                    ps["gunKills"]++;
                                    if (ps["gunKills"] >= this.localData.gameModeData["killsPerGun"])
                                    {
                                        if (ps["gunIndex"] + 1 >= gunGameWeapons.length)
                                        {
                                            //Player wins
                                            this.requestEvent({
                                                eventId: GameServer.EVENT_GAME_END,
                                                condition: MatchState.END_CONDITION_SCORE,
                                                winningTeam: ps["team"]
                                            });
                                        }
                                        else
                                        {
                                            ps["gunIndex"]++;
                                            updateObj.gunIndex = ps["gunIndex"];
                                            ps["gunKills"] = 0;
                                            var pawn = this.getObjectById(ps["id"]);
                                            if (pawn)
                                            {
                                                this.cancelCharacterReload(pawn);
                                            }
                                            var timeout = setTimeout(() =>
                                            {
                                                if (this.localData)
                                                {
                                                    var pawn = this.getObjectById(ps["id"]);
                                                    if (pawn)
                                                    {
                                                        pawn.data["bWantsToFire"] = false;
                                                        pawn.data.weapon["bFireDelay"] = true;
                                                        pawn.data.weapon["bFireHandler"] = false;
                                                        pawn.data.weapon["bBurstFireHandler"] = false;
                                                    }
                                                    //Equip next weapon
                                                    var gunData = gunGameWeapons[ps["gunIndex"]];
                                                    var nextWeaponData = this.getWeaponData(gunData.id);
                                                    if (gunData.mods)
                                                    {
                                                        this.applyWeaponMods(nextWeaponData, gunData.mods);
                                                    }
                                                    this.requestEvent({
                                                        eventId: GameServer.EVENT_PLAYER_UPDATE_INVENTORY,
                                                        pawnId: ps["id"],
                                                        index: 0,
                                                        item: nextWeaponData,
                                                        type: GameServer.INV_ITEM_REPLACE
                                                    });
                                                }
                                            }, 100);                                           
                                            
                                        }
                                    }
                                    updateObj.gunKills = ps["gunKills"];
                                    this.onEvent({
                                        eventId: GameServer.EVENT_PLAYER_UPDATE,
                                        playerId: ps["id"],
                                        data: updateObj
                                    });
                                    this.onEvent({
                                        eventId: GameServer.EVENT_GAME_UPDATE,
                                        gameModeData: {
                                            playerId: ps["id"]
                                        }
                                    });
                                }
                            }
                            break;

                        case GameMode.DEATHMATCH:
                            if (bAddToKills)
                            {
                                gameModeData["bPlayerKill"] = true;
                                if (ps["kills"] >= localData.gameModeData["scoreLimit"])
                                {
                                    this.requestEvent({
                                        eventId: GameServer.EVENT_GAME_END,
                                        condition: MatchState.END_CONDITION_SCORE,
                                        winningTeam: ps["team"]
                                    });
                                }
                            }
                            break;
                        case GameMode.TEAM_DEATHMATCH:
                            if (bAddToKills)
                            {
                                var scores = localData.gameModeData["scores"];
                                scores[ps["team"]]++;
                                gameModeData["scores"] = scores;
                                if (scores[ps["team"]] >= localData.gameModeData["scoreLimit"])
                                {
                                    this.requestEvent({
                                        eventId: GameServer.EVENT_GAME_END,
                                        condition: MatchState.END_CONDITION_SCORE,
                                        winningTeam: ps["team"]
                                    });
                                }
                            }
                            break;
                    }
                }
                this.onEvent(eventObj);
                if (gameModeData)
                {
                    if (Object.keys(gameModeData).length > 0)
                    {
                        this.onEvent({
                            eventId: GameServer.EVENT_GAME_UPDATE,
                            gameModeData: gameModeData
                        });
                    }
                }
            }
        }
    }

    addPlayerMoneyMultiplier(_playerId, _val)
    {
        if (!this.localData["bUseMoneyMultiplier"])
        {
            return;
        }
        var ps = this.getPlayerStateById(_playerId);
        if (ps)
        {
            ps["moneyMultiplier"] = Math.min(Settings.SURVIVAL_MULTIPLIER_MAX, ps["moneyMultiplier"] + _val);
        }
    }

    resetPlayerMoneyMultiplier(_playerId)
    {
        if (!this.localData["bUseMoneyMultiplier"])
        {
            return;
        }
        var ps = this.getPlayerStateById(_playerId);
        if (ps)
        {
            ps["moneyMultiplier"] = 1;
        }
    }

    onPawnDeath(_pawnId, _damageAmount, _killerId, _causerId, _damageInfo, _bHeadshot)
    {
        var ps = this.getPlayerStateById(_pawnId);
        var pawn = this.getObjectById(_pawnId);
        var pawnTeam = pawn.data["team"];
        var ragdoll = null;
        var vx = 0; //pawn.velocity[0];
        var vy = 0; //pawn.velocity[1];
        var va = Math.random(-50, 50);
        var causer = this.getObjectById(_causerId);
        if (causer)
        {
            var rad = this.Angle(causer.position[0], causer.position[1], pawn.position[0], pawn.position[1]) + this.ToRad(this.Random(-5, 5));
            var force = (_damageAmount * 60) * (_bHeadshot ? 1.4 : 1);
            var maxForce = _damageInfo["damageType"] === DamageType.DAMAGE_EXPLOSIVE ? 10000 : 7000;
            force = Math.max(1000, Math.min(force, maxForce));
            vx = Math.cos(rad) * force;
            vy = Math.sin(rad) * force;
        }
        if (pawn)
        {
            this.emitAISound(pawn.position);
        }        
        switch (pawn.data["type"])
        {
            case "infestor":
                ragdoll = {
                    id: this.getRandomUniqueId(),
                    x: Math.round(pawn.position[0]),
                    y: Math.round(pawn.position[1]),
                    type: "ragdoll",
                    vx: -vx,
                    vy: -vy,
                    va: va,
                    data: {
                        type: "infestor",
                        infestorType: pawn.data["infestorType"],
                        scale: pawn.data["scale"]
                    },
                    playerId: _pawnId
                };
                this.removeNextStep(pawn);
                break;

            case "car":
                if (pawn.data.carType == Car.TYPE_RCXD)
                {
                    this.createExplosion({
                        eventId: GameServer.EVENT_SPAWN_EXPLOSION,
                        x: pawn.position[0],
                        y: pawn.position[1],
                        radius: 450,
                        damage: 600,
                        playerId: pawn.data.carData["playerId"] ? pawn.data.carData["playerId"] : pawn.data["id"],
                        causerId: pawn.data["id"],
                        weaponId: Killstreaks.KILLSTREAK_RCXD,
                        bDirectlyCausedByPlayer: true
                    });
                }
                this.removeNextStep(pawn);
                break;

            case "character":
                if (this.localData["bSurvival"])
                {
                    if (this.Random(1, 10) == 1)
                    {
                        this.createScavengerPack(pawn.position, {});
                    }
                }
                else if (!pawn.data["bZombie"] && _damageInfo["damageType"] != DamageType.DAMAGE_EXPLOSIVE && (this.localData["bModeGame"] || this.localData["bSandbox"] || this.localData["bBattlezone"]))
                {
                    this.createScavengerPack(pawn.position, {});
                }
                if (pawn.data["zombieType"] === Zombie.TYPE_EXPLODER || pawn.data["zombieType"] === Zombie.TYPE_EXPLODER_BOSS)
                {
                    var weapon = this.getWeaponData(pawn.data["zombieType"]);
                    if (weapon)
                    {
                        this.createExplosion({
                            eventId: GameServer.EVENT_SPAWN_EXPLOSION,
                            x: Math.round(pawn.position[0]),
                            y: Math.round(pawn.position[1]),
                            radius: weapon["radius"],
                            damage: weapon["damage"],
                            playerId: _pawnId,
                            causerId: _pawnId,
                            weaponId: weapon["id"],
                            bDirectlyCausedByPlayer: true
                        });
                    }
                }
                else
                {
                    var avatar = pawn.data.avatarData;
                    if (avatar && avatar.body == "c4_vest")
                    {
                        var bSuicideVest = true;
                        this.createExplosion({
                            eventId: GameServer.EVENT_SPAWN_EXPLOSION,
                            x: Math.round(pawn.position[0]),
                            y: Math.round(pawn.position[1]),
                            radius: pawn.data.bBot ? 400 : 1000,
                            damage: 400,
                            playerId: pawn.data.id,
                            causerId: pawn.data.id,
                            weaponId: "c4",
                            bDirectlyCausedByPlayer: true
                        });
                    }
                    var weapon = this.getWeaponData(_damageInfo["weaponId"]);
                    var bGib = bSuicideVest == true;
                    if (_damageInfo["damageType"] == DamageType.DAMAGE_EXPLOSIVE)
                    {
                        bGib = pawn.data["bZombie"] ? true : (this.RandomBoolean() && _damageAmount >= 100);
                    }
                    if (weapon && !bGib)
                    {
                        switch (weapon["round"])
                        {
                            case "50bmg":
                            case "408":
                                bGib = true;
                                break;
                        }
                        switch (weapon["type"])
                        {
                            case Weapon.TYPE_SHOTGUN:
                                bGib = _damageInfo["bNearshot"];
                                break;
                            default:
                                bGib = _damageAmount > 200 && !_bHeadshot;
                                break;
                        }
                        switch (weapon["id"])
                        {
                            case "melee_katana":
                            case "melee_machete":
                            case "melee_hatchet":
                            case "minigun":
                            case "mg42":
                                bGib = true;
                                break;
                        }
                    }
                    var bGibHeadshot = _bHeadshot && _damageAmount >= 100; // && pawn.data["bZombie"];

                    ragdoll = {
                        id: this.getRandomUniqueId(),
                        x: Math.round(pawn.position[0]),
                        y: Math.round(pawn.position[1]),
                        type: "ragdoll",
                        vx: -vx,
                        vy: -vy,
                        va: va,
                        data: {
                            bHeadshot: bGibHeadshot,
                            damageAmount: _damageAmount,
                            type: "character",                            
                            bGib: bGib
                            //avatarData: pawn.data["avatarData"]
                        },
                        playerId: _pawnId
                    };
                    if (_damageInfo["damageType"] !== DamageType.DAMAGE_EXPLOSIVE && this.characterHasPerk(pawn, Perks.PERK_PLAYER_MARTYRDOM))
                    {
                        var fragData = this.getWeaponData("frag");
                        this.createGrenade(this.roundNumberArray(pawn.position), {
                            team: pawn.data["team"],
                            playerId: pawn.data["id"],
                            causerId: pawn.data["id"],
                            rotation: this.ToRad(-90),
                            velocity: 100,
                            damage: fragData["damage"],
                            weaponId: fragData["id"],
                            bStartDetonationAfterHit: fragData["bStartDetonationAfterHit"],
                            bImpact: fragData["bImpact"],
                            bMartyrdom: true
                        });
                    }
                }
                if (this.localData["bOperation"])
                {
                    if (pawn.data["team"] == 1)
                    {
                        if (this.Random(1, 10) == 1)
                        {
                            this.dropCharacterWeapon(pawn, pawn.data["currentInventoryIndex"]);
                        }
                    }
                    if (pawn.data.bFailIfKilled)
                    {
                        this.requestEvent({
                            eventId: GameServer.EVENT_GAME_END,
                            condition: MatchState.END_CONDITION_DEAD_ALLY_CAMPAIGN
                        });
                    }
                }
                else if (this.localData["bBattlezone"])
                {
                    if (pawn.data["bBot"])
                    {
                        if (this.Random(1, 2) == 1)
                        {
                            this.dropAllCharacterWeapons(pawn);
                        }
                    }
                    else
                    {
                        this.dropAllCharacterWeapons(pawn);
                    }
                }
                else if (this.localData["bSandbox"] && !pawn.data["bBot"])
                {
                    this.dropAllCharacterWeapons(pawn);
                }
                else if (!this.localData["bModeGame"])
                {
                    if (pawn.data["team"] == 1)
                    {
                        if (this.Random(1, this.localData.gameModeData["id"] == GameMode.SURVIVAL_STAKEOUT ? 5 : 10) == 1)
                        {
                            this.dropCharacterWeapon(pawn, pawn.data["currentInventoryIndex"]);
                        }
                    }
                }
                else
                {
                    if (this.Random(1, 10) == 1 || _damageInfo["damageType"] == DamageType.DAMAGE_MELEE)
                    {
                        this.dropCharacterWeapon(pawn, pawn.data["currentInventoryIndex"]);
                    }
                }
                if (pawn.data["interactableId"])
                {
                    var interactable = this.getObjectById(pawn.data["interactableId"]);
                    if (interactable && interactable.data["bLimitInteractions"])
                    {
                        delete interactable.data["currentPawnId"];
                    }
                }
                this.removeNextStep(pawn);
                break;

            case "helicopter":
                pawn.data.heliData["destination"] = null;
                pawn.data["destroyTimer"] = this.localData.settings.fps * 5;
                pawn.gravityScale = 1;
                pawn.angularForce += this.Random(-10, 10);
                pawn.shapes[0].collisionGroup = CollisionGroups.PAWN;
                pawn.shapes[0].collisionMask = CollisionGroups.GROUND;
                this.dropHelicopterCrate(pawn);
                break;

            default:
                this.removeNextStep(pawn);
                break;
        }
        if (ps)
        {
            ps["deaths"]++;
            var killedBy = ps["killedBy"];
            if (killedBy)
            {
                if (_killerId)
                {
                    if (killedBy.indexOf(_killerId) == -1)
                    {
                        killedBy.push(_killerId);
                    }
                }
            }
            switch (ps.desiredClassData["killstreak"])
            {
                case Killstreaks.TYPE_ASSAULT:
                case Killstreaks.TYPE_PERKS:
                    ps["currentKillstreak"] = 0;
                    break;

                case Killstreaks.TYPE_SUPPORT:
                    var killstreaks = ps.desiredKillstreaks[ps.desiredClassData["killstreak"]];
                    if (killstreaks)
                    {
                        var lastKillstreakId = killstreaks[killstreaks.length - 1];
                        if (lastKillstreakId)
                        {
                            var lastKillstreak = this.getKillstreakData(lastKillstreakId);
                            if (lastKillstreak)
                            {
                                if (ps["currentKillstreak"] >= lastKillstreak["kills"])
                                {
                                    ps["currentKillstreak"] = 0;
                                }
                            }
                        }
                    }
                    break;
            }
            this.endMultiKill(ps);
            this.onEvent({
                eventId: GameServer.EVENT_PLAYER_UPDATE,
                playerId: _pawnId,
                data: {
                    deaths: ps["deaths"],
                    currentKillstreak: ps["currentKillstreak"],
                    bHasPawn: false
                }
            });
            if (ps["controllableId"])
            {
                var controllable = this.getObjectById(ps["controllableId"]);
                if (controllable)
                {
                    switch (controllable.data["type"])
                    {
                        case "turret":
                            this.clearPlayerControllable(ps);
                            break;
                    }
                }
            }
        }
        var gameModeData = this.localData["gameModeData"];        
        if (this.localData["bSandbox"])
        {
            //...
        }
        else if (this.localData["bBattlezone"])
        {
            if (ps)
            {
                if (ps.shards > 0 || ps.xp > 0)
                {
                    this.createLootPack(pawn.position, {
                        shards: ps.shards,
                        xp: ps.xp
                    });
                }
                ps.shards = 0;
                ps.xp = 0;
                if (ps.lives >= 1)
                {
                    ps.lives--;
                    this.onEvent({
                        eventId: GameServer.EVENT_PLAYER_UPDATE,
                        playerId: ps.id,
                        data: {
                            lives: ps.lives,
                            shards: ps.shards,
                            xp: ps.xp
                        }
                    });
                }
                else
                {
                    //End game for player
                }
            }
            else
            {
                if (pawn.data.loot)
                {
                    this.createLootPack(pawn.position, {
                        shards: pawn.data.loot.shards,
                        xp: pawn.data.loot.xp
                    });
                }
                else if (this.Random(1, 5) == 1)
                {
                    this.createLootPack(pawn.position, {
                        shards: 0,
                        xp: this.RoundToNearest(this.Random(1000, 5000))
                    });
                }
            }
        }
        else if (this.localData.gameModeData.id == GameMode.ASSASSINATION)
        {
            if (ps)
            {
                if (ps.bVIP)
                {
                    this.winRound(MatchState.END_CONDITION_VIP_KILLED, this.localData.gameModeData.vipTeam == 0 ? 1 : 0, 1, {
                        id: _killerId
                    });
                    var bVIP = true;
                    this.addPlayerScore(_killerId, 10);
                }
            }
        }
        else if (!this.localData["bModeGame"])
        {
            if (this.localData.gameModeData.id == GameMode.OP_HOSTAGE)
            {
                if (pawn.data.bHostage)
                {
                    this.requestEvent({
                        eventId: GameServer.EVENT_GAME_END,
                        condition: MatchState.END_CONDITION_HOSTAGE_KILLED
                    });
                }
            }
            if (pawnTeam == 0)
            {
                if (ps)
                {
                    if (ps["moneyMultiplier"] != undefined)
                    {
                        this.resetPlayerMoneyMultiplier(ps["id"]);
                    }
                    var players = this.localData["playerStates"];
                    var numDead = 0;
                    for (var i = 0; i < players.length; i++)
                    {
                        var player = players[i];
                        var curPawn = this.getObjectById(player["id"])
                        if (!player["bHasPawn"] || !curPawn || !curPawn.data["health"])
                        {
                            numDead++;
                        }
                    }
                    if (numDead == players.length && !this.localData.bDeadswitch)
                    {
                        this.requestEvent({
                            eventId: GameServer.EVENT_GAME_END,
                            condition: MatchState.END_CONDITION_DEAD
                        });
                    }
                    else
                    {
                        ps["inventory"] = pawn.data["inventory"];
                        ps["equipment"] = pawn.data["equipment"];
                        var bReviver = true;
                    }
                }
            }
            else
            {
                if (pawn.data["type"] != "equipment")
                {
                    gameModeData["enemiesRemaining"]--;
                }
                if (gameModeData["id"] == GameMode.SURVIVAL_STAKEOUT)
                {
                    var wave = gameModeData["wave"];
                    if (wave > 15)
                    {
                        if (gameModeData["enemiesRemaining"] === Math.round(gameModeData["enemies"] * 0.25))
                        {
                            this.createStakeoutAirdrops();
                        }
                        if (gameModeData["enemiesRemaining"] === Math.round(gameModeData["enemies"] * 0.5))
                        {
                            this.createStakeoutAirdrops();
                        }
                        if (gameModeData["enemiesRemaining"] === Math.round(gameModeData["enemies"] * 0.75))
                        {
                            this.createStakeoutAirdrops();
                        }
                    }
                    else if (wave > 10)
                    {
                        if (gameModeData["enemiesRemaining"] === Math.round(gameModeData["enemies"] * 0.33))
                        {
                            this.createStakeoutAirdrops();
                        }
                        if (gameModeData["enemiesRemaining"] === Math.round(gameModeData["enemies"] * 0.66))
                        {
                            this.createStakeoutAirdrops();
                        }
                    }
                    else if (wave > 5)
                    {
                        if (gameModeData["enemiesRemaining"] === Math.round(gameModeData["enemies"] * 0.5))
                        {
                            this.createStakeoutAirdrops();
                        }
                    }
                }
                if (gameModeData["enemiesRemaining"] == 0)
                {
                    if (this.localData["bSurvival"])
                    {
                        this.onSurvivalWaveComplete();
                    }
                    else if (gameModeData["id"] == GameMode.OP_ELIMINATION)
                    {
                        this.requestEvent({
                            eventId: GameServer.EVENT_GAME_END,
                            result: MatchState.END_RESULT_WIN,
                            condition: MatchState.END_CONDITION_OBJECTIVE
                        });
                    }
                }
                this.onEvent({
                    eventId: GameServer.EVENT_GAME_UPDATE,
                    gameModeData: {
                        enemiesRemaining: gameModeData["enemiesRemaining"]
                    }
                });
            }
        }
        /*
        var causer = this.getObjectById(_causerId);
        if (causer)
        {
            switch (causer.data["type"])
            {
                case "grenade":
                case "rocket":
                    _causerId = _killerId;
                    break;
            }
        }
        */
        var useCauserId = _causerId;
        if (causer)
        {
            switch (causer.data.type)
            {
                case "rocket":
                    useCauserId = causer.data.rocketData.causerId;
                    break;

                case "grenade":
                    useCauserId = causer.data.grenadeData.playerId;
                    break;
            }
        }
        this.onEvent({
            eventId: GameServer.EVENT_PAWN_DIE,
            data: {
                id: _pawnId,
                damageAmount: _damageAmount,
                killerId: _killerId,
                causerId: useCauserId,
                damageInfo: _damageInfo,
                bHeadshot: _bHeadshot,
                ragdoll: ragdoll,
                bReviver: bReviver,
                bVIP: bVIP
            }
        });
        switch (gameModeData["id"])
        {
            case GameMode.INFECTED:
                var players = this.localData["playerStates"];
                var numInfected = this.getNumInfected();
                if (ps && !ps["bInfected"])
                {
                    if (numInfected >= players.length - 1)
                    {
                        this.requestEvent({
                            eventId: GameServer.EVENT_GAME_END,
                            condition: MatchState.END_CONDITION_INFECTED,
                            winningTeam: 1
                        });
                    }
                    else
                    {
                        if (ps)
                        {
                            this.makePlayerInfected(ps["id"]);
                        }
                    }
                }
                break;

            case GameMode.GUN_GAME:
                if (ps)
                {
                    if (_damageInfo["weaponId"] == "none")
                    {
                        ps.gunIndex = Math.max(0, ps.gunIndex - 1);
                        ps.gunKills = 0;
                        this.onEvent({
                            eventId: GameServer.EVENT_PLAYER_UPDATE,
                            playerId: ps["id"],
                            data: {
                                gunIndex: ps.gunIndex,
                                gunKills: ps.gunKills,
                                bSetback: true
                            }
                        });
                    }
                }
                break;
        }
        if (bReviver)
        {
            this.createReviver(this.getRandomUniqueId(), pawn.position, [vx, vy], va, this.localData["bOperation"], {
                playerId: _pawnId,
                interactTime: this.localData.settings.fps * 2
            });
        }
    }

    getNumInfected()
    {
        var players = this.localData["playerStates"];
        var numInfected = 0;
        for (var i = 0; i < players.length; i++)
        {
            if (players[i]["bInfected"])
            {
                numInfected++;
            }
        }
        return numInfected;
    }

    checkInfected()
    {
        if (!this.matchInProgress())
        {
            return;
        }
        var numInfected = this.getNumInfected();
        if (numInfected == 0 && this.localData.gameModeData["bFirstInfected"])
        {
            if (this.localData.playerStates.length >= 2)
            {
                //Make random player infected
                var index = this.Random(0, this.localData.playerStates.length - 1);
                var ps = this.localData.playerStates[index];
                this.makePlayerInfected(ps["id"]);
            }
            else
            {
                this.requestEvent({
                    eventId: GameServer.EVENT_GAME_END,
                    condition: MatchState.END_CONDITION_FORFEIT,
                    winningTeam: 0
                });
            }
        }
        else if (numInfected >= this.localData.playerStates.length)
        {
            this.requestEvent({
                eventId: GameServer.EVENT_GAME_END,
                condition: MatchState.END_CONDITION_INFECTED,
                winningTeam: 1
            });
        }
    }

    getEquipmentByPlayerId(_id, _weaponId)
    {
        var arr = [];
        if (_id)
        {
            var equipment = this.getEquipment();
            for (var i = 0; i < equipment.length; i++)
            {
                var item = equipment[i];
                if (item.data["ownerId"] == _id)
                {
                    if (_weaponId != undefined)
                    {
                        if (item.data.weaponData["id"] == _weaponId)
                        {
                            arr.push(item);
                        }
                    }
                    else
                    {
                        arr.push(item);
                    }
                }
            }
        }
        return arr;
    }

    removeEquipmentByPlayerId(_id, _weaponId)
    {
        if (_id)
        {
            var equipment = this.getEquipment();
            for (var i = 0; i < equipment.length; i++)
            {
                var item = equipment[i];
                if (item.data["ownerId"] == _id)
                {
                    if (_weaponId != undefined)
                    {
                        if (item.data.weaponData["id"] == _weaponId)
                        {
                            this.removeNextStep(item);
                        }
                    }
                    else
                    {
                        this.removeNextStep(item);
                    }
                }
            }
        }
    }

    onSurvivalWaveComplete()
    {
        var gameModeData = this.localData["gameModeData"];
        this.startWaveIntermission();
        var multBonus = 0;
        if (gameModeData["waveHeadshots"] + gameModeData["waveMelees"] === gameModeData["waveKills"])
        {
            multBonus = 1; //Perfect wave
        }
        if (gameModeData["id"] === GameMode.SURVIVAL_STAKEOUT)
        {
            this.onEvent({
                eventId: GameServer.EVENT_GAME_WAVE_COMPLETE,
                gameModeData: gameModeData
            });
            this.createStakeoutAirdrops();
        }
        else 
        {
            var waveBonus = gameModeData["wave"] * 100;
            waveBonus += Math.round(gameModeData["waveKills"] * 2.5);
            waveBonus += gameModeData["waveHeadshots"] * 10;
            waveBonus += gameModeData["waveMelees"] * 25;
            if (multBonus)
            {
                waveBonus += 100 * gameModeData["wave"];
                var allPlayers = this.getPlayerStates();
                for (var i = 0; i < allPlayers.length; i++)
                {
                    var curPlayer = allPlayers[i];
                    this.addPlayerMoneyMultiplier(curPlayer["id"], multBonus);
                    this.onEvent({
                        eventId: GameServer.EVENT_PLAYER_UPDATE,
                        playerId: curPlayer["id"],
                        data: {
                            moneyMultiplier: curPlayer["moneyMultiplier"]
                        }
                    });
                }
                this.onEvent({
                    eventId: GameServer.EVENT_GAME_UPDATE,
                    gameModeData: {}
                });
            }
            if (gameModeData["id"] == GameMode.SURVIVAL_CHAOS)
            {
                waveBonus *= 2.5;
            }
            else if (gameModeData["id"] == GameMode.SURVIVAL_PRO)
            {
                waveBonus *= 5;
            }
            waveBonus = waveBonus * Math.max(1, (1 + (gameModeData["wave"] * 0.2)));
            waveBonus = Math.min(waveBonus, 10000);
            waveBonus = this.RoundToNearest(waveBonus);
            this.onEvent({
                eventId: GameServer.EVENT_GAME_WAVE_COMPLETE,
                moneyReward: waveBonus,
                multBonus: multBonus,
                gameModeData: gameModeData
            });
            var players = this.localData["playerStates"];
            for (var i = 0; i < players.length; i++)
            {
                let player = players[i];
                if (player && player.team == 0)
                {
                    this.addPlayerMoney(player.id, waveBonus);
                    let reviver = this.getReviverByPlayerId(player.id);
                    if (reviver)
                    {
                        this.revivePlayer(player.id, reviver.position, reviver.data.id);
                    }
                }
            }
        }
    }

    endMultiKill(_playerData)
    {
        if (_playerData)
        {
            var count = _playerData["multiKillCount"];
            if (count > 1)
            {
                this.requestEvent({
                    eventId: GameServer.EVENT_PLAYER_MULTI_KILL,
                    playerId: _playerData["id"],
                    kills: count
                });
                if (this.localData["bSurvival"])
                {
                    this.addPlayerMoneyMultiplier(_playerData["id"], Math.min(0.5, 0.1 * (count - 1)));
                    this.onEvent({
                        eventId: GameServer.EVENT_PLAYER_UPDATE,
                        playerId: _playerData["id"],
                        data: {
                            moneyMultiplier: _playerData["moneyMultiplier"]
                        }
                    });
                    this.onEvent({
                        eventId: GameServer.EVENT_GAME_UPDATE,
                        gameModeData: {}
                    });
                }
                else if (this.localData["bBattlezone"])
                {
                    this.addBattlezoneLoot(_playerData.id, count * 500, 0);
                }
            }
            _playerData["multiKillTimer"] = 0;
            _playerData["multiKillCount"] = 0;
        }
    }

    getDestructableObjects(_type)
    {
        var world = this.localData.world;
        var arr = [];
        for (var i = 0; i < world.bodies.length; i++)
        {
            var cur = world.bodies[i];
            if (cur.data)
            {
                switch (cur.data["type"])
                {
                    case "destructableObject":
                        if (_type && cur.data.destructableData["type"] == _type)
                        {
                            arr.push(cur);
                        }
                        else
                        {
                            arr.push(cur);
                        }
                        break;
                }
            }
        }
        return arr;
    }

    getDeployableCovers(_playerId)
    {
        var world = this.localData.world;
        var arr = [];
        for (var i = 0; i < world.bodies.length; i++)
        {
            var cur = world.bodies[i];
            if (cur.data)
            {
                switch (cur.data["type"])
                {
                    case "destructableObject":
                        if (cur.data.playerId === _playerId)
                        {
                            arr.push(cur);
                        }
                        break;
                }
            }
        }
        return arr;
    }

    getDisposableCrates()
    {
        var world = this.localData.world;
        var arr = [];
        for (var i = 0; i < world.bodies.length; i++)
        {
            var cur = world.bodies[i];
            if (cur.data)
            {
                switch (cur.data["type"])
                {
                    case "crate":
                        switch (cur.data.interactData["type"])
                        {
                            case Crate.CRATE_AMMO:
                            case Crate.CRATE_WEAPON:
                            case Crate.CRATE_PERK:
                            case Crate.CRATE_DECOY:
                            case Crate.CRATE_KILLSTREAK:
                            case Crate.CRATE_XP:
                            case Crate.CRATE_LIFE:
                            case Crate.CRATE_SHARD:
                                arr.push(cur);

                            case Crate.CRATE_BOMB:
                            case Crate.CRATE_BOMB_GENERIC:
                                if (this.localData["bSandbox"])
                                {
                                    arr.push(cur);
                                }
                                break;

                            case Crate.CRATE_STORE:
                                if (!this.localData["bSurvival"] && !this.localData["bSandbox"])
                                {
                                    arr.push(cur);
                                }
                                break;
                        }
                        break;
                }
            }
        }
        return arr;
    }

    getAmmoCrates()
    {
        var world = this.localData.world;
        var arr = [];
        for (var i = 0; i < world.bodies.length; i++)
        {
            var cur = world.bodies[i];
            if (cur.data && cur.data.bEnabled)
            {
                switch (cur.data["type"])
                {
                    case "crate":
                        if (cur.data.interactData.type == Crate.CRATE_AMMO)
                        {
                            arr.push(cur);
                        }
                        break;
                }
            }
        }
        return arr;
    }

    getItemCrates(_body)
    {
        var world = this.localData.world;
        var arr = [];
        var team = _body.data.team;
        for (var i = 0; i < world.bodies.length; i++)
        {
            var cur = world.bodies[i];
            if (cur.data && cur.data.bEnabled)
            {
                switch (cur.data["type"])
                {
                    case "crate":
                        if (this.isBeingInteractedWith(cur))
                        {
                            continue;
                        }
                        if (cur.data.interactData.type == Crate.CRATE_KILLSTREAK)
                        {
                            arr.push(cur);
                        }
                        else if (cur.data.interactData.type == Crate.CRATE_DECOY && team != cur.data.interactData.team && !this.characterHasPerk(_body, Perks.PERK_PLAYER_SITREP))
                        {
                            arr.push(cur);
                        }
                        else if (cur.data.interactData.type == Crate.CRATE_WEAPON)
                        {
                            arr.push(cur);
                        }
                        else if (cur.data.interactData.type == Crate.CRATE_PERK)
                        {
                            arr.push(cur);
                        }
                        else if (cur.data.interactData.type == Crate.CRATE_SHARD)
                        {
                            arr.push(cur);
                        }
                        else if (cur.data.interactData.type == Crate.CRATE_XP)
                        {
                            arr.push(cur);
                        }
                        else if (cur.data.interactData.type == Crate.CRATE_LIFE)
                        {
                            arr.push(cur);
                        }
                        break;
                }
            }
        }
        return arr;
    }

    getPlayerControllableTurret(_playerId)
    {
        var world = this.localData.world;
        for (var i = 0; i < world.bodies.length; i++)
        {
            var cur = world.bodies[i];
            if (cur.data)
            {
                switch (cur.data["type"])
                {
                    case "turret":
                        if (!cur.data["bAutomated"])
                        {
                            if (cur.data["controllerId"])
                            {
                                continue;
                            }
                            if (cur.data.turretData.type == Turret.TYPE_REMOTE && cur.data.turretData.playerId == _playerId)
                            {
                                return cur;
                            }
                        }
                        break;
                }
            }
        }
        return null;
    }

    getAvailableControllableTurrets(_team)
    {
        var world = this.localData.world;
        var arr = [];
        for (var i = 0; i < world.bodies.length; i++)
        {
            var cur = world.bodies[i];
            if (cur.data)
            {
                switch (cur.data["type"])
                {
                    case "turret":
                        if (!cur.data["bAutomated"])
                        {
                            if (cur.data["controllerId"])
                            {
                                continue;
                            }
                            var bAdd = true;
                            if (_team != undefined)
                            {
                                bAdd = cur.data["team"] == _team;
                            }
                            if (bAdd)
                            {
                                arr.push(cur);
                            }
                        }
                        break;
                }
            }
        }
        return arr;
    }

    getTurrets(_playerId, _type)
    {
        var world = this.localData.world;
        var arr = [];
        for (var i = 0; i < world.bodies.length; i++)
        {
            var cur = world.bodies[i];
            if (cur.data)
            {
                switch (cur.data["type"])
                {
                    case "turret":
                        var bAdd = true;
                        if (_playerId)
                        {
                            bAdd = cur.data.turretData.playerId == _playerId;
                        }
                        if (_type)
                        {
                            bAdd = bAdd && cur.data.turretData.type == _type;
                        }
                        if (bAdd)
                        {
                            arr.push(cur);
                        }
                        break;
                }
            }
        }
        return arr;
    }

    getDroppedWeapons(_bHasAmmo = false)
    {
        var world = this.localData.world;
        var arr = [];
        for (var i = 0; i < world.bodies.length; i++)
        {
            var cur = world.bodies[i];
            if (cur.data)
            {
                switch (cur.data["type"])
                {
                    case "droppedWeapon":
                        if (_bHasAmmo)
                        {
                            var weaponData = cur.data.interactData.weaponData;
                            var totalAmmo = weaponData["ammo"] + weaponData["mag"];
                            if (totalAmmo >= weaponData["magSize"])
                            {
                                arr.push(cur);
                            }
                        }
                        else
                        {
                            arr.push(cur);
                        }
                        break;
                }
            }
        }
        return arr;
    }

    getReviverByPlayerId(_playerId)
    {
        var revivers = this.getRevivers();
        if (revivers)
        {
            for (var i = 0; i < revivers.length; i++)
            {
                let reviver = revivers[i];
                if (reviver.data.interactData["playerId"] === _playerId)
                {
                    return reviver;
                }
            }
        }
        return null;
    }

    getRevivers()
    {
        var world = this.localData.world;
        var arr = [];
        for (var i = 0; i < world.bodies.length; i++)
        {
            var cur = world.bodies[i];
            if (cur.data)
            {
                switch (cur.data["type"])
                {
                    case "reviver":
                        arr.push(cur);
                        break;
                }
            }
        }
        return arr;
    }

    getCars()
    {
        var world = this.localData.world;
        var arr = [];
        for (var i = 0; i < world.bodies.length; i++)
        {
            var cur = world.bodies[i];
            if (cur.data)
            {
                switch (cur.data["type"])
                {
                    case "car":
                        arr.push(cur);
                        break;
                }
            }
        }
        return arr;
    }

    getHelicopters()
    {
        var world = this.localData.world;
        var arr = [];
        for (var i = 0; i < world.bodies.length; i++)
        {
            var cur = world.bodies[i];
            if (cur.data)
            {
                switch (cur.data["type"])
                {
                    case "helicopter":
                        if (cur.data.health)
                        {
                            arr.push(cur);
                        }
                        break;
                }
            }
        }
        return arr;
    }

    getNumCharactersOnTeam(_team)
    {
        var world = this.localData.world;
        var num = 0;
        for (var i = 0; i < world.bodies.length; i++)
        {
            var cur = world.bodies[i];
            if (cur.data)
            {
                switch (cur.data["type"])
                {
                    case "character":
                        if (cur.data.team == _team)
                        {
                            num++;
                        }
                        break;
                }
            }
        }
        return num;
    }

    getNumHelicoptersOnTeam(_team)
    {
        var world = this.localData.world;
        var num = 0;
        for (var i = 0; i < world.bodies.length; i++)
        {
            var cur = world.bodies[i];
            if (cur.data)
            {
                switch (cur.data["type"])
                {
                    case "helicopter":
                        if (cur.data.team == _team)
                        {
                            num++;
                        }
                        break;
                }
            }
        }
        return num;
    }

    getNumAttackHelicoptersForPlayer(_playerId)
    {
        var world = this.localData.world;
        var num = 0;
        for (var i = 0; i < world.bodies.length; i++)
        {
            var cur = world.bodies[i];
            if (cur.data)
            {
                switch (cur.data["type"])
                {
                    case "helicopter":
                        if (cur.data.heliData.playerId == _playerId && cur.data.behaviour == "attack")
                        {
                            num++;
                        }
                        break;
                }
            }
        }
        return num;
    }

    getNumCobrasOnTeam(_team)
    {
        var world = this.localData.world;
        var num = 0;
        for (var i = 0; i < world.bodies.length; i++)
        {
            var cur = world.bodies[i];
            if (cur.data)
            {
                switch (cur.data["type"])
                {
                    case "helicopter":
                        if (cur.data.team == _team && cur.data.heliData.type == Helicopter.TYPE_COBRA)
                        {
                            num++;
                        }
                        break;
                }
            }
        }
        return num;
    }

    getNumAttackHelicoptersOnTeam(_team)
    {
        var world = this.localData.world;
        var num = 0;
        for (var i = 0; i < world.bodies.length; i++)
        {
            var cur = world.bodies[i];
            if (cur.data)
            {
                switch (cur.data["type"])
                {
                    case "helicopter":
                        if (cur.data.team == _team && cur.data.behaviour == "attack")
                        {
                            num++;
                        }
                        break;
                }
            }
        }
        return num;
    }

    getScavengerPacks()
    {
        var world = this.localData.world;
        var arr = [];
        for (var i = 0; i < world.bodies.length; i++)
        {
            var cur = world.bodies[i];
            if (cur.data)
            {
                if (cur.data["type"] == "scavenger_pack")
                {
                    arr.push(cur);
                }
            }
        }
        return arr;
    }

    getLootPacks()
    {
        var world = this.localData.world;
        var arr = [];
        for (var i = 0; i < world.bodies.length; i++)
        {
            var cur = world.bodies[i];
            if (cur.data)
            {
                if (cur.data["type"] == "loot_pack")
                {
                    arr.push(cur);
                }
            }
        }
        return arr;
    }

    getFlames()
    {
        var world = this.localData.world;
        var arr = [];
        for (var i = 0; i < world.bodies.length; i++)
        {
            var cur = world.bodies[i];
            if (cur.data)
            {
                if (cur.data["type"] == "flame")
                {
                    arr.push(cur);
                }
            }
        }
        return arr;
    }

    getCharacters()
    {
        var world = this.localData.world;
        var arr = [];
        for (var i = 0; i < world.bodies.length; i++)
        {
            var cur = world.bodies[i];
            if (cur.data && cur.data["health"])
            {
                switch (cur.data["type"])
                {
                    case "character":
                        arr.push(cur);
                        break;
                }
            }
        }
        return arr;
    }

    getInfestors()
    {
        var world = this.localData.world;
        var arr = [];
        for (var i = 0; i < world.bodies.length; i++)
        {
            var cur = world.bodies[i];
            if (cur.data && cur.data["health"])
            {
                switch (cur.data["type"])
                {
                    case "infestor":
                        arr.push(cur);
                        break;
                }
            }
        }
        return arr;
    }

    getAllCrates()
    {
        var world = this.localData.world;
        var arr = [];
        for (var i = 0; i < world.bodies.length; i++)
        {
            var cur = world.bodies[i];
            if (cur.data)
            {
                switch (cur.data["type"])
                {
                    case "crate":
                        arr.push(cur);
                        break;
                }
            }
        }
        return arr;
    }

    getAllFlags()
    {
        var world = this.localData.world;
        var arr = [];
        for (var i = 0; i < world.bodies.length; i++)
        {
            var cur = world.bodies[i];
            if (cur.data)
            {
                switch (cur.data["type"])
                {
                    case "flag":
                    case "flag_domination":
                    case "flag_ctf":
                    case "flag_defender":
                        arr.push(cur);
                        break;
                }
            }
        }
        return arr;
    }

    getAllDominationFlags()
    {
        var world = this.localData.world;
        var arr = [];
        for (var i = 0; i < world.bodies.length; i++)
        {
            var cur = world.bodies[i];
            if (cur.data)
            {
                switch (cur.data["type"])
                {
                    case "flag_domination":
                        arr.push(cur);
                        break;
                }
            }
        }
        return arr;
    }

    getFlagDomination(_num)
    {
        var world = this.localData.world;
        for (var i = 0; i < world.bodies.length; i++)
        {
            var cur = world.bodies[i];
            if (cur.data)
            {
                switch (cur.data["type"])
                {
                    case "flag_domination":
                        if (cur.data["team"] == _num)
                        {
                            return cur;
                        }
                        break;
                }
            }
        }
        return null;
    }

    getAIBestDominationFlag(_body)
    {
        var data = _body.data;
        var flags = [];
        for (var i = 0; i < 3; i++)
        {
            var curFlag = this.getObjectById("flag_" + i);
            if (curFlag)
            {
                flags.push(curFlag);
            }
        }
        var curFlag = null;
        var dist = Number.MAX_VALUE;
        var bFlag = false;
        for (var i = 0; i < flags.length; i++)
        {
            var flag = flags[i];
            if (flag.data["team"] != data["team"])
            {
                var flagDist = this.Dist(_body.position[0], _body.position[1], flag.position[0], flag.position[1]);
                if (flagDist < dist)
                {
                    bFlag = true;
                    curFlag = flag;
                    dist = flagDist;
                }
            }
        }
        if (!bFlag)
        {
            return flags[this.Random(0, flags.length - 1)];
        }
        return curFlag;
    }

    getFlagCTF(_team)
    {
        var world = this.localData.world;
        for (var i = 0; i < world.bodies.length; i++)
        {
            var cur = world.bodies[i];
            if (cur.data)
            {
                switch (cur.data["type"])
                {
                    case "flag_ctf":
                        if (cur.data["team"] == _team)
                        {
                            return cur;
                        }
                        break;
                }
            }
        }
        return null;
    }

    startLadderClimb(_body, _ladder)
    {
        this.cancelCharacterReload(_body);
        this.cancelCharacterBoltPull(_body);

        var shape = _body.shapes[0];
        shape.collisionMask = CollisionGroups.PROJECTILE;

        var shared = this.getSharedData(_body.data["type"]);

        _body.gravityScale = 0;
        _body.damping = shared.climbDamping;
        _body.velocity = [0, 0];
        _body.position[0] = _ladder.position[0];
        _body.fixedX = true;

        var data = _body.data;
        data["bIsOnLadder"] = true;
        data["ladderId"] = _ladder.data.id;
        data["ladderDirection"] = _ladder.data.direction;

        this.requestEvent({
            eventId: GameServer.EVENT_PAWN_ACTION,
            pawnId: data["id"],
            type: GameServer.PAWN_START_LADDER_CLIMB,
            position: _body.position,
            ladderDirection: data["ladderDirection"]
        });
    }

    roundNumberArray(_arr)
    {
        if (_arr)
        {
            return [Math.round(_arr[0]), Math.round(_arr[1])];
        }
        return _arr;
    }

    leaveLadder(_body)
    {
        var shared = this.getSharedData(_body.data["type"]);

        _body.gravityScale = 1;
        _body.damping = shared.damping;
        _body.velocity = [0, 0];
        _body.fixedX = false;

        var shape = _body.shapes[0];
        //shape.collisionMask = CollisionGroups.GROUND | CollisionGroups.PLATFORM | CollisionGroups.PROJECTILE;
        shape.collisionMask = CollisionGroups.GROUND | CollisionGroups.PROJECTILE;

        var data = _body.data;
        if (data["bIsOnLadder"])
        {
            data["bLadderCooldown"] = 1;
            data["speedMultiplier"] = 1;
            data["ladderCooldownTimer"] = shared.ladderCooldown ? (shared.ladderCooldown * this.localData.settings.fps_mult) : 1;
        }
        data["bIsOnLadder"] = false;
        delete data["ladderId"];
        delete data["ladderDirection"];

        if (data["bBot"])
        {
            data.ai["ticker"] = 1;
        }

        this.requestEvent({
            eventId: GameServer.EVENT_PAWN_ACTION,
            pawnId: data["id"],
            position: this.roundNumberArray(_body.position),
            velocity: _body.velocity,
            type: GameServer.PAWN_LEAVE_LADDER
        });
    }

    getClimbableLadder(_body)
    {
        var world = this.localData.world;
        for (var i = 0; i < world.bodies.length; i++)
        {
            var cur = world.bodies[i];
            if (cur.data)
            {
                switch (cur.data["type"])
                {
                    case "ladder":
                        if (cur.data["bPlayer"] && _body.data["bBot"])
                        {
                            continue;
                        }
                        if (cur.data["bBot"] && !_body.data["bBot"])
                        {
                            continue;
                        }
                        var bOverlap = _body.getAABB().overlaps(cur.getAABB());
                        if (bOverlap)
                        {
                            return cur;
                        }
                        break;
                }
            }
        }
        return null;
    }

    getLadders()
    {
        var world = this.localData.world;
        var arr = [];
        for (var i = 0; i < world.bodies.length; i++)
        {
            var cur = world.bodies[i];
            if (cur.data)
            {
                switch (cur.data["type"])
                {
                    case "ladder":
                        arr.push(cur);
                        break;
                }
            }
        }
        return arr;
    }

    getSpawners()
    {
        var world = this.localData.world;
        var arr = [];
        for (var i = 0; i < world.bodies.length; i++)
        {
            var cur = world.bodies[i];
            if (cur.data)
            {
                switch (cur.data["type"])
                {
                    case "spawner":
                        arr.push(cur);
                        break;
                }
            }
        }
        return arr;
    }

    getPawns(_team)
    {
        var world = this.localData.world;
        var arr = [];
        for (var i = 0; i < world.bodies.length; i++)
        {
            var cur = world.bodies[i];
            if (cur.data)
            {
                switch (cur.data["type"])
                {
                    case "infestor":
                    case "character":
                    case "turret":
                    case "helicopter":
                    case "car":
                        if (_team != undefined)
                        {
                            if (cur.data["team"] === _team)
                            {
                                arr.push(cur);
                            }
                        }
                        else
                        {
                            arr.push(cur);
                        }
                        break;
                }
            }
        }
        return arr;
    }

    getRockets()
    {
        var world = this.localData.world;
        var arr = [];
        for (var i = 0; i < world.bodies.length; i++)
        {
            var cur = world.bodies[i];
            if (cur.data)
            {
                switch (cur.data["type"])
                {
                    case "rocket":
                        arr.push(cur);
                        break;
                }
            }
        }
        return arr;
    }

    getEMPItems()
    {
        var world = this.localData.world;
        var arr = [];
        for (var i = 0; i < world.bodies.length; i++)
        {
            var cur = world.bodies[i];
            if (cur.data)
            {
                switch (cur.data["type"])
                {
                    case "grenade":
                    case "equipment":
                    case "turret":
                    case "helicopter":
                        arr.push(cur);
                        break;

                    case "rocket":
                        if (cur.data.rocketData["type"] == Rocket.TYPE_HELLFIRE)
                        {
                            arr.push(cur);
                        }
                        break;
                }
            }
        }
        return arr;
    }

    createStakeoutAirdrops(_ksType)
    {
        var players = this.localData.playerStates;
        var wave = Math.min(this.localData.gameModeData["wave"], 100);
        for (var i = 0; i < players.length; i++)
        {
            if (this.getDisposableCrates().length < Settings.CRATES_MAX)
            {
                var ps = players[i];                
                if (_ksType)
                {
                    var ksId = _ksType;
                }
                else
                {
                    var streaks = {};
                    streaks[Killstreaks.KILLSTREAK_AMMO] = 3 + (wave * 0.25);
                    streaks[Killstreaks.KILLSTREAK_WEAPON] = wave;
                    streaks[Killstreaks.KILLSTREAK_CARE_PACKAGE] = wave + (wave * 0.5);
                    streaks[Killstreaks.KILLSTREAK_SENTRY_GUN] = wave / (this.getTurrets(ps.id, Turret.TYPE_SENTRY) + 1);
                    streaks[Killstreaks.KILLSTREAK_SAM_TURRET] = ((wave * 0.25) + (wave * 0.5)) / (this.getTurrets(ps.id, Turret.TYPE_SAM) + 1);
                    var pawn = this.getObjectById(pawn);
                    if (!this.characterHasAllSurvivalPerks(pawn))
                    {
                        streaks[Killstreaks.KILLSTREAK_PERK] = Math.min(20, wave * wave * 0.5);
                    }
                    ksId = this.getRandomProperty(streaks);
                }
                if (ksId)
                {
                    var pos = this.getRandomAirdropPosition();
                    this.executePlayerKillstreak(ps.id, ksId, pos[0], pos[1], true);
                }                
            }
        }
    }

    getRandomAirdropPosition()
    {
        var map = this.getCurrentMapData();
        var airdrops = map.airdrops;
        if (airdrops)
        {
            var pos = airdrops[this.Random(0, airdrops.length - 1)];
            pos[0] += this.Random(-50, 50);
        }
        else
        {
            var padding = 600;
            pos = [this.Random(padding, map.width - padding), this.Random(600, 1000)];
        }
        return pos;
    }

    getSmokeGrenades()
    {
        var world = this.localData.world;
        var arr = [];
        for (var i = 0; i < world.bodies.length; i++)
        {
            var cur = world.bodies[i];
            if (cur.data)
            {
                switch (cur.data["type"])
                {
                    case "grenade":
                        if (cur.data.grenadeData["weaponId"] == "smoke" && cur.data["bActivated"])
                        {
                            arr.push(cur);
                        }
                        break;
                }
            }
        }
        return arr;
    }

    getGrenades(_playerId, _weaponId)
    {
        var world = this.localData.world;
        var arr = [];
        for (var i = 0; i < world.bodies.length; i++)
        {
            var cur = world.bodies[i];
            if (cur.data)
            {
                switch (cur.data["type"])
                {
                    case "grenade":
                        if (_weaponId && cur.data.grenadeData["weaponId"] != _weaponId)
                        {
                            continue;
                        }
                        if (_playerId)
                        {
                            if (_playerId == cur.data.grenadeData["playerId"])
                            {
                                arr.push(cur);
                            }
                        }
                        else
                        {
                            arr.push(cur);
                        }
                        break;
                }
            }
        }
        return arr;
    }

    getRandomHairColour()
    {
        var arr = [
            Character.HAIR_COLOUR_BLACK,
            Character.HAIR_COLOUR_BROWN,
            Character.HAIR_COLOUR_BROWN_LIGHT,
            Character.HAIR_COLOUR_BLONDE,
            Character.HAIR_COLOUR_GINGER
        ];
        return arr[this.Random(0, arr.length - 1)];
    }

    getRandomHair()
    {
        var arr = [
            Character.HAIR_BALD,
            Character.HAIR_SHORT,
            Character.HAIR_LONG,
            Character.HAIR_STYLED,
            Character.HAIR_UNDERCUT
        ];
        return arr[this.Random(0, arr.length - 1)];
    }

    getRandomBeard()
    {
        var arr = [
            Character.BEARD_NONE,
            Character.BEARD_FULL,
            Character.BEARD_GOATEE,
            Character.BEARD_MOUSTACHE,
            Character.BEARD_STUBBLE
        ];
        return arr[this.Random(0, arr.length - 1)];
    }

    getEquipment(_weaponId)
    {
        var world = this.localData.world;
        var arr = [];
        for (var i = 0; i < world.bodies.length; i++)
        {
            var cur = world.bodies[i];
            if (cur.data)
            {
                switch (cur.data["type"])
                {
                    case "equipment":
                        if (_weaponId)
                        {
                            if (cur.data.weaponData.id == _weaponId)
                            {
                                arr.push(cur);
                            }
                        }
                        else
                        {
                            arr.push(cur);
                        }
                        break;
                }
            }
        }
        return arr;
    }

    getObstacles()
    {
        var world = this.localData.world;
        var arr = [];
        for (var i = 0; i < world.bodies.length; i++)
        {
            var cur = world.bodies[i];
            if (cur.data)
            {
                switch (cur.data["type"])
                {
                    case "obstacle":
                        arr.push(cur);
                        break;
                }
            }
        }
        return arr;
    }

    getObstaclesWithHealth()
    {
        var world = this.localData.world;
        var arr = [];
        for (var i = 0; i < world.bodies.length; i++)
        {
            var cur = world.bodies[i];
            if (cur.data)
            {
                switch (cur.data["type"])
                {
                    case "obstacle":
                        if (cur.data["health"])
                        {
                            arr.push(cur);
                        }
                        break;
                }
            }
        }
        return arr;
    }

    getDoors()
    {
        var world = this.localData.world;
        var arr = [];
        for (var i = 0; i < world.bodies.length; i++)
        {
            var cur = world.bodies[i];
            if (cur.data)
            {
                switch (cur.data["type"])
                {
                    case "door":
                        arr.push(cur);
                        break;
                }
            }
        }
        return arr;
    }

    getNumPawnType(_type)
    {
        var pawns = this.getPawns();
        var num = 0;
        for (var i = 0; i < pawns.length; i++)
        {
            if (pawns[i].data["type"] == _type)
            {
                num++;
            }
        }
        return num;
    }

    getNumRocketType(_type)
    {
        var rockets = this.getRockets();
        var num = 0;
        for (var i = 0; i < rockets.length; i++)
        {
            var rocket = rockets[i];
            if (rocket.data.rocketData["type"] == _type)
            {
                num++;
            }
        }
        return num;
    }

    getNumHelicopterType(_type)
    {
        var pawns = this.getPawns();
        var num = 0;
        for (var i = 0; i < pawns.length; i++)
        {
            var pawn = pawns[i];
            if (pawn.data["type"] == "helicopter")
            {
                if (pawn.data.heliData["type"] == _type)
                {
                    num++;
                }
            }
        }
        return num;
    }

    getMuzzlePosition(_body)
    {
        if (_body)
        {
            var pos = [_body.position[0], _body.position[1]];            
            var offsetX = _body.data["muzzleOffsetX"] ? _body.data["muzzleOffsetX"] : 0;
            var offsetY = _body.data["muzzleOffsetY"] ? _body.data["muzzleOffsetY"] : 0;
            var muzzlePos = [pos[0] + offsetX, pos[1] + offsetY];
            var rad = this.Angle(_body.position[0], _body.position[1], muzzlePos[0], muzzlePos[1]) + _body.angle;
            var dist = this.Dist(_body.position[0], _body.position[1], muzzlePos[0], muzzlePos[1]);
            pos[0] += Math.cos(_body.angle + rad) * dist;
            pos[1] += Math.sin(_body.angle + rad) * dist;
            return pos;
        }
        return null;
    }

    dropHelicopterCrate(_body)
    {
        var data = _body.data;
        var heliData = data.heliData;
        if (_body["constraint"])
        {
            this.localData.world.removeConstraint(_body["constraint"]);
            var crate = this.getObjectById(data["crateId"]);
            if (crate)
            {
                crate.mass = 1;
                crate.updateMassProperties();
                crate.damping = 0.1;
                crate.angularDamping = 0.1;
                crate.shapes[0].collisionMask = CollisionGroups.GROUND | CollisionGroups.PLATFORM;
                crate.data["bEnabled"] = true;
                crate.data["bOnRope"] = false;
                this.pushObjectDataUpdate(crate.data["id"], ["bEnabled", "bOnRope"]);
            }
            data["crateId"] = null;
            this.pushObjectDataUpdate(data["id"], ["crateId"]);
            delete _body["constraint"];
            heliData["items"] = [];
            this.requestEvent({
                eventId: GameServer.EVENT_PAWN_ACTION,
                pawnId: data["id"],
                type: GameServer.PAWN_DROP_CRATE
            });
        }
        else
        {
            var items = heliData["items"];
            if (items && items.length > 0)
            {
                var item = items[0];
                switch (item["type"])
                {
                    case "unit":
                        if (item["unitId"])
                        {
                            this.createSandboxUnit({
                                unitId: item["unitId"],
                                team: data["team"],
                                pos: _body.position,
                                patrolPoints: item["patrolPoints"],
                                bLOS: item["bLOS"],
                                pawnName: item["pawnName"]
                            });
                        }
                        break;

                    case "crate":
                        switch (item["crateType"])
                        {
                            case Crate.CRATE_KILLSTREAK:
                                switch (data["killstreakId"])
                                {
                                    case Killstreaks.KILLSTREAK_ESCORT_AIRDROP:
                                        if (!this.localData["bSurvival"] && this.Random(1, 5) == 1)
                                        {
                                            crate = this.createDecoyCrate(_body.position[0], _body.position[1], heliData["playerId"]);
                                        }
                                        else
                                        {
                                            crate = this.createKillstreakCrate(_body.position[0], _body.position[1], undefined, heliData["playerId"]);
                                        }
                                        break;

                                    default:
                                        crate = this.createKillstreakCrate(_body.position[0], _body.position[1], undefined, heliData["playerId"]);
                                        break;
                                }
                                break;

                            case Crate.CRATE_WEAPON:
                                var items = item.items;
                                if (!items)
                                {
                                    var weaponData = this.getWeaponData(item.weaponId);
                                    items = [weaponData];
                                }
                                crate = this.createItemCrate(_body.position[0], _body.position[1], heliData["playerId"], items);
                                break;

                            case Crate.CRATE_PERK:
                                crate = this.createPerkCrate(_body.position[0], _body.position[1], heliData["playerId"], item["perkId"]);
                                break;

                            case Crate.CRATE_AMMO:
                                crate = this.createAmmoCrate(_body.position[0], _body.position[1], heliData["playerId"]);
                                break;

                            case Crate.CRATE_SHARD:
                                crate = this.createShardCrate(_body.position[0], _body.position[1], item["shards"]);
                                break;

                            case Crate.CRATE_XP:
                                crate = this.createXPCrate(_body.position[0], _body.position[1], item["xp"]);
                                break;

                            case Crate.CRATE_LIFE:
                                crate = this.createLifeCrate(_body.position[0], _body.position[1], item["lives"]);
                                break;

                            default:
                                console.warn("Unhandled helicopter crate: " + items[0]["crateType"]);
                                break;
                        }
                        break;
                }
                if (crate)
                {
                    crate.angularVelocity = this.Random(-10, 10) * 0.1;
                    crate.applyImpulse([this.Random(-100, 100), 0], 0, 0);
                }
            }
        }
    }

    getObjectById(_id)
    {
        if (!_id)
        {
            return null;
        }
        var object = this.localData.objects[_id];
        if (object && object.data && !object.data["bPendingRemoval"])
        {
            return object;
        }
        return null;
    }

    createPlayerState()
    {
        return {
            id: null,
            name: null,
            level: 1,
            prestige: 0,
            team: 0,
            kills: 0,
            headshots: 0,
            melees: 0,
            assists: 0,
            deaths: 0,
            currentKillstreak: 0,
            avengerTimer: 0,
            multiKillTimer: 0,
            multiKillCount: 0,
            controllableId: null,
            killstreaks: [],
            currentKillstreakIndex: 0,
            factionId: null,
            avatarData: null,
            respawnTimer: -1,
            bSpawnProtection: false,
            bWaitingToRespawn: false,
            bCanRespawn: false,
            bAutoRespawn: true,
            bHasPawn: false,
            bBot: false
        };
    }

    addPlayerState(_data)
    {
        var ps = this.createPlayerState();
        ps["id"] = _data["id"];
        ps["name"] = _data["name"];
        ps["level"] = _data["level"];
        ps["prestige"] = _data["prestige"];
        ps["card"] = _data["card"];
        ps["callsign"] = _data["callsign"];
        ps["clan"] = _data["clan"];
        ps["factionId"] = _data["factionId"];
        ps["avatarData"] = _data["avatarData"];
        if (this.localData.factions)
        {
            ps["avatars"] = _data["avatars"];
        }
        ps["team"] = _data["team"];
        if (_data["bBot"]) ps["bBot"] = _data["bBot"];
        if (_data["bDummy"]) ps["bDummy"] = _data["bDummy"];
        if (_data["bRanked"]) ps["bRanked"] = _data["bRanked"];
        if (_data["bPremium"]) ps["bPremium"] = _data["bPremium"];
        if (_data["bAdmin"]) ps["bAdmin"] = _data["bAdmin"];
        if (_data["bDev"]) ps["bDev"] = _data["bDev"];
        if (_data["steamId"]) ps["steamId"] = _data["steamId"];
        if (_data["bClanLeader"]) ps["bClanLeader"] = _data["bClanLeader"];
        if (_data["bMod"]) ps["bMod"] = _data["bMod"];
        ps["botSkill"] = _data["botSkill"];
        ps["desiredClassData"] = _data["desiredClassData"];
        ps["desiredKillstreaks"] = _data["desiredKillstreaks"];
        ps["latency"] = _data["latency"];
        ps["currentPartyId"] = _data["currentPartyId"];
        if (this.localData["bBattlezone"])
        {
            ps["battlezone"] = _data["battlezone"];
        }
        return ps;
    }

    removePlayerStateById(_id)
    {
        var players = this.localData["playerStates"];
        for (var i = 0; i < players.length; i++)
        {
            if (players[i]["id"] == _id)
            {
                var player = players[i];
                var timer = player["timer_respawn"];
                if (timer)
                {
                    //clearInterval(timer);
                    delete player["timer_respawn"];
                }
                timer = player["timer_spawnProtection"];
                if (timer)
                {
                    //clearInterval(timer);
                    delete player["timer_spawnProtection"];
                }
                players.splice(i, 1);
                return true;
            }
        }
        this.log("Player doesn't exist: " + _id);
        return false;
    }

    getPlayerStates()
    {
        return this.localData.playerStates;
    }

    getPlayerStateById(_id)
    {
        var players = this.localData["playerStates"];
        for (var i = 0; i < players.length; i++)
        {
            if (players[i]["id"] == _id)
            {
                return players[i];
            }
        }
        return null;
    }

    startSpawnProtectionTimer(_playerId)
    {
        var curPlayerData = this.getPlayerStateById(_playerId);
        if (curPlayerData)
        {
            var protectionTime = 1.5;
            if (this.isHardcore())
            {
                protectionTime = 0.5
            }
            else if (this.localData["bBattlezone"])
            {
                protectionTime = 3;
            }
            curPlayerData["timer_spawnProtection"] = Math.ceil(this.localData.settings.fps * protectionTime);
            curPlayerData["bSpawnProtection"] = true;
            this.onEvent({
                eventId: GameServer.EVENT_PLAYER_UPDATE,
                playerId: curPlayerData["id"],
                data: {
                    bSpawnProtection: curPlayerData["bSpawnProtection"]
                }
            });
        }
    }

    onPlayerEarnKillstreak(_playerId, _killstreakId)
    {
        var ps = this.getPlayerStateById(_playerId);
        if (ps)
        {
            var ksData = this.getKillstreakData(_killstreakId);
            if (ksData["type"] == Killstreaks.TYPE_PERKS)
            {
                if (!ps["bJuggernaut"])
                {
                    this.requestEvent({
                        eventId: GameServer.EVENT_PLAYER_UPDATE_INVENTORY,
                        pawnId: _playerId,
                        type: GameServer.INV_PERK_ADD,
                        perkId: ksData["perkId"]
                    });
                }
            }
            else
            {
                ps["killstreaks"].push(_killstreakId);
                ps["currentKillstreakIndex"] = ps["killstreaks"].length - 1;
                this.onEvent({
                    eventId: GameServer.EVENT_PLAYER_UPDATE,
                    playerId: _playerId,
                    data: {
                        killstreaks: ps["killstreaks"],
                        currentKillstreakIndex: ps["currentKillstreakIndex"]
                    }
                });
            }
        }
    }

    killstreakIsActive(_killstreakId)
    {
        var killstreaks = this.localData["killstreaks"];
        for (var i = 0; i < killstreaks.length; i++)
        {
            var ks = killstreaks[i];
            if (ks["id"] === _killstreakId)
            {
                return true;
            }
        }
        return false;
    }

    getNumJuggernautsOnTeam(_team)
    {
        var num = 0;
        var chars = this.getCharacters();
        for (var i = 0; i < chars.length; i ++)
        {
            var char = chars[i];
            if (char.data.team == _team && char.data.bJuggernaut)
            {
                num++;
            }
        }
        return num;
    }

    canUseKillstreak(_playerId, _killstreakId)
    {
        var ps = this.getPlayerStateById(_playerId);
        if (!ps)
        {
            return true;
        }
        var team = ps.team;
        if (ps["controllableId"])
        {
            return false;
        }
        var char = this.getObjectById(_playerId);
        if (!char)
        {
            return false;
        }
        if (!this.localData.bSurvival)
        {
            if (char.data.bJuggernaut)
            {
                return false;
            }
        }
        var killstreaks = this.localData["killstreaks"];
        var numSurvivalAirstrikes = 0;
        var numNapalmAirstrikes = 0;
        for (var i = 0; i < killstreaks.length; i++)
        {
            var ks = killstreaks[i];
            if (ks["id"] == Killstreaks.KILLSTREAK_EMP && ks["team"] != ps["team"])
            {
                return false;
            }
            else if (ks["id"] == Killstreaks.KILLSTREAK_DEADSWITCH)
            {
                return false;
            }
            else if (ks["id"] == Killstreaks.KILLSTREAK_BOMBARDMENT)
            {
                if (_killstreakId == Killstreaks.KILLSTREAK_BOMBARDMENT)
                {
                    numSurvivalAirstrikes++;
                    if (numSurvivalAirstrikes >= (this.localData["bSurvival"] ? 2 : 1))
                    {
                        return false;
                    }
                }
            }
            else if (ks["id"] == Killstreaks.KILLSTREAK_NAPALM)
            {
                if (_killstreakId == Killstreaks.KILLSTREAK_NAPALM)
                {
                    numNapalmAirstrikes++;
                    if (numNapalmAirstrikes >= (this.localData["bSurvival"] ? 2 : 1))
                    {
                        return false;
                    }
                }
            }
        }
        var maxJuggernautsPerTeam = (this.localData["bSurvival"] || this.localData["bSandbox"]) ? 4 : 1;
        var maxControllableHelis = (this.localData["bSurvival"] || this.localData["bSandbox"]) ? 2 : 1;
        var maxAttackHelisPerTeam = (this.localData["bSurvival"] || this.localData["bSandbox"]) ? 6 : 2;
        switch (_killstreakId)
        {
            case Killstreaks.KILLSTREAK_AMMO:
            case Killstreaks.KILLSTREAK_DECOY:
            case Killstreaks.KILLSTREAK_CARE_PACKAGE:
            case Killstreaks.KILLSTREAK_SAM_TURRET:
            case Killstreaks.KILLSTREAK_SENTRY_GUN:
            case Killstreaks.KILLSTREAK_WEAPON:
            case Killstreaks.KILLSTREAK_WEAPON_M202:
            case Killstreaks.KILLSTREAK_WEAPON_MINIGUN:
            case Killstreaks.KILLSTREAK_SUPPORT_AIRDROP:
            case Killstreaks.KILLSTREAK_JUGGERNAUT:
            case Killstreaks.KILLSTREAK_JUGGERNAUT_RECON:
                if (this.getNumHelicopterType(Helicopter.TYPE_MH6) >= 2)
                {
                    return false;
                }
                break;

            case Killstreaks.KILLSTREAK_MH6:
                if (this.getNumHelicopterType(Helicopter.TYPE_MH6_ATTACK) >= 2)
                {
                    return false;
                }
                if (this.getNumAttackHelicoptersOnTeam(team) >= maxAttackHelisPerTeam)
                {
                    return false;
                }
                break;

            case Killstreaks.KILLSTREAK_MH6_GRENADE:
                if (this.getNumHelicopterType(Helicopter.TYPE_MH6_GRENADE) >= maxControllableHelis)
                {
                    return false;
                }
                if (this.getNumAttackHelicoptersOnTeam(team) >= maxAttackHelisPerTeam)
                {
                    return false;
                }
                break;

            case Killstreaks.KILLSTREAK_COBRA:
                if (this.localData["bModeGame"])
                {
                    if (this.getNumCobrasOnTeam(team) >= 1)
                    {
                        return false;
                    }
                    if (this.getNumAttackHelicoptersOnTeam(team) >= maxAttackHelisPerTeam)
                    {
                        return false;
                    }
                }
                else
                {
                    if (this.getNumHelicopterType(Helicopter.TYPE_COBRA) >= 1)
                    {
                        return false;
                    }
                    if (this.getNumAttackHelicoptersOnTeam(team) >= maxAttackHelisPerTeam)
                    {
                        return false;
                    }
                }
                break;

            case Killstreaks.KILLSTREAK_COBRA_CONTROLLABLE:
                if (this.getNumHelicopterType(Helicopter.TYPE_COBRA_CONTROLLABLE) >= maxControllableHelis)
                {
                    return false;
                }
                if (this.getNumAttackHelicoptersOnTeam(team) >= maxAttackHelisPerTeam)
                {
                    return false;
                }
                break;

            case Killstreaks.KILLSTREAK_CHOPPER_GUNNER:
                if (this.getNumHelicopterType(Helicopter.TYPE_BLACKHAWK) >= maxControllableHelis)
                {
                    return false;
                }
                if (this.getNumAttackHelicoptersOnTeam(team) >= maxAttackHelisPerTeam)
                {
                    return false;
                }
                break;

            case Killstreaks.KILLSTREAK_HELI_SNIPER:
                if (this.getNumHelicopterType(Helicopter.TYPE_BLACKHAWK_SNIPER) >= maxControllableHelis)
                {
                    return false;
                }
                if (this.getNumAttackHelicoptersOnTeam(team) >= maxAttackHelisPerTeam)
                {
                    return false;
                }
                break;

            case Killstreaks.KILLSTREAK_PAVE_LOW:
                if (this.getNumHelicopterType(Helicopter.TYPE_PAVE_LOW) >= 1)
                {
                    return false;
                }
                if (this.getNumAttackHelicoptersOnTeam(team) >= maxAttackHelisPerTeam)
                {
                    return false;
                }
                if (!this.localData.bSurvival && this.getNumAttackHelicoptersForPlayer(_playerId) >= 1)
                {
                    return false;
                }
                break;

            case Killstreaks.KILLSTREAK_REAPER:
                if (this.getNumHelicopterType(Helicopter.TYPE_REAPER) >= maxControllableHelis)
                {
                    return false;
                }
                if (this.getNumAttackHelicoptersOnTeam(team) >= maxAttackHelisPerTeam)
                {
                    return false;
                }
                break;

            case Killstreaks.KILLSTREAK_SCOUT:
                if (this.getNumHelicopterType(Helicopter.TYPE_SCOUT) >= maxControllableHelis)
                {
                    return false;
                }
                if (this.getNumAttackHelicoptersOnTeam(team) >= maxAttackHelisPerTeam)
                {
                    return false;
                }
                break;

            case Killstreaks.KILLSTREAK_DRAGONFIRE:
                if (this.getNumHelicopterType(Helicopter.TYPE_DRAGONFIRE) >= 2)
                {
                    return false;
                }
                break;

            case Killstreaks.KILLSTREAK_ESCORT_AIRDROP:
            case Killstreaks.KILLSTREAK_ESCORT_AIRDROP_SURVIVAL:
                if (this.getNumHelicopterType(Helicopter.TYPE_OSPREY) >= 1)
                {
                    return false;
                }
                break;

            case Killstreaks.KILLSTREAK_HELLFIRE:
                if (this.getNumRocketType(Rocket.TYPE_HELLFIRE) >= 2)
                {
                    return false;
                }
                break;

            case Killstreaks.KILLSTREAK_JUGGERNAUT_RECON_USE:
            case Killstreaks.KILLSTREAK_JUGGERNAUT_USE:
                if (ps.bVIP)
                {
                    return false;
                }
                if (this.getNumJuggernautsOnTeam(team) >= maxJuggernautsPerTeam)
                {
                    return false;
                }
                break;
        }
        return true;
    }

    addKillstreak(_data)
    {
        this.localData.killstreaks.push(_data);
        this.onEvent({
            eventId: GameServer.EVENT_KILLSTREAKS_UPDATE,
            killstreaks: this.localData.killstreaks
        });
    }

    executeInteractable(_interactable, _playerId)
    {
        if (!this.matchInProgress())
        {
            return;
        }
        var interactable = _interactable;
        if (interactable && !interactable.data["bPendingDestroy"])
        {
            if (interactable.data["bLimitInteractions"])
            {
                delete interactable.data["currentPawnId"];
            }
            this.onEvent({
                eventId: GameServer.EVENT_INTERACTABLE_USED,
                data: {
                    interactableId: interactable.data.id,
                    playerId: _playerId
                }
            });
            var pawn = this.getObjectById(_playerId);
            var data = interactable.data;
            var interactData = data["interactData"];
            if (data)
            {
                switch (data["type"])
                {
                    case "helicopter":
                        var constraint = new this.p2.RevoluteConstraint(pawn, interactable, {
                            worldPivot: [interactable.position[0], interactable.position[1]]
                        });
                        constraint.setStiffness(100);
                        constraint.upperLimit = this.ToRad(45);
                        constraint.upperLimitEnabled = true;
                        constraint.lowerLimit = this.ToRad(-45);
                        constraint.lowerLimitEnabled = true;
                        this.localData.world.addConstraint(constraint);
                        body["constraint"] = constraint;
                        body.data["crateId"] = crate.data["id"];
                        break;

                    case "info":
                        this.requestEvent({
                            eventId: GameServer.EVENT_MESSAGE_ADD,
                            data: interactable.data.interactData
                        });
                        if (interactData.bRemove)
                        {
                            this.removeNextStep(interactable);
                        }
                        break;

                    case "door":
                        if (!data["cooldownTimer"])
                        {
                            this.setDoorClosed(interactable, !data["bClosed"], pawn);
                            this.cancelCharacterBoltPull(pawn);
                            this.cancelCharacterReload(pawn);
                            pawn.data["bShieldCooldown"] = true;
                            pawn.data["shieldCooldownTimer"] = Math.ceil(this.localData.settings.fps * 0.5);
                            pawn.data["bDoorCooldown"] = true;
                            this.requestEvent({
                                eventId: GameServer.EVENT_PAWN_ACTION,
                                pawnId: pawn.data["id"],
                                type: GameServer.PAWN_START_SHIELD_COOLDOWN,
                                bDoor: true,
                                position: this.roundNumberArray(pawn.position)
                            });
                        }
                        break;

                    case "scavenger_pack":
                        if (pawn && pawn.data)
                        {
                            var inventory = pawn.data["inventory"];
                            for (i = 0; i < inventory.length; i++)
                            {
                                var curInvItem = inventory[i];
                                if (!curInvItem["bMelee"])
                                {
                                    this.requestEvent({
                                        eventId: GameServer.EVENT_PLAYER_UPDATE_INVENTORY,
                                        pawnId: pawn.data.id,
                                        index: i,
                                        type: GameServer.INV_AMMO_ADD,
                                        value: curInvItem["magSize"],
                                        barrelAmmo: 1
                                    });
                                }
                            }
                            var equipment = pawn.data["equipment"];
                            if (equipment && equipment["ammo"] == 0)
                            {
                                this.requestEvent({
                                    eventId: GameServer.EVENT_PLAYER_UPDATE_INVENTORY,
                                    pawnId: pawn.data["id"],
                                    type: GameServer.INV_EQUIPMENT_ADD,
                                    value: 1
                                });
                            }
                        }
                        this.removeNextStep(interactable);
                        break;

                    case "loot_pack":
                        if (pawn)
                        {
                            this.addBattlezoneLoot(pawn.data.id, interactable.data.interactData.xp, interactable.data.interactData.shards);
                            interactable.data.bUsed = true;
                            this.removeNextStep(interactable);
                        }
                        break;

                    case "reviver":
                        var reviveReward = this.localData["bUseMoneyMultiplier"] ? 250 : 0;
                        this.revivePlayer(interactData["playerId"], [interactable.position[0], interactable.position[1] - 20], _playerId);
                        this.onEvent({
                            eventId: GameServer.EVENT_PAWN_ACTION,
                            pawnId: _playerId,
                            type: GameServer.PAWN_END_REVIVE,
                            money: reviveReward
                        });
                        this.removeNextStep(interactable);
                        if (this.localData["bSurvival"])
                        {
                            this.addPlayerMoney(_playerId, reviveReward);
                        }
                        break;

                    case "turret":
                        if (!data["controllerId"])
                        {
                            var ps = this.getPlayerStateById(_playerId);
                            if (ps)
                            {
                                this.setPlayerControllable(ps, interactable);
                            }
                        }
                        break;

                    case "droppedWeapon":
                        if (pawn)
                        {
                            var weaponData = interactData["weaponData"];
                            if (weaponData["bEquipment"])
                            {
                                var equipment = pawn.data["equipment"];
                                if (equipment && equipment["id"] === weaponData["id"])
                                {
                                    this.requestEvent({
                                        eventId: GameServer.EVENT_PLAYER_UPDATE_INVENTORY,
                                        pawnId: pawn.data["id"],
                                        index: itemIndex,
                                        value: 1,
                                        type: GameServer.INV_EQUIPMENT_ADD,
                                        sfxId: "wpn_ammo"
                                    });
                                    this.removeNextStep(interactable);
                                }
                                else if (!pawn.data["bNoPickups"])
                                {
                                    this.dropCharacterEquipment(pawn);
                                    this.requestEvent({
                                        eventId: GameServer.EVENT_PLAYER_UPDATE_INVENTORY,
                                        pawnId: pawn.data["id"],
                                        index: itemIndex,
                                        value: weaponData["id"],
                                        type: GameServer.INV_EQUIPMENT_SET,
                                        sfxId: "wpn_ammo"
                                    });
                                    this.removeNextStep(interactable);
                                    if (this.isTutorial())
                                    {
                                        this.requestEvent({
                                            eventId: GameServer.EVENT_MESSAGE_ADD,
                                            data: {
                                                message: "STR_CONTROL_EQUIPMENT",
                                                id: "tutorial_equipment",
                                            }
                                        });
                                    }
                                }                                
                            }
                            else
                            {
                                var inventory = pawn.data["inventory"];
                                var itemIndex = this.getCharacterInventoryItemIndex(pawn, weaponData["id"]);
                                if (itemIndex >= 0)
                                {
                                    if (!this.isMeleeWeapon(weaponData))
                                    {
                                        this.requestEvent({
                                            eventId: GameServer.EVENT_PLAYER_UPDATE_INVENTORY,
                                            pawnId: pawn.data["id"],
                                            index: itemIndex,
                                            value: (weaponData["mag"] + weaponData["ammo"]),
                                            type: GameServer.INV_AMMO_ADD,
                                            sfxId: "wpn_ammo",
                                            barrelAmmo: weaponData["barrelAmmo"]
                                        });
                                        this.removeNextStep(interactable);
                                    }
                                }
                                else if (!pawn.data["bNoPickups"])
                                {
                                    if (inventory.length <= 1)
                                    {
                                        if (inventory[0] && inventory[0].id == "none")
                                        {
                                            this.requestEvent({
                                                eventId: GameServer.EVENT_PLAYER_UPDATE_INVENTORY,
                                                pawnId: pawn.data["id"],
                                                index: 0,
                                                item: weaponData,
                                                type: GameServer.INV_ITEM_REPLACE
                                            });
                                        }
                                        else
                                        {
                                            this.requestEvent({
                                                eventId: GameServer.EVENT_PLAYER_UPDATE_INVENTORY,
                                                pawnId: pawn.data["id"],
                                                item: weaponData,
                                                type: GameServer.INV_ITEM_ADD,
                                                sfxId: "wpn_ammo"
                                            });
                                            if (this.isTutorial())
                                            {
                                                this.requestEvent({
                                                    eventId: GameServer.EVENT_MESSAGE_ADD,
                                                    data: {
                                                        message: "STR_CONTROL_SWITCH",
                                                        id: "tutorial_switch",
                                                    }
                                                });
                                            }
                                        }
                                    }
                                    else
                                    {
                                        var meleeIndex = pawn.data["currentInventoryIndex"];
                                        for (var i = 0; i < inventory.length; i++)
                                        {
                                            if (inventory[i].id == "none")
                                            {
                                                meleeIndex = i;
                                                break;
                                            }
                                        }
                                        this.dropCharacterWeapon(pawn, meleeIndex);
                                        this.requestEvent({
                                            eventId: GameServer.EVENT_PLAYER_UPDATE_INVENTORY,
                                            pawnId: pawn.data["id"],
                                            index: meleeIndex,
                                            item: weaponData,
                                            type: GameServer.INV_ITEM_REPLACE
                                        });
                                        if (meleeIndex >= 0)
                                        {
                                            this.requestEvent({
                                                eventId: GameServer.EVENT_PLAYER_UPDATE_INVENTORY,
                                                pawnId: pawn.data.id,
                                                value: meleeIndex,
                                                type: GameServer.INV_CURRENT_INVENTORY_INDEX
                                            });
                                        }
                                    }
                                    this.removeNextStep(interactable);
                                }
                            }
                        }
                        break;

                    case "crate":
                        if (interactData && pawn)
                        {
                            if (this.localData["bModeGame"])
                            {
                                if (pawn.data["id"] != interactData["ownerId"])
                                {
                                    switch (interactData["type"])
                                    {
                                        case Crate.CRATE_AMMO:
                                        case Crate.CRATE_KILLSTREAK:
                                        case Crate.CRATE_PERK:
                                        case Crate.CRATE_WEAPON:
                                            if (pawn.data["team"] == interactData["team"])
                                            {
                                                this.requestEvent({
                                                    eventId: GameServer.EVENT_PAWN_ACTION,
                                                    pawnId: interactData["ownerId"],
                                                    type: GameServer.PAWN_SHARED_CRATE
                                                });
                                            }
                                            else
                                            {
                                                this.requestEvent({
                                                    eventId: GameServer.EVENT_PAWN_ACTION,
                                                    pawnId: pawn.data["id"],
                                                    type: GameServer.PAWN_STOLE_CRATE
                                                });
                                            }
                                            break;
                                    }
                                }
                            }
                            switch (interactData["type"])
                            {
                                case Crate.CRATE_BOMB_GENERIC:
                                    if (!data["bBombPlanted"])
                                    {
                                        var gameModeData = this.localData.gameModeData;
                                        data["bBombPlanted"] = true;
                                        data["bEnabled"] = false;
                                        this.pushObjectDataUpdate(data.id, ["bBombPlanted", "bEnabled"]);
                                        var ps = this.getPlayerStateById(_playerId);
                                        if (ps)
                                        {
                                            ps["plants"]++;
                                            this.onEvent({
                                                eventId: GameServer.EVENT_PLAYER_UPDATE,
                                                playerId: _playerId,
                                                data: {
                                                    plants: ps["plants"]
                                                }
                                            });
                                        }
                                        this.emitAISound(interactable.position);
                                    }
                                    break;

                                case Crate.CRATE_BOMB:
                                    if (!this.matchInProgress())
                                    {
                                        break;
                                    }
                                    var ps = this.getPlayerStateById(_playerId);
                                    var gameModeData = this.localData.gameModeData;
                                    if (data["bBombPlanted"] && pawn.data["team"] != gameModeData["bombTeam"])
                                    {
                                        data["bBombPlanted"] = false;
                                        data["interactTeam"] = gameModeData["bombTeam"];
                                        this.pushObjectDataUpdate(data.id, ["bBombPlanted", "interactTeam"]);
                                        gameModeData["bBombPlanted"] = data["bBombPlanted"];
                                        //console.log("Bomb has been defused!");   
                                        gameModeData["playerId"] = _playerId;
                                        if (ps)
                                        {
                                            ps["defuses"]++;
                                            this.onEvent({
                                                eventId: GameServer.EVENT_PLAYER_UPDATE,
                                                playerId: _playerId,
                                                data: {
                                                    defuses: ps["defuses"]
                                                }
                                            });
                                        }   
                                        this.onEvent({
                                            eventId: GameServer.EVENT_GAME_UPDATE,
                                            gameModeData: {
                                                bBombPlanted: false,
                                                playerId: _playerId,
                                                scores: gameModeData.scores
                                            }
                                        });
                                        this.winRound(MatchState.END_CONDITION_DEFUSE, pawn.data["team"], 1, {
                                            id: _playerId
                                        });   
                                    }
                                    else if (!data["bBombPlanted"] && pawn.data["team"] == gameModeData["bombTeam"])
                                    {
                                        gameModeData["bombTimer"] = gameModeData["bombTimerMax"];
                                        data["bBombPlanted"] = true;
                                        data["interactTeam"] = gameModeData["bombTeam"] == 0 ? 1 : 0;
                                        data.interactData["interactTime"] = this.localData.gameModeData["defuseTime"];
                                        data.planterId = pawn.data.id;
                                        this.pushObjectDataUpdate(data.id, ["bBombPlanted", "interactTeam"]);
                                        gameModeData["bBombPlanted"] = data["bBombPlanted"];
                                        //console.log("Bomb has been planted!");
                                        if (ps)
                                        {
                                            ps["plants"]++;
                                            this.onEvent({
                                                eventId: GameServer.EVENT_PLAYER_UPDATE,
                                                playerId: _playerId,
                                                data: {
                                                    plants: ps["plants"]
                                                }
                                            });
                                        }
                                        this.onEvent({
                                            eventId: GameServer.EVENT_GAME_UPDATE,
                                            gameModeData: {
                                                bBombPlanted: true,
                                                bombTimer: gameModeData["bombTimer"],
                                                playerId: _playerId
                                            }
                                        });
                                    }
                                    break;

                                case Crate.CRATE_STORE:
                                    var ps = this.getPlayerStateById(_playerId);
                                    if (pawn && ps && ps["bBot"])
                                    {
                                        var bNeedsWeapon = this.characterNeedsWeapon(pawn);
                                        var desiredItem = this.getRandomWeapon();
                                        if (bNeedsWeapon && ps["money"] >= desiredItem["cost"])
                                        {
                                            this.purchaseStoreItem(ps["id"], {
                                                type: "item",
                                                itemId: desiredItem["id"],
                                                index: 1
                                            });
                                        }
                                        else
                                        {
                                            if (ps["killstreaks"].length == 0)
                                            {
                                                var desiredKillstreak = this.getKillstreakData(Killstreaks.KILLSTREAK_AMMO);
                                                if (ps["money"] >= desiredKillstreak["moneyCost"])
                                                {
                                                    this.purchaseStoreItem(ps["id"], {
                                                        type: "killstreak",
                                                        killstreakId: desiredKillstreak["id"]
                                                    });
                                                }
                                            }
                                        }
                                        delete pawn.data.ai["interactableId"];
                                    }
                                    break;

                                case Crate.CRATE_AMMO:
                                    inventory = pawn.data["inventory"];
                                    var numMags = this.localData["bSurvival"] ? 5 : 3;
                                    for (var i = 0; i < inventory.length; i++)
                                    {
                                        if (!inventory[i]["bMelee"])
                                        {
                                            this.requestEvent({
                                                eventId: GameServer.EVENT_PLAYER_UPDATE_INVENTORY,
                                                pawnId: pawn.data.id,
                                                index: i,
                                                type: GameServer.INV_AMMO_ADD,
                                                value: inventory[i]["magSize"] * numMags,
                                                barrelAmmo: 1
                                            });
                                        }
                                    }
                                    this.requestEvent({
                                        eventId: GameServer.EVENT_PLAYER_UPDATE_INVENTORY,
                                        pawnId: pawn.data["id"],
                                        type: GameServer.INV_EQUIPMENT_ADD,
                                        value: 1
                                    });
                                    this.removeNextStep(interactable);                                    
                                    break;

                                case Crate.CRATE_KILLSTREAK:
                                    this.requestEvent({
                                        eventId: GameServer.EVENT_PLAYER_EARN_KILLSTREAK,
                                        playerId: _playerId,
                                        killstreakId: interactData["killstreakId"],
                                        bAcquired: true
                                    });
                                    this.removeNextStep(interactable);
                                    if (this.isTutorial())
                                    {
                                        this.requestEvent({
                                            eventId: GameServer.EVENT_MESSAGE_ADD,
                                            data: {
                                                message: "STR_CONTROL_KILLSTREAK",
                                                id: "tutorial_killstreak",
                                            }
                                        });
                                    }
                                    break;

                                case Crate.CRATE_DECOY:
                                    this.createExplosion({
                                        eventId: GameServer.EVENT_SPAWN_EXPLOSION,
                                        x: interactable.position[0],
                                        y: interactable.position[1],
                                        radius: 500,
                                        damage: 500,
                                        playerId: data.interactData["ownerId"],
                                        causerId: data["id"],
                                        weaponId: Killstreaks.KILLSTREAK_DECOY,
                                        bDirectlyCausedByPlayer: true
                                    });
                                    this.removeNextStep(interactable);
                                    break;

                                case Crate.CRATE_SHARD:
                                    this.addBattlezoneLoot(_playerId, 0, data.interactData.shards);
                                    this.removeNextStep(interactable);
                                    break;

                                case Crate.CRATE_XP:
                                    this.addBattlezoneLoot(_playerId, data.interactData.xp, 0);
                                    this.removeNextStep(interactable);
                                    break;

                                case Crate.CRATE_LIFE:
                                    var ps = this.getPlayerStateById(_playerId);
                                    if (ps)
                                    {
                                        ps.lives += data.interactData.lives;
                                        this.onEvent({
                                            eventId: GameServer.EVENT_PLAYER_UPDATE,
                                            playerId: ps.id,
                                            data: {
                                                lives: ps.lives
                                            }
                                        });
                                    }
                                    this.removeNextStep(interactable);
                                    break;

                                case Crate.CRATE_WEAPON:
                                    var items = data.interactData.items;
                                    for (var i = 0; i < items.length; i++)
                                    {
                                        var weaponData = items[i];
                                        if (this.localData.gameModeData["id"] == GameMode.SURVIVAL_STAKEOUT)
                                        {
                                            weaponData["ammo"] += weaponData["magSize"] * 3;
                                        }
                                        this.createDroppedWeapon(this.getRandomUniqueId(), [interactable.position[0], interactable.position[1] - 10] , 0, 1, {
                                            weaponData: weaponData,
                                            playerId: data.interactData["playerId"]
                                        }, [this.Random(-100, 100), this.Random(-200, -100)], this.Random(0, 5));
                                    }
                                    this.removeNextStep(interactable);
                                    break;

                                case Crate.CRATE_PERK:
                                    this.requestEvent({
                                        eventId: GameServer.EVENT_PLAYER_UPDATE_INVENTORY,
                                        pawnId: _playerId,
                                        type: GameServer.INV_PERK_ADD,
                                        perkId: data.interactData["perkId"],
                                    });
                                    this.removeNextStep(interactable);
                                    break;
                            }
                        }
                        break;
                }
            }
        }
    }

    getCurrentPlayerKillstreak(_playerId)
    {
        var ps = this.getPlayerStateById(_playerId);
        if (ps)
        {
            var killstreaks = ps["killstreaks"];
            if (!killstreaks || killstreaks.length === 0)
            {
                return null;
            }
            return killstreaks[ps["currentKillstreakIndex"]];
        }
        return null;
    }

    addBattlezoneLoot(_playerId, _xp = 0, _shards = 0)
    {
        if (this.localData["bBattlezone"])
        {
            var pawn = this.getObjectById(_playerId);
            var ps = this.getPlayerStateById(_playerId);
            if (ps)
            {
                if (ps.bHasPawn && pawn)
                {
                    if (ps.xp == null || isNaN(ps.xp))
                    {
                        ps.xp = 0;
                    }
                    if (_xp != null)
                    {
                        ps.xp = Math.min(Battlezone.MAX_XP, ps.xp + _xp);
                    }
                    if (ps.shards == null || isNaN(ps.shards))
                    {
                        ps.shards = 0;
                    }
                    if (_shards != null)
                    {
                        ps.shards = Math.min(Battlezone.MAX_SHARDS, ps.shards + _shards);
                    }
                    this.onEvent({
                        eventId: GameServer.EVENT_PLAYER_UPDATE,
                        playerId: ps.id,
                        data: {
                            xp: ps.xp,
                            shards: ps.shards
                        }
                    });
                }
            }
            else
            {
                if (pawn && !pawn.data.bZombie && pawn.data.health > 0)
                {
                    if (!pawn.data.loot)
                    {
                        pawn.data.loot = {
                            xp: 0,
                            shards: 0
                        };
                    }
                    if (_xp)
                    {
                        pawn.data.loot.xp = Math.min(Battlezone.MAX_XP, pawn.data.loot.xp + _xp);
                    }
                    if (_shards)
                    {
                        pawn.data.loot.shards = Math.min(Battlezone.MAX_SHARDS, pawn.data.loot.shards + _shards);
                    }
                }
            }
        }
    }

    executePlayerKillstreak(_playerId, _ksId, _worldX, _worldY, _bSilent)
    {
        var ps = this.getPlayerStateById(_playerId);
        if (!ps)
        {
            console.warn("Invalid player state");
            return;
        }
        var killstreakId = _ksId;
        if (killstreakId)
        {
            var ksData = this.getKillstreakData(killstreakId);
            if (ksData)
            {
                this.addBattlezoneLoot(ps.id, ksData.xpReward ? ksData.xpReward : 100);
            }
            this.onEvent({
                eventId: GameServer.EVENT_PLAYER_EXECUTE_KILLSTREAK,
                playerId: _playerId,
                killstreakId: killstreakId,
                team: ps["team"],
                bSilent: _bSilent,
                position: [_worldX, _worldY]
            });
            var map = this.getCurrentMapData();
            var char = this.getObjectById(_playerId);
            var desiredAirdropScale = _worldX < (map.width * 0.5) ? 1 : -1;
            var desiredAirdropX = desiredAirdropScale === 1 ? 100 : (map.width - 100);
            switch (killstreakId)
            {
                case Killstreaks.KILLSTREAK_UAV_SUPPORT:
                case Killstreaks.KILLSTREAK_UAV:
                    this.addKillstreak({
                        id: killstreakId,
                        playerId: ps["id"],
                        team: ps["team"],
                        timer: this.localData.settings.fps * 30
                    });
                    break;

                case Killstreaks.KILLSTREAK_COUNTER_UAV:
                    this.addKillstreak({
                        id: killstreakId,
                        playerId: ps["id"],
                        team: ps["team"],
                        timer: this.localData.settings.fps * 15
                    });
                    break;

                case Killstreaks.KILLSTREAK_JUGGERNAUT:
                    this.createHelicopter([desiredAirdropX, 0], ps["team"], {
                        type: Helicopter.TYPE_MH6,
                        playerId: ps["id"],
                        destination: [_worldX, Math.min(this.getHeliMaxY(), _worldY)],
                        items: [
                            {
                                type: "crate",
                                crateType: Crate.CRATE_KILLSTREAK,
                                killstreakId: Killstreaks.KILLSTREAK_JUGGERNAUT_USE
                            }
                        ],
                        scale: desiredAirdropScale
                    });
                    break;

                case Killstreaks.KILLSTREAK_JUGGERNAUT_USE:
                    this.makePlayerJuggernaut(ps["id"], Killstreaks.KILLSTREAK_JUGGERNAUT);
                    break;

                case Killstreaks.KILLSTREAK_JUGGERNAUT_RECON:
                    this.createHelicopter([desiredAirdropX, 0], ps["team"], {
                        type: Helicopter.TYPE_MH6,
                        playerId: ps["id"],
                        destination: [_worldX, Math.min(this.getHeliMaxY(), _worldY)],
                        items: [
                            {
                                type: "crate",
                                crateType: Crate.CRATE_KILLSTREAK,
                                killstreakId: Killstreaks.KILLSTREAK_JUGGERNAUT_RECON_USE
                            }
                        ],
                        scale: desiredAirdropScale
                    });
                    break;

                case Killstreaks.KILLSTREAK_JUGGERNAUT_RECON_USE:
                    this.makePlayerJuggernaut(ps["id"], Killstreaks.KILLSTREAK_JUGGERNAUT_RECON);
                    break;

                case Killstreaks.KILLSTREAK_CARE_PACKAGE:
                    this.createHelicopter([desiredAirdropX, 0], ps["team"], {
                        type: Helicopter.TYPE_MH6,
                        playerId: ps["id"],
                        destination: [_worldX, Math.min(this.getHeliMaxY(), _worldY)],
                        items: [
                            {
                                type: "crate",
                                crateType: Crate.CRATE_KILLSTREAK,
                            }
                        ],
                        scale: desiredAirdropScale
                    });
                    break;

                case Killstreaks.KILLSTREAK_AMMO:
                    this.createHelicopter([desiredAirdropX, 0], ps["team"], {
                        type: Helicopter.TYPE_MH6,
                        playerId: ps["id"],
                        destination: [_worldX, Math.min(this.getHeliMaxY(), _worldY)],
                        items: [
                            {
                                type: "crate",
                                crateType: Crate.CRATE_AMMO
                            }
                        ],
                        scale: desiredAirdropScale
                    });
                    break;

                case Killstreaks.KILLSTREAK_SUPPORT_AIRDROP:                    
                    if (this.RandomBoolean())
                    {
                        var items = [];
                        var numItems = this.Random(1, 3);
                        for (var i = 0; i < numItems; i++)
                        {
                            var randomWeapon = this.getRandomWeapon(this.localData.gameModeData["id"] == GameMode.SURVIVAL_STAKEOUT);
                            var weaponMods = this.getRandomMods(randomWeapon);
                            this.applyWeaponMods(randomWeapon, weaponMods);
                            items.push(randomWeapon);
                        }
                        var supportItem = {
                            type: "crate",
                            crateType: Crate.CRATE_WEAPON,
                            items: items
                        };
                    }
                    else
                    {
                        supportItem = {
                            type: "crate",
                            crateType: Crate.CRATE_PERK,
                            perkId: this.getRandomPerk()
                        };
                    }
                    this.createHelicopter([desiredAirdropX, 0], ps["team"], {
                        type: Helicopter.TYPE_MH6,
                        playerId: ps["id"],
                        destination: [_worldX, Math.min(this.getHeliMaxY(), _worldY)],
                        items: [supportItem],
                        scale: desiredAirdropScale
                    });
                    break;

                case Killstreaks.KILLSTREAK_WEAPON:
                    var items = [];
                    var numWeapons = this.localData.gameModeData.id == GameMode.SURVIVAL_STAKEOUT ? 3 : 1;
                    for (var i = 0; i < numWeapons; i++)
                    {
                        var randomWeapon = this.getRandomWeapon(this.localData.gameModeData.id == GameMode.SURVIVAL_STAKEOUT);
                        var weaponMods = this.getRandomMods(randomWeapon);
                        this.applyWeaponMods(randomWeapon, weaponMods);
                        if (randomWeapon["ammo"] != null && randomWeapon["magSize"] != null)
                        {
                            randomWeapon["ammo"] = this.Random(0, randomWeapon["magSize"]);
                        }
                        items.push(randomWeapon);
                    }

                    this.createHelicopter([desiredAirdropX, 0], ps["team"], {
                        type: Helicopter.TYPE_MH6,
                        playerId: ps["id"],
                        destination: [_worldX, Math.min(this.getHeliMaxY(), _worldY)],
                        items: [
                            {
                                type: "crate",
                                crateType: Crate.CRATE_WEAPON,
                                items: items
                            }
                        ],
                        scale: desiredAirdropScale
                    });
                    break;

                case Killstreaks.KILLSTREAK_WEAPON_M202:
                    var m202 = this.getWeaponData("m202");                    
                    this.applyWeaponMods(m202, {
                        base: Mods.BASE_MODE_SELECTOR,
                        barrel: Mods.BARREL_LASER,
                        ammo: Mods.AMMO_LAUNCHER_EXPLOSIVE
                    });
                    m202.damage = 500;
                    m202.ammo = 20;
                    m202.mag = 10;
                    m202.magSize = 10;
                    this.createHelicopter([desiredAirdropX, 0], ps["team"], {
                        type: Helicopter.TYPE_MH6,
                        playerId: ps["id"],
                        destination: [_worldX, Math.min(this.getHeliMaxY(), _worldY)],
                        items: [
                            {
                                type: "crate",
                                crateType: Crate.CRATE_WEAPON,
                                weaponData: m202
                            }
                        ],
                        scale: desiredAirdropScale
                    });
                    break;

                case Killstreaks.KILLSTREAK_WEAPON_MINIGUN:
                    var minigun = this.getWeaponData("minigun");
                    this.createHelicopter([desiredAirdropX, 0], ps["team"], {
                        type: Helicopter.TYPE_MH6,
                        playerId: ps["id"],
                        destination: [_worldX, Math.min(this.getHeliMaxY(), _worldY)],
                        items: [
                            {
                                type: "crate",
                                crateType: Crate.CRATE_WEAPON,
                                weaponData: minigun
                            }
                        ],
                        scale: desiredAirdropScale
                    });
                    break;

                case Killstreaks.KILLSTREAK_PERK:
                    var perks = this.getSurvivalPerks();
                    var tmp = {};
                    for (var i = 0; i < perks.length; i++)
                    {
                        if (!this.characterHasPerk(char, perks[i]))
                        {
                            tmp[perks[i]] = 1;
                        }
                    }
                    var perkId = this.getRandomProperty(tmp);
                    if (perkId)
                    {
                        this.createHelicopter([desiredAirdropX, 0], ps["team"], {
                            type: Helicopter.TYPE_MH6,
                            playerId: ps["id"],
                            destination: [_worldX, Math.min(this.getHeliMaxY(), _worldY)],
                            items: [
                                {
                                    type: "crate",
                                    crateType: Crate.CRATE_PERK,
                                    perkId: perkId
                                }
                            ],
                            scale: desiredAirdropScale
                        });
                    }
                    break;

                case Killstreaks.KILLSTREAK_DECOY:
                    this.createHelicopter([desiredAirdropX, 0], ps["team"], {
                        type: Helicopter.TYPE_MH6,
                        playerId: ps["id"],
                        destination: [_worldX, Math.min(this.getHeliMaxY(), _worldY)],
                        items: [
                            {
                                type: "crate",
                                crateType: Crate.CRATE_DECOY,
                                playerId: ps["id"]
                            }
                        ],
                        scale: desiredAirdropScale
                    });
                    break;

                case Killstreaks.KILLSTREAK_SAM_TURRET:
                    this.createHelicopter([desiredAirdropX, 0], ps["team"], {
                        type: Helicopter.TYPE_MH6,
                        playerId: ps["id"],
                        destination: [_worldX, Math.min(this.getHeliMaxY(), _worldY)],
                        items: [
                            {
                                type: "crate",
                                crateType: Crate.CRATE_KILLSTREAK,
                                killstreakId: Killstreaks.KILLSTREAK_SAM_TURRET_PLACE,
                                playerId: ps["id"]
                            }
                        ],
                        scale: desiredAirdropScale
                    });
                    break;

                case Killstreaks.KILLSTREAK_SENTRY_GUN:
                    this.createHelicopter([desiredAirdropX, 0], ps["team"], {
                        type: Helicopter.TYPE_MH6,
                        playerId: ps["id"],
                        destination: [_worldX, Math.min(this.getHeliMaxY(), _worldY)],
                        items: [
                            {
                                type: "crate",
                                crateType: Crate.CRATE_KILLSTREAK,
                                killstreakId: Killstreaks.KILLSTREAK_SENTRY_GUN_PLACE,
                                playerId: ps["id"]
                            }
                        ],
                        scale: desiredAirdropScale
                    });
                    break;

                case Killstreaks.KILLSTREAK_SAM_TURRET_PLACE:
                    this.createTurret(this.getRandomUniqueId(), char.position, char.data.scale, ps.team, {
                        type: Turret.TYPE_SAM,
                        playerId: ps["id"]
                    });
                    break;

                case Killstreaks.KILLSTREAK_SENTRY_GUN_PLACE:
                    this.createTurret(this.getRandomUniqueId(), char.position, char.data.scale, ps.team, {
                        type: Turret.TYPE_SENTRY,
                        playerId: ps["id"]
                    });
                    break;

                case Killstreaks.KILLSTREAK_REMOTE_TURRET:
                    this.createTurret(this.getRandomUniqueId(), char.position, char.data.scale, ps.team, {
                        type: Turret.TYPE_REMOTE,
                        playerId: ps["id"]
                    });
                    break;

                case Killstreaks.KILLSTREAK_ADVANCED_TURRET:
                    this.createTurret(this.getRandomUniqueId(), char.position, char.data.scale, ps.team, {
                        type: Turret.TYPE_BALLISTIC,
                        playerId: ps["id"]
                    });
                    break;

                case Killstreaks.KILLSTREAK_GRENADE_TURRET:
                    this.createTurret(this.getRandomUniqueId(), char.position, char.data.scale, ps.team, {
                        type: Turret.TYPE_GRENADE,
                        playerId: ps["id"]
                    });
                    break;

                case Killstreaks.KILLSTREAK_RCXD:
                    this.createCar([char.position[0], char.position[1] - 40], char.data.team, {
                        carType: Car.TYPE_RCXD,
                        playerId: _playerId
                    });
                    break;

                case Killstreaks.KILLSTREAK_HELLFIRE:
                    this.createRocket([_worldX, 0], {
                        type: Rocket.TYPE_HELLFIRE,
                        team: ps["team"],
                        playerId: _playerId,
                        causerId: _playerId,
                        rotation: this.ToRad(90),
                        weaponId: Killstreaks.KILLSTREAK_HELLFIRE
                    });
                    break;

                case Killstreaks.KILLSTREAK_AIRSTRIKE:
                    var rockets = [];
                    for (var i = 0; i < 5; i++)
                    {
                        var startX = _worldX + this.Random(-100, 100);
                        var startY = 0;
                        var angle = this.Angle(startX, startY, _worldX + this.Random(-50, 50), _worldY);
                        rockets.push({
                            timer: this.localData.settings.fps + (i * (30 * this.localData.settings.fps_mult)),
                            position: [startX, startY],
                            rocketData: {
                                type: Rocket.TYPE_DEFAULT,
                                team: ps["team"],
                                playerId: _playerId,
                                causerId: _playerId,
                                rotation: angle,
                                weaponId: Killstreaks.KILLSTREAK_AIRSTRIKE
                            }
                        });
                        this.addKillstreak({
                            id: killstreakId,
                            playerId: ps["id"],
                            team: ps["team"],
                            timer: this.localData.settings.fps * 2,
                            rockets: rockets
                        });
                    }
                    break;

                case Killstreaks.KILLSTREAK_NAPALM:
                    var rockets = [];
                    for (var i = 0; i < 3; i++)
                    {
                        var startX = _worldX + this.Random(-100, 100);
                        var startY = 0;
                        var angle = this.Angle(startX, startY, _worldX + this.Random(-50, 50), _worldY);
                        rockets.push({
                            timer: this.localData.settings.fps + (i * (45 * this.localData.settings.fps_mult)),
                            position: [startX, startY],
                            rocketData: {
                                type: Rocket.TYPE_NAPALM,
                                team: ps["team"],
                                playerId: _playerId,
                                causerId: _playerId,
                                rotation: angle,
                                weaponId: Killstreaks.KILLSTREAK_NAPALM
                            }
                        });
                        this.addKillstreak({
                            id: killstreakId,
                            playerId: ps["id"],
                            team: ps["team"],
                            timer: this.localData.settings.fps * 15,
                            rockets: rockets
                        });
                    }
                    break;

                case Killstreaks.KILLSTREAK_BOMBARDMENT:
                    var rockets = [];
                    for (var i = 0; i < 30; i++)
                    {
                        var startX = _worldX + this.Random(-50, 50);
                        var startY = 0;
                        var angle = this.Angle(startX, startY, _worldX + this.Random(-100, 100), _worldY);
                        rockets.push({
                            timer: this.localData.settings.fps + (i * (30 * this.localData.settings.fps_mult)),
                            position: [startX, startY],
                            rocketData: {
                                type: Rocket.TYPE_DEFAULT,
                                team: ps["team"],
                                playerId: _playerId,
                                causerId: _playerId,
                                rotation: angle,
                                weaponId: Killstreaks.KILLSTREAK_BOMBARDMENT
                            }
                        });
                    }
                    this.addKillstreak({
                        id: killstreakId,
                        playerId: ps["id"],
                        team: ps["team"],
                        timer: this.localData.settings.fps * (this.localData["bSurvival"] ? 15 : 10),
                        rockets: rockets
                    });
                    break;

                case Killstreaks.KILLSTREAK_STEALTH_BOMBER:
                    var rockets = [];
                    for (var i = 0; i < 5; i++)
                    {
                        var startX = _worldX + (i * 200) - 400;
                        var startY = 0;
                        var angle = this.ToRad(90); //this.Angle(startX, startY, startX, _worldY);
                        rockets.push({
                            timer: (this.localData.settings.fps * 2) + (i * Math.round(10 * this.localData.settings.fps_mult)),
                            position: [startX, startY],
                            rocketData: {
                                type: Rocket.TYPE_DEFAULT,
                                team: ps["team"],
                                playerId: _playerId,
                                causerId: _playerId,
                                rotation: angle,
                                weaponId: Killstreaks.KILLSTREAK_STEALTH_BOMBER
                            }
                        });
                    }
                    this.addKillstreak({
                        id: killstreakId,
                        playerId: ps["id"],
                        team: ps["team"],
                        timer: this.localData.settings.fps * 3,
                        rockets: rockets
                    });
                    break;

                case Killstreaks.KILLSTREAK_COBRA:
                    this.createHelicopter([_worldX, 0], ps["team"], {
                        type: Helicopter.TYPE_COBRA,
                        playerId: ps["id"],
                        destination: [_worldX, _worldY]
                    });
                    break;

                case Killstreaks.KILLSTREAK_COBRA_CONTROLLABLE:
                    var heli = this.createHelicopter([_worldX, 0], ps["team"], {
                        type: Helicopter.TYPE_COBRA_CONTROLLABLE,
                        playerId: ps["id"],
                        destination: [_worldX, _worldY]
                    });
                    heli.data["bBot"] = ps["bBot"];
                    heli.data["bPlayerControlled"] = !ps["bBot"];
                    break;

                case Killstreaks.KILLSTREAK_MH6:
                    this.createHelicopter([_worldX, 0], ps["team"], {
                        type: Helicopter.TYPE_MH6_ATTACK,
                        playerId: ps["id"],
                        destination: [_worldX, map.height * 0.5]
                    });
                    break;

                case Killstreaks.KILLSTREAK_MH6_GRENADE:
                    var heli = this.createHelicopter([_worldX, 0], ps["team"], {
                        type: Helicopter.TYPE_MH6_GRENADE,
                        playerId: ps["id"],
                        destination: [_worldX, map.height * 0.5]
                    });
                    heli.data["bBot"] = ps["bBot"];
                    heli.data["bPlayerControlled"] = !ps["bBot"];
                    break;

                case Killstreaks.KILLSTREAK_CHOPPER_GUNNER:
                    var heli = this.createHelicopter([_worldX, 0], ps["team"], {
                        type: Helicopter.TYPE_BLACKHAWK,
                        playerId: ps["id"],
                        destination: [map.width * 0.5, map.height * 0.5]
                    });
                    heli.data["bBot"] = ps["bBot"];
                    heli.data["bPlayerControlled"] = !ps["bBot"];
                    break;

                case Killstreaks.KILLSTREAK_HELI_SNIPER:
                    var heli = this.createHelicopter([_worldX, 0], ps["team"], {
                        type: Helicopter.TYPE_BLACKHAWK_SNIPER,
                        playerId: ps["id"],
                        destination: [map.width * 0.5, map.height * 0.5]
                    });
                    heli.data["bBot"] = ps["bBot"];
                    heli.data["bPlayerControlled"] = !ps["bBot"];
                    break;

                case Killstreaks.KILLSTREAK_REAPER:
                    var map = this.getCurrentMapData();
                    var heli = this.createHelicopter([_worldX, 0], ps["team"], {
                        type: Helicopter.TYPE_REAPER,
                        playerId: ps["id"],
                        destination: [map.width * 0.5, map.height * 0.5]
                    });
                    heli.data["bBot"] = ps["bBot"];
                    heli.data["bPlayerControlled"] = !ps["bBot"];
                    break;

                case Killstreaks.KILLSTREAK_DRAGONFIRE:
                    var map = this.getCurrentMapData();
                    var ownerPawn = this.getObjectById(ps["id"]);
                    var pos = ownerPawn ? [ownerPawn.position[0], ownerPawn.position[1] - 40] : [_worldX, _worldY];
                    var heli = this.createHelicopter(pos, ps["team"], {
                        type: Helicopter.TYPE_DRAGONFIRE,
                        playerId: ps["id"],
                        destination: [pos[0], pos[1] - 20]
                    });
                    heli.data["bBot"] = ps["bBot"];
                    heli.data["bPlayerControlled"] = !ps["bBot"];
                    break;

                case Killstreaks.KILLSTREAK_SCOUT:
                    var map = this.getCurrentMapData();
                    var heli = this.createHelicopter([_worldX, 0], ps["team"], {
                        type: Helicopter.TYPE_SCOUT,
                        playerId: ps["id"],
                        destination: [_worldX, map.height * 0.5],
                        items: [
                            {
                                type: "crate",
                                crateType: Crate.CRATE_AMMO,
                            }
                        ]
                    });
                    break;

                case Killstreaks.KILLSTREAK_PAVE_LOW:
                    this.createHelicopter([map.width * 0.5, 0], ps["team"], {
                        type: Helicopter.TYPE_PAVE_LOW,
                        playerId: ps["id"],
                        destination: null
                    });
                    break;

                case Killstreaks.KILLSTREAK_ESCORT_AIRDROP:
                    this.createHelicopter([desiredAirdropX, 0], ps["team"], {
                        type: Helicopter.TYPE_OSPREY,
                        playerId: ps["id"],
                        destination: [_worldX, Math.max(200, Math.min(this.getHeliMaxY(), _worldY - 200))],
                        items: [
                            {
                                type: "crate",
                                crateType: Crate.CRATE_KILLSTREAK,
                                playerId: ps["id"]
                            },
                            {
                                type: "crate",
                                crateType: Crate.CRATE_KILLSTREAK,
                                playerId: ps["id"]
                            },
                            {
                                type: "crate",
                                crateType: Crate.CRATE_KILLSTREAK,
                                playerId: ps["id"]
                            },
                            {
                                type: "crate",
                                crateType: Crate.CRATE_KILLSTREAK,
                                playerId: ps["id"]
                            },
                            {
                                type: "crate",
                                crateType: Crate.CRATE_KILLSTREAK,
                                playerId: ps["id"]
                            }
                        ],
                        scale: desiredAirdropScale
                    });
                    break;

                case Killstreaks.KILLSTREAK_ESCORT_AIRDROP_SURVIVAL:
                    var escortItems = [];
                    for (var i = 0; i < 3; i++)
                    {
                        var items = [];
                        var numItems = this.Random(1, 3);
                        for (var j = 0; j < numItems; j++)
                        {
                            var randomWeapon = this.getRandomWeapon(this.localData.gameModeData["id"] == GameMode.SURVIVAL_STAKEOUT);
                            var weaponMods = this.getRandomMods(randomWeapon);
                            this.applyWeaponMods(randomWeapon, weaponMods);
                            items.push(randomWeapon);
                        }
                        escortItems.push({
                            type: "crate",
                            crateType: Crate.CRATE_WEAPON,
                            playerId: ps["id"],
                            items: items
                        });
                    }
                    if (this.localData.gameModeData["id"] === GameMode.SURVIVAL_STAKEOUT)
                    {
                        for (var i = 0; i < this.localData.playerStates.length; i++)
                        {
                            escortItems.push({
                                type: "crate",
                                crateType: Crate.CRATE_KILLSTREAK,
                                playerId: ps["id"]
                            });
                        }
                    }
                    for (var i = 0; i < 3; i++)
                    {
                        escortItems.push({
                            type: "crate",
                            crateType: Crate.CRATE_AMMO,
                            playerId: ps["id"]
                        });
                    }
                    var osprey = this.createHelicopter([desiredAirdropX, 0], ps["team"], {
                        type: Helicopter.TYPE_OSPREY,
                        playerId: ps["id"],
                        destination: [_worldX, Math.max(200, Math.min(this.getHeliMaxY(), _worldY - 200))],
                        items: escortItems,
                        scale: desiredAirdropScale
                    });
                    break;

                case Killstreaks.KILLSTREAK_EMP:
                    this.executeEMP(ps["id"]);
                    this.addKillstreak({
                        id: killstreakId,
                        playerId: ps["id"],
                        team: ps["team"],
                        timer: this.localData.settings.fps * 30
                    });
                    break;

                case Killstreaks.KILLSTREAK_DEADSWITCH:
                    this.addKillstreak({
                        id: killstreakId,
                        playerId: ps["id"],
                        team: ps["team"],
                        timer: this.localData.settings.fps * 3
                    });
                    break;

                default:
                    this.log("Unhandled killstreak: " + killstreakId);
                    break;
            }
        }
    }

    triggerPlayerCurrentKillstreak(_playerId, _worldX, _worldY)
    {
        _worldY = Math.min(1500, _worldY);
        var ps = this.getPlayerStateById(_playerId);
        var killstreaks = ps["killstreaks"];
        var currentKillstreakIndex = ps["currentKillstreakIndex"];
        var killstreakId = killstreaks[currentKillstreakIndex];
        if (!this.canUseKillstreak(_playerId, killstreakId))
        {
            this.onEvent({
                eventId: GameServer.EVENT_PLAYER_EXECUTE_KILLSTREAK,
                playerId: _playerId,
                killstreakId: killstreakId,
                team: ps["team"],
                bUnavailable: true
            });
            return;
        }
        killstreaks.splice(currentKillstreakIndex, 1);
        ps["currentKillstreakIndex"] = Math.min(killstreaks.length - 1, currentKillstreakIndex);
        if (killstreakId)
        {
            this.onEvent({
                eventId: GameServer.EVENT_PLAYER_UPDATE,
                playerId: _playerId,
                data: {
                    killstreaks: ps["killstreaks"],
                    currentKillstreakIndex: ps["currentKillstreakIndex"]
                }
            });
            this.executePlayerKillstreak(ps.id, killstreakId, _worldX, _worldY);
        }
    }

    executeEMP(_playerId)
    {
        if (this.matchHasEnded())
        {
            return;
        }
        var ps = this.getPlayerStateById(_playerId);
        var electronics = this.getEMPItems();
        for (var i = 0; i < electronics.length; i++)
        {
            var curItem = electronics[i];
            if (curItem.data["team"] != ps["team"])
            {
                if (curItem.data["health"])
                {
                    this.requestEvent({
                        eventId: GameServer.EVENT_PAWN_DAMAGE,
                        damageType: DamageType.DAMAGE_EXPLOSIVE,
                        damageAmount: 5000,
                        pawnId: curItem.data["id"],
                        attackerId: ps["id"],
                        causerId: ps["id"],
                        weaponId: Killstreaks.KILLSTREAK_EMP,
                        bDirectlyCausedByPlayer: true
                    });
                }
            }
        }
        var chars = this.getCharacters();
        for (var i = 0; i < chars.length; i++)
        {
            var char = chars[i];
            if (char.data.bJuggernaut)
            {
                this.requestEvent({
                    eventId: GameServer.EVENT_PAWN_DAMAGE,
                    damageType: DamageType.DAMAGE_EXPLOSIVE,
                    damageAmount: this.getCharacterHealth(),
                    pawnId: char.data["id"],
                    attackerId: ps["id"],
                    causerId: ps["id"],
                    weaponId: Killstreaks.KILLSTREAK_EMP,
                    bDirectlyCausedByPlayer: false
                });
            }
        }
    }

    executeDeadswitch(_playerId)
    {
        if (this.matchHasEnded())
        {
            return;
        }
        var ps = this.getPlayerStateById(_playerId);
        if (ps)
        {
            if (this.localData["bOperation"])
            {
                this.localData.bDeadswitch = true;
            }
            var pawns = this.getPawns();
            for (var i = 0; i < pawns.length; i++)
            {
                var curPawn = pawns[i];
                if (curPawn.data["type"])
                {
                    var bKill = true;
                    if (this.localData["bSurvival"] && curPawn.data["team"] == ps["team"])
                    {
                        bKill = false;
                    }
                    if (bKill)
                    {
                        var damage = curPawn.data["health"];
                        if (curPawn.data.damageMultipliers)
                        {
                            curPawn.data.damageMultipliers[DamageType.DAMAGE_EXPLOSIVE] = 1;
                        }
                        if (curPawn.data.perks)
                        {
                            curPawn.data.perks = [];
                        }
                        this.requestEvent({
                            eventId: GameServer.EVENT_PAWN_DAMAGE,
                            damageType: DamageType.DAMAGE_EXPLOSIVE,
                            damageAmount: Math.max(damage, 500),
                            pawnId: curPawn.data["id"],
                            attackerId: ps["id"],
                            causerId: ps["id"],
                            weaponId: Killstreaks.KILLSTREAK_DEADSWITCH,
                            bDirectlyCausedByPlayer: false
                        });
                    }
                }
            }
            if (this.localData["bSurvival"])
            {
                this.localData["deadswitchCooldownTimer"] = this.localData.settings.fps * 10;
            }
            else if (this.localData["bModeGame"] || this.localData["bOperation"])
            {
                this.requestEvent({
                    eventId: GameServer.EVENT_GAME_END,
                    condition: MatchState.END_CONDITION_NUKE,
                    winningTeam: ps.team,
                    playerSpotlight: {
                        id: ps.id
                    }
                });
            }
        }
    }

    killPawn(_id)
    {
        var curPawn = this.getObjectById(_id);
        if (curPawn)
        {
            var damage = curPawn.data["health"];
            if (curPawn.data.damageMultipliers)
            {
                curPawn.data.damageMultipliers[DamageType.DAMAGE_EXPLOSIVE] = 1;
            }
            if (curPawn.data.perks)
            {
                curPawn.data.perks = [];
            }
            this.requestEvent({
                eventId: GameServer.EVENT_PAWN_DAMAGE,
                damageType: DamageType.DAMAGE_EXPLOSIVE,
                damageAmount: Math.max(damage, 500),
                pawnId: _id,
                attackerId: _id,
                causerId: null,
                weaponId: "generic",
                bDirectlyCausedByPlayer: false
            });
        }
    }

    onPlayerUseKillstreak(_playerId, _worldX, _worldY)
    {
        var ps = this.getPlayerStateById(_playerId);
        if (ps)
        {
            var char = this.getObjectById(_playerId);
            var killstreaks = ps["killstreaks"];
            if (char && killstreaks && killstreaks.length > 0)
            {
                var killstreakId = killstreaks[ps["currentKillstreakIndex"]];
                var bCanUse = !char.data.bIsOnLadder && !this.characterHasWeaponDelay(char);
                if (bCanUse)
                {
                    var placeable = [
                        Killstreaks.KILLSTREAK_REMOTE_TURRET,
                        Killstreaks.KILLSTREAK_ADVANCED_TURRET,
                        Killstreaks.KILLSTREAK_JUGGERNAUT_USE,
                        Killstreaks.KILLSTREAK_JUGGERNAUT_RECON_USE
                    ];
                    if (killstreakId.indexOf("place") >= 0 || placeable.indexOf(killstreakId) >= 0)
                    {
                        this.triggerPlayerCurrentKillstreak(_playerId, _worldX, _worldY);
                    }
                    else
                    {
                        this.cancelCharacterReload(char);
                        this.cancelCharacterBoltPull(char);
                        this.stopCharacterInteract(char);
                        char.data.weapon["bUseDelay"] = true;
                        char.data.weapon["useDelayTimer"] = Math.round(this.localData.settings.fps * 0.3);
                        char.data.weapon["useData"] = {
                            type: "killstreak",
                            position: [_worldX, _worldY]
                        };
                        this.requestEvent({
                            eventId: GameServer.EVENT_PAWN_ACTION,
                            pawnId: char.data["id"],
                            type: GameServer.PAWN_OPEN_LAPTOP
                        });
                    }
                }
            }
        }
    }

    purchaseStoreItem(_playerId, _data)
    {
        var ps = this.getPlayerStateById(_playerId);
        var pawn = this.getObjectById(_playerId);
        if (ps && pawn)
        {
            if (_data)
            {
                var cost = 0;
                switch (_data["type"])
                {
                    case "ammo":
                        if (_data["index"] === 2)
                        {
                            var weaponData = pawn.data.equipment;
                        }
                        else
                        {
                            weaponData = pawn.data.inventory[_data["index"]];
                        }
                        if (weaponData)
                        {
                            var ammoStoreInfo = this.getAmmoStoreInfo(weaponData["id"]);
                        }
                        if (ammoStoreInfo)
                        {
                            cost = ammoStoreInfo.cost ? ammoStoreInfo.cost : 0;
                            if (ps["money"] >= cost)
                            {
                                if (_data["index"] == 2)
                                {
                                    this.requestEvent({
                                        eventId: GameServer.EVENT_PLAYER_UPDATE_INVENTORY,
                                        pawnId: _playerId,
                                        type: GameServer.INV_EQUIPMENT_ADD,
                                        value: ammoStoreInfo.ammo
                                    });
                                }
                                else
                                {
                                    this.requestEvent({
                                        eventId: GameServer.EVENT_PLAYER_UPDATE_INVENTORY,
                                        pawnId: _playerId,
                                        index: _data["index"],
                                        type: GameServer.INV_AMMO_ADD,
                                        value: ammoStoreInfo.ammo,
                                        barrelAmmo: 1
                                    });
                                }
                            }
                        }
                        break;

                    case "item":
                        var weaponData = this.getWeaponData(_data["itemId"]);
                        if (weaponData)
                        {
                            cost = weaponData["cost"] ? weaponData["cost"] : 0;
                            if (ps["money"] >= cost)
                            {
                                if (_data["index"] == 2)
                                {
                                    this.requestEvent({
                                        eventId: GameServer.EVENT_PLAYER_UPDATE_INVENTORY,
                                        pawnId: _playerId,
                                        type: GameServer.INV_EQUIPMENT_SET,
                                        value: weaponData["id"]
                                    });
                                }
                                else if (pawn.data.inventory.length < 2)
                                {
                                    this.requestEvent({
                                        eventId: GameServer.EVENT_PLAYER_UPDATE_INVENTORY,
                                        pawnId: _playerId,
                                        type: GameServer.INV_ITEM_ADD,
                                        item: weaponData
                                    });
                                }
                                else
                                {
                                    var otherIndex = _data["index"] == 0 ? 1 : 0;
                                    var otherItem = pawn.data.inventory[otherIndex];
                                    if (otherItem["type"] == Weapon.TYPE_MELEE)
                                    {
                                        //_data["index"] = otherIndex;
                                    }
                                    this.requestEvent({
                                        eventId: GameServer.EVENT_PLAYER_UPDATE_INVENTORY,
                                        pawnId: _playerId,
                                        index: _data["index"],
                                        item: weaponData,
                                        type: GameServer.INV_ITEM_REPLACE
                                    });
                                }
                            }
                        }
                        break;

                    case "perk":
                        var perkData = this.getPerkData(_data["perkId"]);
                        if (perkData)
                        {
                            cost = perkData["cost"] ? perkData["cost"] : 0;
                            if (ps["money"] >= cost)
                            {
                                this.requestEvent({
                                    eventId: GameServer.EVENT_PLAYER_UPDATE_INVENTORY,
                                    pawnId: _playerId,
                                    type: GameServer.INV_PERK_ADD,
                                    perkId: perkData["id"]
                                });
                            }
                        }
                        break;

                    case "killstreak":
                        var killstreakData = this.getKillstreakData(_data["killstreakId"]);
                        if (killstreakData)
                        {
                            cost = killstreakData["moneyCost"] ? killstreakData["moneyCost"] : 0;
                            if (ps["money"] >= cost)
                            {
                                this.requestEvent({
                                    eventId: GameServer.EVENT_PLAYER_EARN_KILLSTREAK,
                                    playerId: _playerId,
                                    killstreakId: _data["killstreakId"],
                                    bAcquired: true
                                });
                            }
                        }
                        break;

                    case "mod":
                        var modData = this.getModData(_data["modId"]);
                        cost = modData ? modData["moneyCost"] : 0;
                        if (ps["money"] >= cost)
                        {
                            var char = this.getObjectById(_playerId);
                            if (char)
                            {
                                var curItem = char.data.inventory[_data.index];
                                if (curItem)
                                {
                                    if (curItem.type != Weapon.TYPE_LAUNCHER)
                                    {
                                        if (_data.modId == Mods.AMMO_LAUNCHER_RADIUS || _data.modId == Mods.AMMO_NAPALM || _data.modId == Mods.AMMO_LAUNCHER_EXPLOSIVE)
                                        {
                                            console.warn("Invalid mod purchase", curItem.id, _data.modId);
                                            cost = 0;
                                            break;
                                        }
                                    }
                                    this.requestEvent({
                                        eventId: GameServer.EVENT_PLAYER_UPDATE_INVENTORY,
                                        pawnId: _playerId,
                                        type: GameServer.INV_MOD_SET,
                                        index: _data["index"],
                                        modId: _data["modId"],
                                        modType: _data["modType"]
                                    });
                                }
                            }
                        }
                        break;
                }                
                this.requestEvent({
                    eventId: GameServer.EVENT_GAME_MONEY_ADD,
                    playerId: _playerId,
                    value: -cost
                });
            }
            else
            {
                console.warn("Invalid data");
            }
        }
    }

    getAmmoStoreInfo(_weaponId)
    {
        var weaponData = this.getWeaponData(_weaponId);
        if (weaponData)
        {
            if (weaponData["bEquipment"])
            {
                var cost = weaponData["cost"];
            }
            else
            {
                cost = this.getAmmoRoundCost(weaponData["round"]);
            }
            if (cost > 0)
            {
                var ammoSize = weaponData["bEquipment"] ? 1 : weaponData["magSize"];
                return {
                    cost: this.RoundToNearest(cost * ammoSize),
                    ammo: ammoSize
                }
            }
        }
        return null;
    }

    getAmmoRoundCost(_round)
    {
        var costs = this.getSharedData("ammoCost");
        if (costs)
        {
            if (costs[_round] != undefined)
            {
                return costs[_round];
            }
            else
            {
                return 0;
            }
        }
        return 0;
    }

    addAnnouncerMessage(_id, _team)
    {
        this.onEvent({
            eventId: GameServer.EVENT_ANNOUNCER_MESSAGE,
            id: _id,
            team: _team
        });
    }

    getBattlezonePatrolPoints()
    {
        var map = this.getCurrentMapData();
        var arr = map.campSpots ? this.clone(map.campSpots) : [];
        arr = arr.concat(this.getAllPlayerPositions());
        this.shuffleArray(arr);
        return arr;
    }

    getAllPlayerPositions()
    {
        var arr = []
        for (var i = 0; i < this.localData.playerStates.length; i++)
        {
            var char = this.getObjectById(this.localData.playerStates[i].id);
            if (char && char.data.health > 0)
            {
                arr.push([char.position[0], char.position[1]]);
            }
        }
        return arr;
    }

    onGameTimer()
    {
        if (!this.localData)
        {
            return;
        }
        var localData = this.localData;
        if (!localData["bPaused"] && !localData["preGameTimer"])
        {

            var gameModeData = localData.gameModeData;
            switch (gameModeData["id"])
            {
                case GameMode.BATTLEZONE:
                    localData["gameTimer"]--;
                    if (localData["gameTimer"] > 0)
                    {
                        var map = this.getCurrentMapData();
                        var bEnemyThreshold = localData["gameTimer"] % (localData["gameTimer"] <= 300 ? 10 : 30) == 0;
                        if (bEnemyThreshold)
                        {
                            var patrolPoints = this.getBattlezonePatrolPoints();
                            var numEnemies = 5; //this.Random(3, 5);
                            var randomEnemies = {};
                            randomEnemies[SurvivalEnemyType.ZOMBIE_DEFAULT] = 5;
                            randomEnemies[SurvivalEnemyType.ZOMBIE_MELEE] = 2;
                            randomEnemies[SurvivalEnemyType.ZOMBIE_SPRINTER_MELEE] = 2;
                            randomEnemies[SurvivalEnemyType.ZOMBIE_FAT] = 2;
                            randomEnemies[SurvivalEnemyType.ZOMBIE_SPRINTER] = 2;
                            randomEnemies[SurvivalEnemyType.ZOMBIE_SPITTER] = 1;
                            randomEnemies[SurvivalEnemyType.ZOMBIE_EXPLODER] = 1;
                            randomEnemies[SurvivalEnemyType.INFESTOR] = 1;
                            if (localData["gameTimer"] <= 300)
                            {
                                randomEnemies[SurvivalEnemyType.ZOMBIE_SPRINTER_BOSS] = 2;
                                randomEnemies[SurvivalEnemyType.ZOMBIE_SPRINTER_MELEE] = 2;
                                randomEnemies[SurvivalEnemyType.ZOMBIE_EXPLODER_BOSS] = 2;
                                randomEnemies[SurvivalEnemyType.ZOMBIE_SPITTER_BOSS] = 1;
                            }
                            if (this.Random(1, 50) == 1)
                            {
                                randomEnemies[SurvivalEnemyType.INFESTOR_KING] = 1;
                            }                            
                            if (this.getNumCharactersOnTeam(Battlezone.TEAM_ENEMIES) >= 8)
                            {
                                numEnemies = 1;
                            }
                            for (var i = 0; i < numEnemies; i++)
                            {
                                this.createSandboxUnit({
                                    type: "unit",
                                    unitId: this.getRandomProperty(randomEnemies),
                                    team: Battlezone.TEAM_ENEMIES,
                                    pos: map.spawns_survival[this.Random(0, map.spawns_survival.length - 1)],
                                    bLOS: false
                                });
                            }
                        }
                        if (localData["gameTimer"] % 180 == 0)
                        {
                            if (this.getNumHelicoptersOnTeam(Battlezone.TEAM_MERCENARIES) < Battlezone.MAX_HELIS)
                            {
                                this.requestEvent({
                                    eventId: GameServer.EVENT_MESSAGE_ADD,
                                    data: {
                                        hqSound: "hq_enemy_chopper"
                                    }
                                });
                                var mercHelis = [
                                    SurvivalEnemyType.HELI_MH6,
                                    SurvivalEnemyType.HELI_COBRA,
                                    SurvivalEnemyType.HELI_SCOUT,
                                    SurvivalEnemyType.HELI_SNIPER,
                                    SurvivalEnemyType.HELI_CHOPPER_GUNNER,
                                    SurvivalEnemyType.HELI_PAVE_LOW
                                ];
                                this.createSandboxUnit({
                                    type: "unit",
                                    unitId: mercHelis[this.Random(0, mercHelis.length - 1)],
                                    team: Battlezone.TEAM_MERCENARIES,
                                    pos: [this.RandomBoolean() ? 0 : map.width, 0],
                                    avatarData: {
                                        body: Character.BODY_RUS_STANDARD,
                                        head: Character.HEAD_RUS_BERET,
                                        facewear: Character.FACEWEAR_BALACLAVA
                                    }
                                });
                            }
                        }
                        var bSpawnMercs = localData["gameTimer"] % 60 == 0 && localData["gameTimer"] > 60;
                        if (bSpawnMercs)
                        {
                            this.requestEvent({
                                eventId: GameServer.EVENT_MESSAGE_ADD,
                                data: {
                                    message: "STR_MERCS_INBOUND",
                                    hqSound: "hq_enemy_generic_" + this.Random(1, 4)
                                }
                            });
                            var patrolPoints = this.getBattlezonePatrolPoints();
                            var mercRand = this.Random(1, 8);
                            switch (mercRand)
                            {
                                default:
                                    var mercs = [
                                        SurvivalEnemyType.RUS_BASIC,
                                        SurvivalEnemyType.RUS_HARD,
                                        SurvivalEnemyType.RUS_CLAYMORE,
                                        SurvivalEnemyType.RUS_EXPERT,
                                        SurvivalEnemyType.RUS_SNIPER,
                                        SurvivalEnemyType.RUS_MERC,
                                        SurvivalEnemyType.RUS_CROSSBOW,
                                        SurvivalEnemyType.RUS_RPG,
                                        SurvivalEnemyType.RUS_SHIELD,
                                        SurvivalEnemyType.RUS_MELEE
                                    ];
                                    break;
                            }
                            var items = [];
                            items.push({
                                type: "unit",
                                unitId: SurvivalEnemyType.RUS_CLAYMORE,
                                patrolPoints: patrolPoints
                            });
                            if (localData["gameTimer"] <= 300)
                            {
                                this.createSandboxUnit({
                                    type: "unit",
                                    unitId: SurvivalEnemyType.HELI_DRAGONFIRE,
                                    team: Battlezone.TEAM_MERCENARIES,
                                    pos: [this.RandomBoolean() ? 0 : map.width, 0]
                                });
                            }
                            var bMercLOS = localData["gameTimer"] >= 180;
                            var numMercs = this.Random(2, 3);
                            if (this.getNumCharactersOnTeam(Battlezone.TEAM_MERCENARIES) >= Battlezone.MAX_MERCS)
                            {
                                numMercs = 0;
                            }
                            for (var i = 0; i < numMercs; i++)
                            {
                                items.push({
                                    type: "unit",
                                    unitId: mercs[this.Random(0, mercs.length - 1)],
                                    patrolPoints: bMercLOS ? patrolPoints : null,
                                    bLOS: bMercLOS
                                })
                            }
                            items.push({
                                type: "unit",
                                unitId: this.RandomBoolean() ? SurvivalEnemyType.TURRET_SENTRY : SurvivalEnemyType.TURRET_SAM,
                                patrolPoints: patrolPoints
                            });
                            var mercDest = [this.Random(500, map.width - 500), this.Random(800, 1000)];
                            var osprey = this.createHelicopter([mercDest[0] > (map.width * 0.5) ? map.width : 0, 0], Battlezone.TEAM_MERCENARIES, {
                                type: Helicopter.TYPE_OSPREY,
                                playerId: null,
                                destination: mercDest,
                                items: items,
                                scale: 1
                            });
                            osprey.data.dropTimerMax = Math.round(this.localData.settings.fps * 0.5);
                        }
                        if (localData["gameTimer"] == 60)
                        {
                            this.requestEvent({
                                eventId: GameServer.EVENT_MESSAGE_ADD,
                                data: {
                                    message: "STR_JUGGERNAUTS_INBOUND",
                                    hqSound: "hq_enemy_juggernauts"
                                }
                            });
                            var osprey = this.createHelicopter([0, 0], Battlezone.TEAM_MERCENARIES, {
                                type: Helicopter.TYPE_OSPREY,
                                playerId: null,
                                destination: [map.width * 0.2, this.Random(500, 1000)],
                                items: [
                                    {
                                        type: "unit",
                                        unitId: SurvivalEnemyType.ZOMBIE_JUGGERNAUT_MERC,
                                        bLOS: false
                                    },
                                    {
                                        type: "unit",
                                        unitId: SurvivalEnemyType.JUGGERNAUT_MERC,
                                        bLOS: false
                                    }                                    
                                ],
                                scale: 1
                            });
                            osprey.data.dropTimerMax = Math.round(this.localData.settings.fps * 0.5);

                            var osprey = this.createHelicopter([map.width, 0], Battlezone.TEAM_MERCENARIES, {
                                type: Helicopter.TYPE_OSPREY,
                                playerId: null,
                                destination: [map.width * 0.8, this.Random(500, 1000)],
                                items: [
                                    {
                                        type: "unit",
                                        unitId: SurvivalEnemyType.JUGGERNAUT_MERC,
                                        bLOS: false
                                    },
                                    {
                                        type: "unit",
                                        unitId: SurvivalEnemyType.ZOMBIE_JUGGERNAUT_MERC,
                                        bLOS: false
                                    }
                                ],
                                scale: 1
                            });
                            osprey.data.dropTimerMax = Math.round(this.localData.settings.fps * 0.5);
                        }
                        if (localData["gameTimer"] % 30 == 0)
                        {
                            var numAirdrops = this.Random(1, 3);
                            for (var i = 0; i < numAirdrops; i++)
                            {
                                var heliDest = [this.Random(500, map.width - 500), this.Random(800, 1000)];
                                var heliPos = [heliDest[0] < (map.width * 0.5) ? 0 : map.width, this.Random(0, 500)];
                                if (this.Random(1, 5) == 1)
                                {
                                    this.createHelicopter(heliPos, Battlezone.TEAM_AIRDROPS, {
                                        type: Helicopter.TYPE_MH6,
                                        playerId: null,
                                        destination: heliDest,
                                        items: [
                                            {
                                                type: "crate",
                                                crateType: Crate.CRATE_SHARD,
                                                shards: 1
                                            }
                                        ],
                                        scale: 1
                                    });
                                }
                                else
                                {
                                    var random = this.Random(1, 8);
                                    switch (random)
                                    {
                                        case 1:
                                        case 2:
                                            var bzPerks = [
                                                Perks.PERK_PLAYER_LIGHTWEIGHT,
                                                Perks.PERK_PLAYER_SITREP,
                                                Perks.PERK_PLAYER_JUGGERNAUT,
                                                Perks.PERK_PLAYER_ANTI_SNIPER,
                                                Perks.PERK_PLAYER_HELMET,
                                                Perks.PERK_PLAYER_COLD_BLOODED,
                                                Perks.PERK_PLAYER_SPECIALIST,
                                                Perks.PERK_PLAYER_NINJA,
                                                Perks.PERK_WEAPON_ACCURACY,
                                                Perks.PERK_WEAPON_SHRAPNEL,
                                                Perks.PERK_WEAPON_QUICKDRAW,
                                                Perks.PERK_WEAPON_AGGRESSION,
                                                Perks.PERK_WEAPON_RELOAD,
                                                Perks.PERK_WEAPON_VAMPIRE,
                                                Perks.PERK_WEAPON_STOPPING_POWER
                                            ];
                                            this.createHelicopter(heliPos, Battlezone.TEAM_AIRDROPS, {
                                                type: Helicopter.TYPE_MH6,
                                                playerId: null,
                                                destination: heliDest,
                                                items: [
                                                    {
                                                        type: "crate",
                                                        crateType: Crate.CRATE_PERK,
                                                        perkId: bzPerks[this.Random(0, bzPerks.length - 1)]
                                                    }
                                                ],
                                                scale: 1
                                            });
                                            break;

                                        case 3:
                                            var items = [];
                                            var numWeapons = this.Random(1, 3);
                                            for (var i = 0; i < numWeapons; i++)
                                            {
                                                var randomWeapon = this.getRandomWeapon(true);
                                                var weaponMods = this.getRandomMods(randomWeapon);
                                                this.applyWeaponMods(randomWeapon, weaponMods);
                                                if (randomWeapon["ammo"] != null && randomWeapon["magSize"] != null)
                                                {
                                                    //randomWeapon["ammo"] = this.Random(0, randomWeapon["magSize"]);
                                                }
                                                items.push(randomWeapon);
                                            }
                                            this.createHelicopter(heliPos, Battlezone.TEAM_AIRDROPS, {
                                                type: Helicopter.TYPE_MH6,
                                                playerId: null,
                                                destination: heliDest,
                                                items: [
                                                    {
                                                        type: "crate",
                                                        crateType: Crate.CRATE_WEAPON,
                                                        items: items
                                                    }
                                                ],
                                                scale: 1
                                            });
                                            break;
                                            break;

                                        case 4:
                                            var killstreaks = [
                                                Killstreaks.KILLSTREAK_AIRSTRIKE,
                                                Killstreaks.KILLSTREAK_NAPALM,
                                                Killstreaks.KILLSTREAK_STEALTH_BOMBER,
                                                Killstreaks.KILLSTREAK_SAM_TURRET_PLACE,
                                                Killstreaks.KILLSTREAK_SENTRY_GUN_PLACE,
                                                Killstreaks.KILLSTREAK_REMOTE_TURRET,
                                                Killstreaks.KILLSTREAK_ADVANCED_TURRET,
                                                Killstreaks.KILLSTREAK_GRENADE_TURRET,
                                                Killstreaks.KILLSTREAK_EMP
                                            ];
                                            this.createHelicopter(heliPos, Battlezone.TEAM_AIRDROPS, {
                                                type: Helicopter.TYPE_MH6,
                                                playerId: null,
                                                destination: heliDest,
                                                items: [
                                                    {
                                                        type: "crate",
                                                        crateType: Crate.CRATE_KILLSTREAK,
                                                        killstreakId: killstreaks[this.Random(0, killstreaks.length - 1)]
                                                    }
                                                ],
                                                scale: 1
                                            });
                                            break;

                                        case 5:
                                            this.createHelicopter(heliPos, Battlezone.TEAM_AIRDROPS, {
                                                type: Helicopter.TYPE_MH6,
                                                playerId: null,
                                                destination: heliDest,
                                                items: [
                                                    {
                                                        type: "crate",
                                                        crateType: Crate.CRATE_XP,
                                                        xp: this.RoundToNearest(this.Random(5000, 25000))
                                                    }
                                                ],
                                                scale: 1
                                            });
                                            break;

                                        case 6:
                                            this.createHelicopter(heliPos, Battlezone.TEAM_AIRDROPS, {
                                                type: Helicopter.TYPE_MH6,
                                                playerId: null,
                                                destination: heliDest,
                                                items: [
                                                    {
                                                        type: "crate",
                                                        crateType: Crate.CRATE_LIFE,
                                                        lives: 1
                                                    }
                                                ],
                                                scale: 1
                                            });
                                            break;

                                        default:
                                            this.createHelicopter(heliPos, Battlezone.TEAM_AIRDROPS, {
                                                type: Helicopter.TYPE_MH6,
                                                playerId: null,
                                                destination: heliDest,
                                                items: [
                                                    {
                                                        type: "crate",
                                                        crateType: Crate.CRATE_AMMO
                                                    }
                                                ],
                                                scale: 1
                                            });
                                            break;
                                    }
                                }
                            }
                        }
                    }
                    break;

                case GameMode.DEMOLITION:
                    if (gameModeData["bBombPlanted"])
                    {
                        var bTimerPaused = true;
                        if (gameModeData["bombTimer"] > 0)
                        {
                            gameModeData["bombTimer"]--;
                        }
                        else if (gameModeData["bombTimer"] == 0)
                        {
                            gameModeData["bombTimer"] = -1;
                            var bomb = this.getBombCrate();
                            if (bomb)
                            {
                                this.createExplosion({
                                    eventId: GameServer.EVENT_SPAWN_EXPLOSION,
                                    x: bomb.position[0],
                                    y: bomb.position[1],
                                    radius: 500,
                                    damage: 1000,
                                    causerId: bomb.data["id"],
                                    playerId: bomb.data["planterId"],
                                    weaponId: "bomb" //Killstreaks.KILLSTREAK_DECOY
                                });
                                this.removeNextStep(bomb);
                            }
                            this.winRound(MatchState.END_CONDITION_BOMB, gameModeData["bombTeam"], 1, {
                                id: bomb.data["planterId"]
                            });                            
                            /*
                            this.requestEvent({
                                eventId: GameServer.EVENT_GAME_END,
                                condition: MatchState.END_CONDITION_BOMB,
                                winningTeam: gameModeData["bombTeam"]
                            });
                            */
                        }
                        this.onEvent({
                            eventId: GameServer.EVENT_GAME_UPDATE,
                            gameModeData: {
                                bombTimer: gameModeData["bombTimer"]
                            }
                        });
                    }
                    else
                    {
                        localData["gameTimer"]--;
                    }
                    break;

                default:
                    localData["gameTimer"]--;
                    break;
            }

            this.onEvent({
                eventId: GameServer.EVENT_GAME_TIMER,
                timer: localData["gameTimer"],
                bTimerPaused: bTimerPaused
            });
            if (localData["gameTimer"] < 0)
            {
                var timer = localData["timer_game"];
                clearInterval(timer);
                delete localData["timer_game"];
                if (localData.gameModeData["round"] != null)
                {
                    switch (localData.gameModeData["id"])
                    {
                        case GameMode.HEADQUARTERS:
                            this.winRound(MatchState.END_CONDITION_TIME, null);
                            break;

                        case GameMode.ASSASSINATION:
                            this.winRound(MatchState.END_CONDITION_TIME, gameModeData["vipTeam"] == 0 ? 0 : 1, 1); 
                            break;

                        case GameMode.RESCUE:
                            this.winRound(MatchState.END_CONDITION_TIME, gameModeData["rescueTeam"] == 0 ? 1 : 0, 1);
                            break;

                        case GameMode.DEMOLITION:
                            this.winRound(MatchState.END_CONDITION_TIME, gameModeData["bombTeam"] == 0 ? 1 : 0, 1);  
                            break;
                    }                    
                }
                else
                {
                    var endObj = {
                        eventId: GameServer.EVENT_GAME_END,
                        condition: MatchState.END_CONDITION_TIME
                    };
                    switch (localData.gameModeData["id"])
                    {
                        case GameMode.INFECTED:
                        case GameMode.DEMOLITION:
                            endObj["winningTeam"] = 0;
                            break;

                        case GameMode.BATTLEZONE:
                            var players = this.getPlayerStates();
                            players.sort(function (a, b)
                            {                                
                                if (a.shards < b.shards) return 1;
                                if (a.shards > b.shards) return -1;
                                if (a.xp < b.xp) return 1;
                                if (a.xp > b.xp) return -1;
                                if (a.kills < b.kills) return 1;
                                if (a.kills > b.kills) return -1;
                                if (a.lives < b.lives) return 1;
                                if (a.lives > b.lives) return -1;
                                return 0;
                            });
                            if (players.length > 0)
                            {
                                var player = players[0];
                                if (player.lives > 0)
                                {
                                    endObj["winningTeam"] = players[0]["team"];
                                }
                            }
                            break;

                        case GameMode.GUN_GAME:
                            var players = this.getPlayerStates();
                            players.sort(function (a, b)
                            {
                                if (a.gunIndex < b.gunIndex) return 1;
                                if (a.gunIndex > b.gunIndex) return -1;
                                if (a.gunKills < b.gunKills) return 1;
                                if (a.gunKills > b.gunKills) return -1;
                                if (a.kills < b.kills) return 1;
                                if (a.kills > b.kills) return -1;
                                return 0;
                            });
                            if (players.length > 0)
                            {
                                if (players.length > 1 && players[1]["kills"] === players[0]["kills"])
                                {
                                    endObj["winningTeam"] = -1; //Draw
                                }
                                else
                                {
                                    endObj["winningTeam"] = players[0]["team"];
                                }
                            }
                            break;

                        case GameMode.DEATHMATCH:
                            var players = this.getPlayerStates();
                            players.sort(function (a, b)
                            {
                                if (a.kills < b.kills) return 1;
                                if (a.kills > b.kills) return -1;
                                return 0;
                            });
                            if (players.length > 0)
                            {
                                if (players.length > 1 && players[1]["kills"] === players[0]["kills"])
                                {
                                    endObj["winningTeam"] = -1; //Draw
                                }
                                else
                                {
                                    endObj["winningTeam"] = players[0]["team"];
                                }
                            }
                            break;

                        default:
                            var scores = localData.gameModeData["scores"];
                            if (scores)
                            {
                                if (scores[0] > scores[1])
                                {
                                    endObj["winningTeam"] = 0;
                                }
                                else if (scores[1] > scores[0])
                                {
                                    endObj["winningTeam"] = 1;
                                }
                                else
                                {
                                    //Draw
                                    endObj["winningTeam"] = -1;
                                }
                            }
                            break;
                    }
                    this.requestEvent(endObj);
                }
            }
        }
    }

    addScore(_team, _val)
    {
        if (_team == null || _team == -1)
        {
            return;
        }
        var gameModeData = this.localData.gameModeData;
        gameModeData.scores[_team] = Math.min(gameModeData.scoreLimit, gameModeData.scores[_team] + _val);
    }

    winRound(_condition, _winningTeam, _score, _playerSpotlight)
    {
        if (this.localData["timer_game"])
        {
            clearInterval(this.localData["timer_game"]);
            delete this.localData["timer_game"];
        }
        var gameModeData = this.localData.gameModeData;
        if (_winningTeam != null && _winningTeam != -1)
        {
            if (_score != 0)
            {
                this.addScore(_winningTeam, _score);
            }
            var newScore = gameModeData.scores[_winningTeam];
        }
        var scores = gameModeData.scores;
        if (gameModeData["bUseRoundThreshold"])
        {
            var roundWinThreshold = Math.ceil(gameModeData["numRounds"] * 0.5);
            var scoreWinThreshold = Math.ceil(gameModeData["scoreLimit"] * 0.5);
        }
        if (scores[0] >= gameModeData["scoreLimit"] || scores[1] >= gameModeData["scoreLimit"])
        {
            this.requestEvent({
                eventId: GameServer.EVENT_GAME_END,
                condition: MatchState.END_CONDITION_SCORE,
                winningTeam: scores[0] > scores[1] ? 0 : 1,
                gameModeData: {
                    scores: gameModeData.scores
                }
            });
        }
        else if (gameModeData["bUseRoundThreshold"] && ((scores[0] >= scoreWinThreshold && scores[1] < scores[0]) || (scores[1] >= scoreWinThreshold && scores[0] < scores[1])))
        {
            this.requestEvent({
                eventId: GameServer.EVENT_GAME_END,
                condition: MatchState.END_CONDITION_SCORE,
                winningTeam: scores[0] > scores[1] ? 0 : 1,
                gameModeData: {
                    scores: gameModeData.scores
                }
            });
        }
            /*
        else if (gameModeData["bUseRoundThreshold"] && ((gameModeData["round"] + 1) >= roundWinThreshold && (gameModeData["numRounds"] - gameModeData["round"]) < roundWinThreshold))
        {
            this.log("Round threshold reached");
            var winner = -1;
            if (gameModeData.scores[0] > gameModeData.scores[1])
            {
                winner = 0;
            }
            else if (gameModeData.scores[0] < gameModeData.scores[1])
            {
                winner = 1;
            }
            this.requestEvent({
                eventId: GameServer.EVENT_GAME_END,
                condition: MatchState.END_CONDITION_SCORE,
                winningTeam: winner,
                gameModeData: {
                    scores: gameModeData.scores
                }
            });
        }
        */
        else if (gameModeData["round"] + 1 >= gameModeData["numRounds"])
        {
            var winner = -1;
            if (gameModeData.scores[0] > gameModeData.scores[1])
            {
                winner = 0;
            }
            else if (gameModeData.scores[0] < gameModeData.scores[1])
            {
                winner = 1;
            }
            this.requestEvent({
                eventId: GameServer.EVENT_GAME_END,
                condition: MatchState.END_CONDITION_SCORE,
                winningTeam: winner,
                gameModeData: {
                    scores: gameModeData.scores
                }
            });
        }
        else
        {
            this.requestEvent({
                eventId: GameServer.EVENT_ROUND_END,
                condition: _condition,
                winningTeam: _winningTeam,
                playerSpotlight: _playerSpotlight,
                gameModeData: {
                    scores: gameModeData.scores
                }
            });
            setTimeout(this.prepareRound.bind(this), 3000);            
            gameModeData["round"]++;
            gameModeData["bAllowRespawns"] = false;

            for (var i = 0; i < this.localData.playerStates.length; i++)
            {
                var ps = this.localData.playerStates[i];
                if (ps)
                {
                    ps["bCanRespawn"] = false;
                    ps["bWaitingToRespawn"] = false;
                    if (ps.desiredClassData["killstreak"] == Killstreaks.TYPE_PERKS)
                    {
                        ps["currentKillstreak"] = 0;
                    }
                }
            }
        }
    }

    prepareRound()
    {
        if (this.matchHasEnded())
        {
            return;
        }
        var streaks = this.localData["killstreaks"];
        for (var i = 0; i < streaks.length; i++)
        {
            var ks = streaks[i];
            ks["timer"] = 0;
        }
        var objects = this.getPawns().concat(this.getAllCrates()).concat(this.getDroppedWeapons()).concat(this.getEquipment()).concat(this.getGrenades()).concat(this.getScavengerPacks());
        objects = objects.concat(this.getObstaclesWithHealth());
        //objects.concat(this.getDoors())
        for (var i = 0; i < objects.length; i++)
        {
            this.removeObject(objects[i]);
        }
        var map = this.getCurrentMapData();
        switch (this.localData.gameModeData["id"])
        {
            case GameMode.HEADQUARTERS:
                var flag = this.getAllDominationFlags()[0];
                if (flag)
                {
                    this.resetFlag(flag);
                }
                var hq = map.flags_headquarters;
                if (hq)
                {
                    flag.position = hq[this.Random(0, hq.length - 1)];
                }
                break;

            case GameMode.DEMOLITION:
                this.localData.gameModeData["bBombPlanted"] = false;
                break;

            case GameMode.RESCUE:
                this.localData.gameModeData["numHostages"] = 2;
                break;
        }
        setTimeout(this.startRound.bind(this), 5000);
    }

    startRound()
    {
        if (!this.localData)
        {
            return;
        }
        var localData = this.localData;
        var gameModeData = localData.gameModeData;
        gameModeData["bAllowRespawns"] = true;
        gameModeData["bFirstBlood"] = false;
        gameModeData["firstBloodPlayerId"] = null;

        if (localData.gameModeData["timeLimit"])
        {
            localData["gameTimer"] = localData.gameModeData["timeLimit"];
            var timer_game = setInterval(this.onGameTimer.bind(this), 1000);
            localData["timer_game"] = timer_game;
        }

        var map = this.getCurrentMapData();
        var objects = map.objects;
        if (objects)
        {
            for (var i = 0; i < objects.length; i++)
            {
                var curObject = objects[i];
                switch (curObject.type)
                {
                    case "obstacle":
                        if (curObject.obstacleId == "barrel_explosive")
                        {
                            this.createObstacle(curObject);
                        }
                        break;

                    case "door":
                        //this.createDoor(curObject);
                        break;
                }
            }
        }

        var doors = this.getDoors();
        for (var i = 0; i < doors.length; i ++)
        {
            var door = doors[i];
            this.setDoorClosed(door, true, null, false, true);
        }

        switch (gameModeData["id"])
        {
            case GameMode.HEADQUARTERS:
                gameModeData["hqTeam"] = null;                
                break;

            case GameMode.DEMOLITION:
                gameModeData["bombTimer"] = null;
                gameModeData["bombTeam"] = gameModeData["bombTeam"] == 0 ? 1 : 0;
                gameModeData["bBombPlanted"] = false;
                if (!this.getBombCrate())
                {
                    this.createBombCrate(gameModeData["bombTeam"]);
                }
                break;

            case GameMode.ASSASSINATION:
                gameModeData["vipTeam"] = gameModeData["vipTeam"] == 0 ? 1 : 0;
                break;

            case GameMode.RESCUE:
                gameModeData["rescueTeam"] = gameModeData["rescueTeam"] == 0 ? 1 : 0;
                gameModeData["numHostages"] = 2;
                break;
        } 

        //Start pre-game timer
        localData["matchState"] = MatchState.STATE_PRE_GAME;
        localData["preGameTimer"] = 10;
        var timer_preGame = setInterval(this.onPreGameTimer.bind(this), 1000);
        localData["timer_preGame"] = timer_preGame;
        this.onEvent({
            eventId: GameServer.EVENT_GAME_UPDATE,
            gameModeData: localData["gameModeData"]
        });
        this.onEvent({
            eventId: GameServer.EVENT_GAME_PRE_TIMER,
            timer: localData["preGameTimer"]
        });

        //Start round
        this.requestEvent({
            eventId: GameServer.EVENT_ROUND_START,
            round: gameModeData["round"]
        });

        //Respawn players
        var players = this.localData.playerStates;
        for (var i = 0; i < players.length; i++)
        {
            this.requestEvent({
                eventId: GameServer.EVENT_PLAYER_RESPAWN,
                playerId: players[i]["id"]
            });
        }

        this.onRoundStart();
    }

    addPlayerScore(_playerId, _val)
    {
        var ps = this.getPlayerStateById(_playerId);
        if (ps)
        {
            ps.score += _val;
            this.onEvent({
                eventId: GameServer.EVENT_PLAYER_UPDATE,
                playerId: ps.id,
                data: {
                    score: ps.score
                }
            });
        }
    }

    rescueHostage(_pawn, _playerId)
    {
        var ps = this.getPlayerStateById(_playerId);
        if (ps)
        {
            ps.score++;
            this.onEvent({
                eventId: GameServer.EVENT_PLAYER_UPDATE,
                playerId: ps.id,
                data: {
                    score: ps.score
                }
            });
        }
        var obj = {
            bHostageRescued: 1,
            playerId: _playerId
        };
        switch (this.localData.gameModeData.id)
        {
            case GameMode.OP_HOSTAGE:
                this.localData.gameModeData.numHostages--;
                var num = Math.min(this.localData.gameModeData.numHostages, this.getNumHostages() - 1);
                if (num <= 0)
                {
                    this.requestEvent({
                        eventId: GameServer.EVENT_GAME_END,
                        condition: MatchState.END_CONDITION_HOSTAGES_RESCUED,
                        winningTeam: 0
                    });
                }
                else
                {
                    obj.numHostages = num;
                }
                break;

            case GameMode.RESCUE:   
                this.localData.gameModeData.numHostages--;
                var num = Math.min(this.localData.gameModeData.numHostages, this.getNumHostages() - 1);
                if (num <= 0)
                {
                    this.winRound(MatchState.END_CONDITION_HOSTAGES_RESCUED, this.localData.gameModeData.rescueTeam, 1);
                }
                obj.numHostages = num;
                break;
        }
        this.onEvent({
            eventId: GameServer.EVENT_GAME_UPDATE,
            gameModeData: obj
        });
        this.removeNextStep(_pawn);
    }

    getHostages()
    {
        var arr = [];
        var pawns = this.getPawns();
        for (var i = 0; i < pawns.length; i++)
        {
            if (pawns[i].data.bHostage)
            {
                arr.push(pawns[i]);
            }
        }
        return arr;
    }

    getNumHostages()
    {
        return this.getHostages().length;
    }

    onRoundStart()
    {
        switch (this.localData.gameModeData["id"])
        {
            case GameMode.ASSASSINATION:
                var players = this.clone(this.localData.playerStates);
                this.shuffleArray(players);
                for (var i = 0; i < players.length; i++)
                {
                    var ps = players[i];
                    if (ps["team"] == this.localData.gameModeData["vipTeam"])
                    {
                        this.makePlayerVIP(ps.id);
                        break;
                    }
                }
                break;

            case GameMode.RESCUE:
                var map = this.getCurrentMapData();
                var hostages = map.spawns_hostages;
                if (hostages)
                {
                    for (var i = 0; i < hostages.length; i++)
                    {
                        this.createSandboxUnit({
                            unitId: SurvivalEnemyType.HOSTAGE,
                            team: 99,
                            pos: hostages[i]
                        });
                    }
                }
                else
                {
                    console.warn("Missing hostage spawn points");
                }
                break;
        }
    }

    onPreGameTimer()
    {
        var localData = this.localData;
        if (!localData)
        {
            return;
        }
        if (!localData["bPaused"])
        {
            localData["preGameTimer"]--;
            if (localData["preGameTimer"] < 0)
            {
                var timer = localData["timer_preGame"];
                clearInterval(timer);
                delete localData["timer_preGame"];
                delete localData["preGameTimer"];
                var players = this.localData["playerStates"];
                for (var i = 0; i < players.length; i++)
                {
                    var ps = players[i];
                    ps["bAutoRespawn"] = true;
                    this.onEvent({
                        eventId: GameServer.EVENT_PLAYER_UPDATE,
                        playerId: ps["id"],
                        data: {
                            bAutoRespawn: ps["bAutoRespawn"]
                        }
                    });
                }
                this.localData["matchState"] = MatchState.STATE_IN_PROGRESS;
                this.requestEvent({
                    eventId: GameServer.EVENT_GAME_START,
                    timer: localData["gameTimer"]
                });
            }
            else
            {
                this.onEvent({
                    eventId: GameServer.EVENT_GAME_PRE_TIMER,
                    timer: localData["preGameTimer"]
                });
            }
        }
    }

    onInfectedTimer()
    {
        var localData = this.localData;
        if (!localData["bPaused"])
        {
            var gameData = localData.gameModeData;
            gameData["intermissionTimer"]--;
            if (gameData["intermissionTimer"] < 0)
            {                
                var timer = localData["timer_wave"];
                clearInterval(timer);
                delete localData["timer_wave"];
                //Make random player infected
                var index = this.Random(0, this.localData.playerStates.length - 1);
                var ps = this.localData.playerStates[index];
                this.makePlayerInfected(ps["id"]);
                gameData["bFirstInfected"] = true;
            }
            this.onEvent({
                eventId: GameServer.EVENT_GAME_UPDATE,
                gameModeData: {
                    intermissionTimer: localData.gameModeData["intermissionTimer"]
                }
            });
        }
    }

    makePlayerVIP(_playerId)
    {
        var ps = this.getPlayerStateById(_playerId);
        if (ps)
        {
            var char = this.getObjectById(ps["id"]);
            if (char && char.data["health"])
            {
                char.data["bVIP"] = true;
                char.data["bNoPickups"] = true;
                ps["bVIP"] = true;
                this.requestEvent({
                    eventId: GameServer.EVENT_PLAYER_UPDATE_INVENTORY,
                    pawnId: ps["id"],
                    type: GameServer.INV_PERKS_SET,
                    perks: [Perks.PERK_PLAYER_JUGGERNAUT, Perks.PERK_PLAYER_SPECIALIST],
                    bRemoveEquipment: true
                });
                var pistol = this.getWeaponData("p320");
                pistol.ammo = pistol.magSize * 10;
                var mods = {
                    barrel: "barrel_laser"
                };
                this.applyWeaponMods(pistol, mods);
                this.requestEvent({
                    eventId: GameServer.EVENT_PLAYER_UPDATE_INVENTORY,
                    pawnId: ps["id"],
                    type: GameServer.INV_INVENTORY_REPLACE,
                    inventory: [
                        pistol
                    ]
                });
                var equipment = this.getWeaponData("smoke");
                this.requestEvent({
                    eventId: GameServer.EVENT_PLAYER_UPDATE_INVENTORY,
                    pawnId: ps["id"],
                    index: 2,
                    value: equipment["id"],
                    type: GameServer.INV_EQUIPMENT_SET,
                    ammo: 1
                });
                this.pushObjectDataUpdate(char.data["id"], ["bVIP", "bNoPickups"]);
            }
            if (!ps["desiredAvatarData"])
            {
                ps["desiredAvatarData"] = ps["avatarData"];
            }
            var vipAvatar = {
                body: Character.BODY_VIP,
                head: Character.HEAD_NONE,
                face: Character.FACE_DEFAULT,
                facewear: Character.FACEWEAR_NONE,
                eyewear: Character.EYEWEAR_NONE,
                hair: Character.HAIR_SHORT,
                hairColour: Character.HAIR_COLOUR_BROWN,
                beard: Character.BEARD_NONE,
                melee: "melee_knife"
            };
            ps["avatarData"] = vipAvatar;
            this.onEvent({
                eventId: GameServer.EVENT_PLAYER_UPDATE,
                playerId: ps["id"],
                data: {
                    team: ps["team"],
                    bVIP: ps["bVIP"],
                    avatarData: ps["avatarData"]
                }
            });
        }
    }

    makePlayerJuggernaut(_playerId, _killstreakId)
    {
        var ps = this.getPlayerStateById(_playerId);
        if (ps)
        {
            var char = this.getObjectById(ps["id"]);
            if (char && char.data["health"])
            {
                char.data["bJuggernaut"] = true;
                ps["bJuggernaut"] = true;
                this.requestEvent({
                    eventId: GameServer.EVENT_PLAYER_UPDATE_INVENTORY,
                    pawnId: ps["id"],
                    type: GameServer.INV_PERKS_SET,
                    perks: [Perks.PERK_PLAYER_JUGGERNAUT],
                    bRemoveEquipment: true
                });
                switch (_killstreakId)
                {
                    case Killstreaks.KILLSTREAK_JUGGERNAUT:
                        var jugLMG = this.getWeaponData("m240");
                        //jugLMG["ammo"] *= 3;
                        //this.applyWeaponMods(jugLMG, { barrel: Mods.BARREL_GRIP });
                        var inventory = [
                            jugLMG
                        ];
                        var equipment = this.getWeaponData("frag");
                        var equipmentAmmo = 2;
                        break;
                    case Killstreaks.KILLSTREAK_JUGGERNAUT_RECON:
                        var pistol = this.getWeaponData("magnum");
                        pistol["ammo"] = pistol["magSize"] * 10;
                        this.applyWeaponMods(pistol, { barrel: Mods.BARREL_LASER, ammo: Mods.AMMO_FMJ });
                        var inventory = [
                            pistol,
                            this.getWeaponData("riot_shield"),
                        ];
                        equipment = this.getWeaponData("smoke");
                        break;
                }
                if (inventory)
                {                    
                    this.requestEvent({
                        eventId: GameServer.EVENT_PLAYER_UPDATE_INVENTORY,
                        pawnId: ps["id"],
                        type: GameServer.INV_INVENTORY_REPLACE,
                        inventory: inventory
                    });
                }
                if (equipment)
                {
                    this.requestEvent({
                        eventId: GameServer.EVENT_PLAYER_UPDATE_INVENTORY,
                        pawnId: ps["id"],
                        index: 2,
                        value: equipment["id"],
                        type: GameServer.INV_EQUIPMENT_SET,
                        ammo: equipmentAmmo
                    });
                }
                this.pushObjectDataUpdate(char.data["id"], ["bJuggernaut"]);
            }
            if (!ps["desiredAvatarData"])
            {
                ps["desiredAvatarData"] = ps["avatarData"];
            }
            var vipAvatar = {
                hairColour: Character.HAIR_COLOUR_BLACK,
                hair: Character.HAIR_BALD,
                beard: Character.BEARD_NONE,
                face: Character.FACE_DEFAULT,
                head: Character.HEAD_JUGGERNAUT_HELMET,
                body: Character.BODY_JUGGERNAUT,
                facewear: Character.FACEWEAR_MASK,
                melee: "melee_bowie"
            };
            ps["avatarData"] = vipAvatar;
            this.onEvent({
                eventId: GameServer.EVENT_PLAYER_UPDATE,
                playerId: ps["id"],
                data: {
                    team: ps["team"],
                    bJuggernaut: ps["bJuggernaut"],
                    avatarData: ps["avatarData"]
                }
            });
        }
    }

    makePlayerZombie(_id, _zombieType)
    {
        var ps = this.getPlayerStateById(_id);
        if (ps)
        {
            var char = this.getObjectById(ps["id"]);
            if (char && char.data["health"])
            {
                char.data["bZombie"] = true;
                char.data["zombieType"] = Zombie.TYPE_DEFAULT;
                char.data["bNoPickups"] = true;
                var infectedWeapon = this.getWeaponData("zombie");
                this.applyWeaponMods(infectedWeapon, { base: "base_speed" });
                this.requestEvent({
                    eventId: GameServer.EVENT_PLAYER_UPDATE_INVENTORY,
                    pawnId: ps["id"],
                    index: 0,
                    type: GameServer.INV_ITEM_REPLACE,
                    item: infectedWeapon
                });
                this.requestEvent({
                    eventId: GameServer.EVENT_PLAYER_UPDATE_INVENTORY,
                    pawnId: ps["id"],
                    index: 1,
                    type: GameServer.INV_ITEM_REPLACE,
                    item: infectedWeapon
                });
                this.pushObjectDataUpdate(char.data["id"], ["bZombie", "zombieType", "team", "perks", "bNoPickups"]);
            }
            if (!ps["desiredAvatarData"])
            {
                ps["desiredAvatarData"] = ps["avatarData"];
            }
            ps["avatarData"] = {
                hairColour: Character.HAIR_COLOUR_BLACK,
                hair: Character.HAIR_BALD,
                beard: Character.BEARD_NONE,
                face: Character.FACE_ZOMBIE_1,
                head: Character.HEAD_NONE,
                body: Character.BODY_ZOMBIE
            };
            if (char)
            {
                char.data.avatarData = ps.avatarData;
            }
            this.onEvent({
                eventId: GameServer.EVENT_PLAYER_UPDATE,
                playerId: ps["id"],
                data: {
                    team: ps["team"],
                    bZombie: ps["bZombie"],
                    avatarData: ps["avatarData"]
                }
            });
        }        
    }

    makePlayerSuicideVest(_id)
    {
        var ps = this.getPlayerStateById(_id);
        if (ps)
        {
            var wpn = this.getWeaponData("none");
            this.requestEvent({
                eventId: GameServer.EVENT_PLAYER_UPDATE_INVENTORY,
                pawnId: ps["id"],
                index: 0,
                type: GameServer.INV_ITEM_REPLACE,
                item: wpn
            });
            ps.avatarData.body = "c4_vest";
            var char = this.getObjectById(ps.id);
            if (char)
            {
                char.data.avatarData = ps.avatarData;
            }
            this.onEvent({
                eventId: GameServer.EVENT_PLAYER_UPDATE,
                playerId: ps["id"],
                data: {
                    avatarData: ps["avatarData"]
                }
            });
        }
    }

    makePlayerSantaClaus(_id)
    {
        var ps = this.getPlayerStateById(_id);
        if (ps)
        {
            ps["avatarData"] = {
                hairColour: Character.HAIR_COLOUR_WHITE,
                hair: Character.HAIR_LONG,
                beard: Character.BEARD_FULL,
                face: Character.FACE_DEFAULT,
                head: Character.HEAD_SANTA_HAT,
                body: Character.BODY_OPFOR_BARE
            };
            var char = this.getObjectById(ps.id);
            if (char)
            {
                char.data.avatarData = ps.avatarData;
            }
            this.onEvent({
                eventId: GameServer.EVENT_PLAYER_UPDATE,
                playerId: ps["id"],
                data: {
                    avatarData: ps["avatarData"]
                }
            });
        }
    }

    makePlayerInfected(_id)
    {
        var ps = this.getPlayerStateById(_id);
        if (ps)
        {
            ps["team"] = 1;
            ps["bInfected"] = true;            
            var char = this.getObjectById(ps["id"]);
            if (char && char.data["health"])
            {
                char.data["team"] = 1;
                char.data["bZombie"] = true;
                char.data["zombieType"] = Zombie.TYPE_SPRINTER;
                this.requestEvent({
                    eventId: GameServer.EVENT_PLAYER_UPDATE_INVENTORY,
                    pawnId: ps["id"],
                    type: GameServer.INV_PERKS_SET,
                    perks: this.localData.gameModeData["infectedPerks"],
                    //bRemoveEquipment: true
                });
                var infectedWeapon = this.getWeaponData(this.localData.gameModeData["infectedWeapon"]["id"]);
                this.applyWeaponMods(infectedWeapon, this.localData.gameModeData["infectedWeapon"]["mods"]);
                this.requestEvent({
                    eventId: GameServer.EVENT_PLAYER_UPDATE_INVENTORY,
                    pawnId: ps["id"],
                    index: 0,
                    type: GameServer.INV_ITEM_REPLACE,
                    item: infectedWeapon
                });
                this.requestEvent({
                    eventId: GameServer.EVENT_PLAYER_UPDATE_INVENTORY,
                    pawnId: ps["id"],
                    index: 2,
                    value: this.localData.gameModeData["infectedEquipment"],
                    type: GameServer.INV_EQUIPMENT_SET
                });
                this.pushObjectDataUpdate(char.data["id"], ["bZombie", "zombieType", "team", "perks"]);
            }
            ps["avatarData"] = {
                hairColour: Character.HAIR_COLOUR_BLACK,
                hair: Character.HAIR_BALD,
                beard: Character.BEARD_NONE,
                face: Character.FACE_ZOMBIE_SPRINTER,
                head: Character.HEAD_NONE,
                body: Character.BODY_ZOMBIE_SPRINTER
            };
            this.onEvent({
                eventId: GameServer.EVENT_PLAYER_UPDATE,
                playerId: ps["id"],
                data: {
                    team: ps["team"],
                    bInfected: ps["bInfected"],
                    avatarData: ps["avatarData"]
                }
            });
            this.onEvent({
                eventId: GameServer.EVENT_GAME_UPDATE,
                gameModeData: {
                    bInfected: true,
                    playerId: ps["id"]
                }
            });
        }
        var numInfected = this.getNumInfected();
        if (this.localData.playerStates.length - numInfected == 1)
        {
            for (var i = 0; i < this.localData.playerStates.length; i++)
            {
                var ps = this.localData.playerStates[i];
                //Give final survivor extra perks
                if (ps && !ps["bInfected"])
                {
                    this.requestEvent({
                        eventId: GameServer.EVENT_PLAYER_UPDATE_INVENTORY,
                        pawnId: ps["id"],
                        type: GameServer.INV_PERKS_SET,
                        perks: [Perks.PERK_PLAYER_LIGHTWEIGHT, Perks.PERK_PLAYER_SCAVENGER, Perks.PERK_WEAPON_RELOAD]
                    });
                    break;
                }
            }
        }
    }


    onWaveTimer()
    {
        var localData = this.localData;
        if (!localData["bPaused"])
        {
            var gameData = localData.gameModeData;
            gameData["intermissionTimer"]--;
            if (gameData["intermissionTimer"] < 0)
            {
                //Wave start
                var timer = localData["timer_wave"];
                clearInterval(timer);
                delete localData["timer_wave"];

                gameData["wave"]++;
                gameData["waveKills"] = 0;
                gameData["waveHeadshots"] = 0;
                gameData["waveMelees"] = 0;
                gameData["enemiesSpawned"] = 0;

                var numWaveEnemies = 1;
                var wave = gameData["wave"];
                var waveType;
                var spawnTime;
                var spawnTimeBase = 3000;
                var minSpawnTime = 200;
                switch (gameData["id"])
                {
                    case GameMode.SURVIVAL_STAKEOUT:
                        if (wave == 5)
                        {
                            numWaveEnemies = 2;
                            waveType = "chopper";
                        }
                        else if (wave % 5 === 0)
                        {
                            numWaveEnemies = ((wave / 5) - 1) * 3;
                            waveType = "juggernauts";
                        }
                        else
                        {
                            numWaveEnemies = (wave * 10);
                            if (wave == 8)
                            {
                                waveType = "claymores";
                            }
                        }
                        if (wave >= 5)
                        {
                            if (wave % 5 != 0 && wave % 2 == 0)
                            {
                                var escortPlayer = this.localData.playerStates[this.Random(0, this.localData.playerStates.length - 1)];
                                if (escortPlayer)
                                {
                                    var pos = this.getRandomAirdropPosition();
                                    this.executePlayerKillstreak(escortPlayer.id, Killstreaks.KILLSTREAK_ESCORT_AIRDROP_SURVIVAL, pos[0], pos[1] + 200, true);
                                }
                            }
                        }
                        break;

                    case GameMode.SURVIVAL_BASIC:
                        spawnTimeBase = 4000;
                        if (wave == 15)
                        {
                            numWaveEnemies = 2;
                            waveType = "chopper";
                        }
                        else if (wave % 10 == 0)
                        {
                            spawnTime = 1000;
                            numWaveEnemies = (wave / 10) * 2;
                            waveType = "juggernauts";
                        }
                        else if (wave == 5)
                        {
                            numWaveEnemies = wave / 5;
                            waveType = "chopper";
                        }
                        else
                        {
                            numWaveEnemies = wave * 5;
                            if (wave == 8)
                            {
                                waveType = "claymores";
                            }
                        }
                        break;

                    case GameMode.SURVIVAL_UNDEAD:
                        spawnTimeBase = 2500;
                        if (wave == 3)
                        {
                            numWaveEnemies = 2;
                        }
                        else if (wave == 5)
                        {
                            numWaveEnemies = 8;
                        }
                        else if (wave == 10)
                        {
                            numWaveEnemies = 10;
                        }
                        else if (wave == 15)
                        {
                            numWaveEnemies = 2;
                        }
                        else
                        {
                            numWaveEnemies = wave * 5;
                        }
                        break;

                    case GameMode.SURVIVAL_CHAOS:
                        spawnTimeBase = 2000;
                        minSpawnTime = 100;
                        if (wave !== 20 && wave !== 25 && wave % 5 == 0)
                        {
                            spawnTime = 3000 - ((wave / 5) * 500);
                            numWaveEnemies = (wave / 5) * 3;
                            waveType = "juggernauts";
                        }
                        else
                        {
                            numWaveEnemies = wave * 5;
                            if (wave == 4)
                            {
                                waveType = "claymores";
                            }
                        }
                        break;

                    case GameMode.SURVIVAL_PRO:
                        spawnTimeBase = 1500;
                        minSpawnTime = 100;
                        numWaveEnemies = 5 * wave;
                        break;
                }

                gameData["enemies"] = Math.ceil(Math.min(Math.max(1, numWaveEnemies), 100));
                gameData["enemiesRemaining"] = gameData["enemies"];

                if (!spawnTime)
                {
                    var numPlayers = this.getPlayerStates().length;
                    if (numPlayers > 1)
                    {
                        spawnTimeBase = Math.round(spawnTimeBase / numPlayers);
                    }
                    spawnTime = Math.max(minSpawnTime, spawnTimeBase - (Math.min(100, gameData["wave"]) * 100));
                }
                timer = setInterval(this.onWaveSpawnTimer.bind(this), spawnTime);
                localData["timer_waveSpawn"] = timer;

                this.onEvent({
                    eventId: GameServer.EVENT_GAME_WAVE_START,
                    waveType: waveType
                });
            }
            this.onEvent({
                eventId: GameServer.EVENT_GAME_UPDATE,
                gameModeData: {
                    intermissionTimer: gameData["intermissionTimer"],
                    wave: gameData["wave"],
                    enemies: gameData["enemies"],
                    enemiesRemaining: gameData["enemiesRemaining"]
                }
            });
        }
    }

    onWaveSpawnTimer()
    {
        var localData = this.localData;
        if (!localData["bPaused"])
        {
            var gameData = localData.gameModeData;
            if (gameData["enemiesSpawned"] < gameData["enemies"])
            {
                if (localData["deadswitchCooldownTimer"] > 0)
                {
                    return;
                }
                var pawns = this.getPawns(1);
                var maxEnemies = Math.min(8, 5 + (gameData["wave"] - 1)); //Max survival enemies
                if (pawns.length >= maxEnemies)
                {
                    return;
                }
                gameData["enemiesSpawned"]++;
                var map = this.getCurrentMapData();
                var enemyId = gameData["wave"] + "_" + gameData["enemiesSpawned"];
                var spawns = map.spawns_survival;
                var spawnIndex = this.Random(0, spawns.length - 1);
                var spawnX = spawns[spawnIndex][0];
                var spawnY = spawns[spawnIndex][1];
                var wave = Math.min(101, gameData["wave"]);
                var enemyTypes = {};
                var enemyType = null;
                var enemyInfo = null;
                var enemyHealthMult = 1 + Math.floor(wave / 10) + (Math.floor(wave / 20));
                if (wave > 10)
                {
                    enemyHealthMult += Math.max(0, (wave - 10) * 0.1);
                }
                if (wave > 15)
                {
                    enemyHealthMult += Math.max(0, (wave - 15) * 0.1);
                }
                switch (gameData["id"])
                {
                    case GameMode.SURVIVAL_STAKEOUT:
                        enemyHealthMult *= 0.75;
                        if (wave === 5)
                        {
                            enemyTypes[SurvivalEnemyType.HELI_MH6] = 1;
                        }
                        else if (wave % 5 === 0)
                        {                            
                            enemyTypes[SurvivalEnemyType.JUGGERNAUT] = 3;
                            if (wave >= 10)
                            {
                                enemyTypes[SurvivalEnemyType.JUGGERNAUT_COMMANDER] = 1;
                            }
                            if (wave >= 15)
                            {
                                enemyTypes[SurvivalEnemyType.JUGGERNAUT_JAVELIN] = 1;
                                enemyTypes[SurvivalEnemyType.INFESTOR_KING] = 1;
                            }
                            if (wave >= 20)
                            {
                                enemyTypes[SurvivalEnemyType.INFESTOR_KING] = 1;
                            }
                        }
                        else
                        {
                            enemyTypes[SurvivalEnemyType.OPFOR_PISTOL] = wave;
                            enemyTypes[SurvivalEnemyType.ZOMBIE_DEFAULT] = wave;
                            if (wave >= 2)
                            {
                                enemyTypes[SurvivalEnemyType.OPFOR_BASIC] = wave;
                            }
                            if (wave >= 3)
                            {
                                enemyTypes[SurvivalEnemyType.ZOMBIE_FAT] = wave * 0.1;
                                enemyTypes[SurvivalEnemyType.OPFOR_HEAVY] = wave * 0.5;
                                enemyTypes[SurvivalEnemyType.RUS_BASIC] = wave;
                            }
                            if (wave >= 5)
                            {
                                enemyTypes[SurvivalEnemyType.ZOMBIE_SPRINTER] = wave * 3;
                                enemyTypes[SurvivalEnemyType.RUS_HARD] = wave;
                                enemyTypes[SurvivalEnemyType.HELI_DRAGONFIRE] = wave * 0.5;
                            }
                            if (wave >= 6)
                            {
                                enemyTypes[SurvivalEnemyType.ZOMBIE_EXPLODER] = wave * wave;
                                enemyTypes[SurvivalEnemyType.RUS_SNIPER] = wave;
                            }
                            if (wave >= 8)
                            {
                                enemyTypes[SurvivalEnemyType.RUS_CLAYMORE] = wave * 0.5;
                                enemyTypes[SurvivalEnemyType.ZOMBIE_SPITTER] = wave * wave;
                                enemyTypes[SurvivalEnemyType.RUS_EXPERT] = wave;
                            }
                            if (wave >= 10)
                            {
                                enemyTypes[SurvivalEnemyType.INFESTOR] = wave * wave;
                                enemyTypes[SurvivalEnemyType.ZOMBIE_MELEE] = wave;
                                enemyTypes[SurvivalEnemyType.ZOMBIE_SPRINTER_MELEE] = wave * 0.5;
                                enemyTypes[SurvivalEnemyType.OPFOR_RPG] = wave * 0.1;
                                enemyTypes[SurvivalEnemyType.HELI_MH6] = wave * 0.5;
                                enemyTypes[SurvivalEnemyType.RUS_MELEE] = wave;
                                enemyTypes[SurvivalEnemyType.RUS_C4] = wave;
                            }
                            if (wave >= 12)
                            {
                                enemyTypes[SurvivalEnemyType.ZOMBIE_EXPLODER_BOSS] = wave * 2;
                                enemyTypes[SurvivalEnemyType.RUS_SHIELD] = wave * 3;
                                enemyTypes[SurvivalEnemyType.ZOMBIE_SPRINTER_BOSS] = wave * wave;
                            }
                            if (wave >= 13)
                            {
                                enemyTypes[SurvivalEnemyType.ZOMBIE_SPITTER_BOSS] = wave * wave;
                            }
                            if (wave >= 13)
                            {
                                enemyTypes[SurvivalEnemyType.ZOMBIE_FAT_THUMPER] = wave * 2;
                            }
                            if (wave >= 15)
                            {
                                enemyTypes[SurvivalEnemyType.INFESTOR_KING] = wave * 0.25;
                                enemyTypes[SurvivalEnemyType.JUGGERNAUT] = wave * 0.5;
                                enemyTypes[SurvivalEnemyType.HELI_COBRA] = wave * 0.5;
                                enemyTypes[SurvivalEnemyType.ZOMBIE_RPG] = wave * 0.5;
                                enemyTypes[SurvivalEnemyType.RUS_EXPLOSIVES] = wave * 0.1;
                            }
                            if (wave >= 18)
                            {
                                enemyTypes[SurvivalEnemyType.HELI_PAVE_LOW] = wave * wave * 0.2;
                                enemyTypes[SurvivalEnemyType.JUGGERNAUT_COMMANDER] = wave * 0.5;
                            }
                            if (wave >= 20)
                            {
                                enemyTypes[SurvivalEnemyType.JUGGERNAUT_JAVELIN] = wave * 0.5;
                                enemyTypes[SurvivalEnemyType.HELI_PAVE_LOW] += wave * 0.1;
                                enemyTypes[SurvivalEnemyType.HELI_COBRA] += wave * 0.1;
                                enemyTypes[SurvivalEnemyType.JUGGERNAUT_COMMANDER] += wave * 0.2;
                                enemyTypes[SurvivalEnemyType.ZOMBIE_RIFLE] = wave;
                            }
                            if (wave >= 21)
                            {
                                enemyTypes[SurvivalEnemyType.INFESTOR_KING] += wave;
                                enemyTypes[SurvivalEnemyType.INFESTOR] += wave * wave;
                            }
                        }
                        enemyType = this.getRandomProperty(enemyTypes);
                        enemyInfo = SurvivalEnemyInfo[enemyType];
                        break;

                    case GameMode.SURVIVAL_PRO:
                        enemyHealthMult *= 2;
                        var enemiesSpawned = this.localData.gameModeData["enemiesSpawned"];
                        var totalEnemies = this.localData.gameModeData["enemies"];
                        var threshold = Math.max(Math.round(totalEnemies * 0.5), Math.round((totalEnemies * 0.5) - (wave * wave)));
                        if (enemiesSpawned % threshold == 0)
                        {
                            enemyHealthMult *= (10 + wave);                           
                            enemyTypes[Heroes.OBSV32] = 1;
                            enemyTypes[Heroes.VALIANT25] = 1;
                            enemyTypes[Heroes.ARI] = 1;
                            enemyTypes[Heroes.KARAMBITGUY] = 1;
                            enemyTypes[Heroes.ERIC] = 1;
                            enemyTypes[Heroes.TWOPLAYER] = 1;
                            enemyTypes[Heroes.MOUSSA] = 1;
                            enemyTypes[Heroes.ALEXSEI] = 1;
                            enemyTypes[Heroes.UPBOSS] = 1;
                            if (wave >= 10)
                            {
                                enemyTypes[Heroes.XWILKINX] = 1;
                                enemyTypes[Heroes.AETIC] = 1;
                            }         
                            enemyType = this.getRandomProperty(enemyTypes);
                            enemyInfo = SurvivalEnemyInfo[enemyType];
                        }
                        else
                        {
                            enemyTypes[SurvivalEnemyType.OPFOR_BASIC] = 1;
                            enemyTypes[SurvivalEnemyType.OPFOR_HEAVY] = 1;
                            enemyTypes[SurvivalEnemyType.ZOMBIE_SPRINTER] = 1;
                            enemyTypes[SurvivalEnemyType.INFESTOR] = 1;
                            enemyTypes[SurvivalEnemyType.HELI_MH6] = 1;
                            enemyTypes[SurvivalEnemyType.HELI_DRAGONFIRE] = 1;
                            if (wave >= 5)
                            {
                                enemyTypes[SurvivalEnemyType.ZOMBIE_MELEE] = 1;
                                enemyTypes[SurvivalEnemyType.ZOMBIE_SPRINTER_MELEE] = 1;
                                enemyTypes[SurvivalEnemyType.RUS_HARD] = 1;
                                enemyTypes[SurvivalEnemyType.RUS_EXPERT] = 1;
                                enemyTypes[SurvivalEnemyType.RUS_SNIPER] = 1;
                                enemyTypes[SurvivalEnemyType.ZOMBIE_EXPLODER] = 1;
                                enemyTypes[SurvivalEnemyType.ZOMBIE_SPITTER] = 1;
                                enemyTypes[SurvivalEnemyType.HELI_COBRA] = 1 + (wave * 0.1);
                                enemyTypes[SurvivalEnemyType.OPFOR_RPG] = 1;
                                enemyTypes[SurvivalEnemyType.ZOMBIE_RPG] = 1;
                                enemyTypes[SurvivalEnemyType.JUGGERNAUT] = 1;
                                enemyTypes[SurvivalEnemyType.RUS_MELEE] = 1;
                                enemyTypes[SurvivalEnemyType.RUS_C4] = 1;
                            }
                            if (wave >= 10)
                            {
                                enemyTypes[SurvivalEnemyType.RUS_SHIELD] = 1;
                                enemyTypes[SurvivalEnemyType.RUS_CLAYMORE] = 1;
                                enemyTypes[SurvivalEnemyType.RUS_EXPLOSIVES] = 1;
                                enemyTypes[SurvivalEnemyType.ZOMBIE_EXPLODER_BOSS] = 1;
                                enemyTypes[SurvivalEnemyType.ZOMBIE_SPITTER_BOSS] = 1;
                                enemyTypes[SurvivalEnemyType.HELI_SCOUT] = 1;
                                enemyTypes[SurvivalEnemyType.HELI_CHOPPER_GUNNER] = 1;                                
                                enemyTypes[SurvivalEnemyType.JUGGERNAUT_COMMANDER] = 1;
                                enemyTypes[SurvivalEnemyType.ZOMBIE_FLAMETHROWER] = 1;
                                enemyTypes[SurvivalEnemyType.ZOMBIE_SPRINTER_BOSS] = wave * wave;
                            }
                            if (wave >= 15)
                            {
                                enemyTypes[SurvivalEnemyType.INFESTOR_KING] = wave;
                                enemyTypes[SurvivalEnemyType.HELI_PAVE_LOW] = wave * 0.5;
                                enemyTypes[SurvivalEnemyType.HELI_SNIPER] = 1;
                                enemyTypes[SurvivalEnemyType.JUGGERNAUT_JAVELIN] = wave * 0.5;
                            }
                            if (wave >= 20)
                            {
                                enemyTypes[SurvivalEnemyType.HELI_OSPREY] = 1;
                            }
                            if (wave >= 22)
                            {
                                enemyTypes[SurvivalEnemyType.HELI_REAPER] = 1;
                            }
                            enemyType = this.getRandomProperty(enemyTypes);
                            enemyInfo = SurvivalEnemyInfo[enemyType];
                        }                        
                        break;

                    case GameMode.SURVIVAL_CHAOS:
                        enemyHealthMult *= 2;
                        if (wave % 30 == 0)
                        {
                            enemyTypes[SurvivalEnemyType.INFESTOR] = 4;
                            enemyTypes[SurvivalEnemyType.INFESTOR_KING] = 1;
                            enemyTypes[SurvivalEnemyType.JUGGERNAUT] = 1;
                            enemyTypes[SurvivalEnemyType.JUGGERNAUT_COMMANDER] = 1;
                            enemyTypes[SurvivalEnemyType.JUGGERNAUT_JAVELIN] = 1;
                            enemyType = this.getRandomProperty(enemyTypes);
                        }
                        else if (wave % 25 == 0)
                        {
                            enemyTypes[SurvivalEnemyType.JUGGERNAUT_COMMANDER] = 1;
                            enemyTypes[SurvivalEnemyType.INFESTOR_KING] = 1;
                            enemyTypes[SurvivalEnemyType.ZOMBIE_RPG] = 1;
                            enemyTypes[SurvivalEnemyType.ZOMBIE_RIFLE] = 1;
                            enemyTypes[SurvivalEnemyType.OPFOR_RPG] = 1;
                            enemyType = this.getRandomProperty(enemyTypes);
                        }
                        else if (wave % 20 == 0)
                        {
                            enemyTypes[SurvivalEnemyType.JUGGERNAUT_COMMANDER] = 1;
                            enemyTypes[SurvivalEnemyType.ZOMBIE_SPITTER] = 1;
                            enemyTypes[SurvivalEnemyType.ZOMBIE_SPITTER_BOSS] = 1;
                            enemyTypes[SurvivalEnemyType.HELI_MH6] = 2;
                            enemyTypes[SurvivalEnemyType.HELI_COBRA] = 1;
                            enemyType = this.getRandomProperty(enemyTypes);
                        }
                        else if (wave % 5 == 0)
                        {
                            if (wave === 5)
                            {
                                enemyType = SurvivalEnemyType.JUGGERNAUT;
                            }
                            else
                            {
                                enemyTypes[SurvivalEnemyType.INFESTOR_KING] = 3 + (wave * 0.2);
                                enemyTypes[SurvivalEnemyType.JUGGERNAUT] = 2;
                                enemyTypes[SurvivalEnemyType.JUGGERNAUT_COMMANDER] = 1 + (wave * 0.1);
                                enemyType = this.getRandomProperty(enemyTypes);
                            }
                        }
                        else
                        {
                            enemyTypes[SurvivalEnemyType.ZOMBIE_SPRINTER] = (wave * wave) * 0.5;
                            enemyTypes[SurvivalEnemyType.RUS_BASIC] = wave * 3;
                            enemyTypes[SurvivalEnemyType.RUS_HARD] = wave * 2;
                            if (wave >= 2) enemyTypes[SurvivalEnemyType.ZOMBIE_EXPLODER] = wave * 3;
                            if (wave >= 3) enemyTypes[SurvivalEnemyType.ZOMBIE_SPITTER] = (wave * 4) + wave;
                            if (wave >= 4) enemyTypes[SurvivalEnemyType.RUS_CLAYMORE] = wave;
                            if (wave >= 5) enemyTypes[SurvivalEnemyType.HELI_MH6] = Math.round(wave * wave) * 0.5;
                            if (wave >= 6) enemyTypes[SurvivalEnemyType.INFESTOR] = (wave * wave) * 0.8;
                            if (wave >= 7) enemyTypes[SurvivalEnemyType.RUS_EXPERT] = wave * 2;
                            if (wave >= 8) enemyTypes[SurvivalEnemyType.RUS_SNIPER] = Math.round(wave * 1.5);
                            if (wave >= 9)
                            {
                                enemyTypes[SurvivalEnemyType.OPFOR_RPG] = wave;
                                enemyTypes[SurvivalEnemyType.ZOMBIE_FAT_THUMPER] = wave * 2;
                            }
                            if (wave >= 10)
                            {
                                enemyTypes[SurvivalEnemyType.ZOMBIE_MELEE] = wave;
                                enemyTypes[SurvivalEnemyType.ZOMBIE_SPRINTER_MELEE] = wave * 0.5;
                                enemyTypes[SurvivalEnemyType.ZOMBIE_SPITTER_BOSS] = (wave * 5) + wave;
                                enemyTypes[SurvivalEnemyType.RUS_SHIELD] = wave * 3;
                                enemyTypes[SurvivalEnemyType.HELI_DRAGONFIRE] = wave;
                                enemyTypes[SurvivalEnemyType.RUS_MELEE] = wave;
                                enemyTypes[SurvivalEnemyType.RUS_C4] = wave;
                                enemyTypes[SurvivalEnemyType.ZOMBIE_SPRINTER_BOSS] = wave * wave;
                            }
                            if (wave >= 11) enemyTypes[SurvivalEnemyType.JUGGERNAUT] = wave;
                            if (wave >= 12) enemyTypes[SurvivalEnemyType.INFESTOR_KING] = wave * 3;
                            if (wave >= 13) enemyTypes[SurvivalEnemyType.ZOMBIE_EXPLODER_BOSS] = wave * wave;
                            if (wave >= 14) enemyTypes[SurvivalEnemyType.ZOMBIE_RPG] = wave * 2;
                            if (wave >= 15)
                            {
                                enemyTypes[SurvivalEnemyType.HELI_COBRA] = Math.round(wave * wave) * 0.5;
                                enemyTypes[SurvivalEnemyType.HELI_CHOPPER_GUNNER] = wave;
                                enemyTypes[SurvivalEnemyType.HELI_SCOUT] = wave;
                                enemyTypes[SurvivalEnemyType.ZOMBIE_FLAMETHROWER] = wave;
                            }
                            if (wave >= 16) enemyTypes[SurvivalEnemyType.OPFOR_RPG] += wave * wave;                            
                            if (wave >= 20)
                            {
                                enemyTypes[SurvivalEnemyType.JUGGERNAUT_COMMANDER] = (wave * wave) * 0.5;
                                enemyTypes[SurvivalEnemyType.JUGGERNAUT_JAVELIN] = (wave * wave) * 0.25;
                                enemyTypes[SurvivalEnemyType.HELI_PAVE_LOW] = wave * 2;
                                enemyTypes[SurvivalEnemyType.HELI_SNIPER] = wave;
                                enemyTypes[SurvivalEnemyType.ZOMBIE_RIFLE] = wave;
                                enemyTypes[SurvivalEnemyType.RUS_EXPLOSIVES] = wave;
                            }
                            if (wave >= 21) enemyTypes[SurvivalEnemyType.HELI_COBRA] += wave;
                            if (wave >= 22) enemyTypes[SurvivalEnemyType.INFESTOR_KING] += (wave * wave) * 2;
                            if (wave >= 23)
                            {
                                enemyTypes[SurvivalEnemyType.HELI_PAVE_LOW] += wave * wave;
                                enemyTypes[SurvivalEnemyType.HELI_OSPREY] = 1;
                            }
                            if (wave >= 25)
                            {
                                enemyTypes[SurvivalEnemyType.HELI_REAPER] = 1;
                            }
                            enemyType = this.getRandomProperty(enemyTypes);
                        }
                        enemyInfo = SurvivalEnemyInfo[enemyType];
                        break;

                    case GameMode.SURVIVAL_BASIC:
                        enemyHealthMult *= 0.75;
                        if (wave == 15)
                        {
                            enemyType = SurvivalEnemyType.HELI_COBRA;
                        }
                        else if (wave % 10 == 0)
                        {
                            enemyTypes[SurvivalEnemyType.JUGGERNAUT] = wave;
                            enemyTypes[SurvivalEnemyType.JUGGERNAUT_COMMANDER] = wave * wave;
                            enemyTypes[SurvivalEnemyType.JUGGERNAUT_JAVELIN] = (wave * wave) * 0.1;
                            enemyType = this.getRandomProperty(enemyTypes);
                        }
                        else if (wave == 5)
                        {
                            enemyType = SurvivalEnemyType.HELI_MH6;
                        }
                        else
                        {
                            enemyTypes[SurvivalEnemyType.OPFOR_PISTOL] = wave;
                            if (wave >= 2) enemyTypes[SurvivalEnemyType.OPFOR_BASIC] = wave * 2;
                            if (wave >= 3) enemyTypes[SurvivalEnemyType.OPFOR_HEAVY] = wave;
                            if (wave >= 5) enemyTypes[SurvivalEnemyType.HELI_MH6] = wave * 0.5;
                            if (wave >= 6) enemyTypes[SurvivalEnemyType.RUS_BASIC] = wave * wave;
                            if (wave >= 7) enemyTypes[SurvivalEnemyType.RUS_EXPERT] = wave * 2;
                            if (wave >= 8) enemyTypes[SurvivalEnemyType.RUS_CLAYMORE] = wave;
                            if (wave >= 10)
                            {
                                enemyTypes[SurvivalEnemyType.RUS_HARD] = wave * wave;
                                enemyTypes[SurvivalEnemyType.HELI_DRAGONFIRE] = wave;
                                enemyTypes[SurvivalEnemyType.RUS_MELEE] = wave * wave;
                                enemyTypes[SurvivalEnemyType.RUS_C4] = wave;
                            }
                            if (wave >= 11) enemyTypes[SurvivalEnemyType.RUS_SNIPER] = wave * 1.5;
                            if (wave >= 12) enemyTypes[SurvivalEnemyType.JUGGERNAUT] = wave * 0.5;
                            if (wave >= 13) enemyTypes[SurvivalEnemyType.OPFOR_RPG] = wave * wave * 0.2;
                            if (wave >= 14) enemyTypes[SurvivalEnemyType.JUGGERNAUT_COMMANDER] = wave;
                            if (wave >= 15)
                            {
                                enemyTypes[SurvivalEnemyType.HELI_COBRA] = (wave * wave) * 0.5;
                                enemyTypes[SurvivalEnemyType.JUGGERNAUT] += wave;
                                enemyTypes[SurvivalEnemyType.HELI_SCOUT] = wave;
                            }
                            if (wave >= 16) enemyTypes[SurvivalEnemyType.RUS_SHIELD] = wave * wave * 0.5;
                            if (wave >= 18)
                            {
                                enemyTypes[SurvivalEnemyType.RUS_EXPLOSIVES] = wave * wave * 0.1;
                                enemyTypes[SurvivalEnemyType.HELI_PAVE_LOW] = (wave * wave);
                                enemyTypes[SurvivalEnemyType.HELI_CHOPPER_GUNNER] = wave;
                                enemyTypes[SurvivalEnemyType.HELI_SNIPER] = wave;
                                enemyTypes[SurvivalEnemyType.JUGGERNAUT_JAVELIN] = wave;
                            }
                            if (wave >= 20)
                            {
                                enemyTypes[SurvivalEnemyType.HELI_OSPREY] = wave;
                            }
                            if (wave >= 22)
                            {
                                enemyTypes[SurvivalEnemyType.HELI_REAPER] = wave;
                            }
                            enemyType = this.getRandomProperty(enemyTypes);
                        }
                        enemyInfo = SurvivalEnemyInfo[enemyType];
                        break;

                    case GameMode.SURVIVAL_UNDEAD:
                        if (wave == 3)
                        {
                            enemyType = SurvivalEnemyType.ZOMBIE_FAT;
                        }
                        else if (wave == 5)
                        {
                            enemyType = SurvivalEnemyType.ZOMBIE_SPRINTER;
                        }
                        else if (wave == 10)
                        {
                            enemyType = SurvivalEnemyType.INFESTOR;
                        }
                        else if (wave == 15)
                        {
                            enemyType = SurvivalEnemyType.INFESTOR_KING;
                        }
                        else
                        {
                            enemyTypes[SurvivalEnemyType.ZOMBIE_DEFAULT] = wave * 3;
                            if (wave >= 3) enemyTypes[SurvivalEnemyType.ZOMBIE_FAT] = wave * 0.5;
                            if (wave >= 4) enemyTypes[SurvivalEnemyType.ZOMBIE_MELEE] = wave * 0.1;
                            if (wave >= 5) enemyTypes[SurvivalEnemyType.ZOMBIE_SPRINTER] = wave * wave;
                            if (wave >= 6) enemyTypes[SurvivalEnemyType.ZOMBIE_EXPLODER] = wave;
                            if (wave >= 7) enemyTypes[SurvivalEnemyType.ZOMBIE_SPRINTER_BOSS] = wave * wave;
                            if (wave >= 8) enemyTypes[SurvivalEnemyType.ZOMBIE_SPITTER] = wave * 2;
                            if (wave >= 9) enemyTypes[SurvivalEnemyType.ZOMBIE_FAT_THUMPER] = wave;
                            if (wave >= 10)
                            {
                                enemyTypes[SurvivalEnemyType.ZOMBIE_JUGGERNAUT] = (wave * wave) * 0.5;
                                enemyTypes[SurvivalEnemyType.ZOMBIE_MELEE] += wave;
                                enemyTypes[SurvivalEnemyType.ZOMBIE_SPRINTER_MELEE] = wave * 0.5;
                                enemyTypes[SurvivalEnemyType.INFESTOR] = wave * wave;
                            }
                            if (wave >= 11) enemyTypes[SurvivalEnemyType.ZOMBIE_RPG] = wave;
                            if (wave >= 12) enemyTypes[SurvivalEnemyType.ZOMBIE_EXPLODER_BOSS] = wave * wave;
                            if (wave >= 15)
                            {
                                enemyTypes[SurvivalEnemyType.ZOMBIE_JUGGERNAUT_MERC] = wave;
                                enemyTypes[SurvivalEnemyType.ZOMBIE_JUGGERNAUT] += wave * wave;
                                enemyTypes[SurvivalEnemyType.ZOMBIE_SHIELD] = wave * wave * 0.5;
                                enemyTypes[SurvivalEnemyType.ZOMBIE_SPITTER_BOSS] = wave * wave;
                                enemyTypes[SurvivalEnemyType.ZOMBIE_RPG] += wave * wave;
                                enemyTypes[SurvivalEnemyType.ZOMBIE_FAT_THUMPER] += wave * wave;
                                enemyTypes[SurvivalEnemyType.ZOMBIE_FLAMETHROWER] += wave * wave;
                            }                            
                            if (wave >= 20)
                            {
                                enemyTypes[SurvivalEnemyType.INFESTOR_KING] = wave * wave * 2;
                                enemyTypes[SurvivalEnemyType.ZOMBIE_RPG] = wave * 2;
                            }
                            if (wave >= 22) enemyTypes[SurvivalEnemyType.INFESTOR] += wave * wave;
                            if (wave >= 23) enemyTypes[SurvivalEnemyType.INFESTOR_KING] += wave * wave;
                            if (wave >= 25)
                            {
                                enemyTypes[SurvivalEnemyType.ZOMBIE_SPITTER_BOSS] = wave * wave;
                                enemyTypes[SurvivalEnemyType.ZOMBIE_RPG] += wave * wave;
                                enemyTypes[SurvivalEnemyType.ZOMBIE_FAT_THUMPER] += wave * wave;
                            }
                            enemyType = this.getRandomProperty(enemyTypes);
                        }
                        enemyInfo = SurvivalEnemyInfo[enemyType];
                        break;
                }
                var useBotSkill = enemyInfo.botSkill;
                if (gameData["id"] == GameMode.SURVIVAL_PRO)
                {
                    useBotSkill += 2;
                }
                var botSkillIncreaseWave = this.getPlayerStates().length > 1 ? 5 : 10;
                if (wave > botSkillIncreaseWave)
                {
                    useBotSkill = Math.min(Math.max(BotSkill.SKILL_EASY, Math.floor(enemyInfo.botSkill + (wave / botSkillIncreaseWave))), BotSkill.SKILL_INSANE);
                }
                switch (enemyInfo.type)
                {
                    case "helicopter":
                        var heli = this.createHelicopter([this.RandomBoolean() ? 0 : map.width, 0], 1, {
                            type: enemyInfo.helicopterType,
                            destination: [map.width * 0.5, map.height * 0.5],
                            killReward: enemyInfo.killReward
                        });
                        if (wave >= 15)
                        {
                            heli.data["health"] += (wave - 15) * 100;
                        }
                        heli.data["bControllable"] = false;
                        heli.data["bBot"] = true;
                        heli.data["bPlayerControlled"] = false;
                        heli.data["bAirdrop"] = false;
                        heli.data["bMaxLookRange"] = true;
                        heli.data["bUnlimitedAmmo"] = true;
                        this.pushObjectDataUpdate(heli.data.id, ["health"]);
                        break;

                    case "infestor":
                        this.requestEvent({
                            eventId: GameServer.EVENT_CREATE_INFESTOR,
                            data:
                            {
                                id: enemyId,
                                x: spawnX,
                                y: spawnY,
                                team: 1,
                                infestorType: enemyInfo.infestorType,
                                health: enemyInfo.health + (wave * (25 * enemyHealthMult)),
                                botSkill: useBotSkill,
                                killReward: enemyInfo.killReward,
                                damageMultipliers: enemyInfo.damageMultipliers
                            }
                        });
                        break;

                    case "character":
                    default:
                        var curWeapon = enemyInfo.weapons[this.Random(0, enemyInfo.weapons.length - 1)];
                        var curWeaponData = this.getWeaponData(curWeapon);
                        var charHealth = enemyInfo.health;
                        if (enemyInfo.zombieType)
                        {
                            charHealth += (wave * (50 * enemyHealthMult));
                            var useInventory = [{ id: curWeapon }];
                        }
                        else
                        {
                            charHealth += (wave * (25 * enemyHealthMult));
                            useInventory = [
                                {
                                    id: curWeapon,
                                    mods: enemyInfo.mods ? enemyInfo.mods : this.getRandomMods(curWeaponData)
                                }
                            ];
                        }

                        if (enemyInfo.secondaryWeapons)
                        {
                            useInventory.push(
                                { id: enemyInfo.secondaryWeapons[this.Random(0, enemyInfo.secondaryWeapons.length - 1)] }
                            );
                        }
                        this.requestEvent({
                            eventId: GameServer.EVENT_CREATE_GENERIC_CHARACTER,
                            data:
                            {
                                id: enemyId,
                                x: spawnX,
                                y: spawnY,
                                team: 1,
                                health: charHealth,
                                inventory: useInventory,
                                equipment: enemyInfo.equipment,
                                avatarData: {
                                    hairColour: Character.HAIR_COLOUR_BLACK,
                                    hair: enemyInfo.zombieType != undefined ? Character.HAIR_BALD : Character.HAIR_SHORT,
                                    beard: Character.BEARD_NONE,
                                    face: enemyInfo.faces ? enemyInfo.faces[this.Random(0, enemyInfo.faces.length - 1)] : undefined,
                                    head: enemyInfo.heads[this.Random(0, enemyInfo.heads.length - 1)],
                                    body: enemyInfo.body,
                                    facewear: enemyInfo.facewear,
                                    eyewear: enemyInfo.eyewear
                                },
                                botSkill: useBotSkill,
                                killReward: enemyInfo.killReward,
                                bZombie: enemyInfo.zombieType != undefined,
                                zombieType: enemyInfo.zombieType,
                                damageMultipliers: enemyInfo.damageMultipliers,
                                ai: {
                                    bPreferDistance: true
                                },
                                maxSpeed: enemyInfo.maxSpeed,
                                bHero: enemyInfo.bHero,
                                pawnName: enemyInfo.pawnName,
                                bRegenHealth: enemyInfo.bHero || enemyInfo.bRegenHealth,
                                perks: enemyInfo.perks,
                                baseSpeedMultiplier: enemyInfo.baseSpeedMultiplier
                            }
                        });
                        break;
                }
            }
            else
            {
                var timer = localData["timer_waveSpawn"];
                if (timer)
                {
                    clearInterval(timer);
                    delete localData["timer_waveSpawn"];
                }
            }
        }
    }

    onRespawnTimer(_playerId)
    {
        var localData = this.localData;
        if (!localData)
        {
            return;
        }
        if (!localData["bPaused"])
        {
            var ps = this.getPlayerStateById(_playerId);
            if (ps["id"] == _playerId)
            {
                if (!ps["controllableId"])
                {
                    ps["respawnTimer"]--;
                    if (ps["respawnTimer"] < 0)
                    {
                        ps["bCanRespawn"] = true;
                        ps["bWaitingToRespawn"] = false;

                        if (ps["bAutoRespawn"])
                        {
                            this.requestEvent({
                                eventId: GameServer.EVENT_PLAYER_RESPAWN,
                                playerId: ps["id"]
                            });
                        }

                        delete ps["timer_respawn"];
                    }
                    else
                    {
                        ps["timer_respawn"] = this.localData.settings.fps;
                    }
                    this.onEvent({
                        eventId: GameServer.EVENT_PLAYER_UPDATE,
                        playerId: ps["id"],
                        data: {
                            bWaitingSpawn: ps["bWaitingToRespawn"],
                            bCanRespawn: ps["bCanRespawn"],
                            respawnTimer: ps["respawnTimer"],
                            bHasPawn: ps["bHasPawn"]
                        }
                    });
                }
            }
        }
    }

    onSpawnProtectionTimer(_playerId)
    {
        this.removeSpawnProtection(_playerId);
    }

    addPlayerMoney(_playerId, _val)
    {
        if (!_val && !this.localData["bSandbox"])
        {
            return;
        }
        var ps = this.getPlayerStateById(_playerId);
        if (ps)
        {
            var maxMoney = this.getSharedData("maxSurvivalMoney");
            ps["money"] = Math.max(0, Math.min(maxMoney, Math.round(ps["money"] + _val)));
            this.onEvent({
                eventId: GameServer.EVENT_PLAYER_UPDATE,
                playerId: _playerId,
                data: {
                    money: ps["money"]
                }
            });
        }
    }

    revivePlayer(_playerId, _position, _reviverId)
    {
        var ps = this.getPlayerStateById(_playerId);
        if (ps)
        {
            if (!this.localData["bModeGame"])
            {
                var inventory = ps["inventory"];
            }
            else
            {
                inventory = [{ id: "none" }];
            }

            var reviveData = {
                x: _position[0],
                y: _position[1],
                inventory: inventory,
                perks: []
            };
            var equipment = ps["equipment"];
            if (equipment)
            {
                reviveData.equipment = equipment["id"];
                reviveData.equipmentAmmo = equipment["ammo"];
            }
            this.requestEvent({
                eventId: GameServer.EVENT_REQUEST_RANKED_CHARACTER,
                playerId: ps["id"],
                avatarData: ps["avatarData"],
                data: reviveData
            });
            if (!this.localData["bModeGame"])
            {
                this.onEvent({
                    eventId: GameServer.EVENT_GAME_UPDATE,
                    gameModeData: {
                        bPlayerRevived: true,
                        reviverId: _reviverId,
                        revivedId: _playerId
                    }
                });
            }
            var reviver = this.getReviverByPlayerId(ps.id);
            if (reviver)
            {
                this.removeNextStep(reviver);
            }
        }
    }

    startInfectedIntermission()
    {
        var localData = this.localData;
        localData.gameModeData["intermissionTimer"] = Settings.INFECTED_INTERMISSION_TIMER;
        localData["timer_wave"] = setInterval(this.onInfectedTimer.bind(this), 1000);
        this.onEvent({
            eventId: GameServer.EVENT_GAME_UPDATE,
            gameModeData: {
                intermissionTimer: localData.gameModeData["intermissionTimer"]
            }
        });
    }

    startWaveIntermission()
    {
        var localData = this.localData;
        localData.gameModeData["intermissionTimer"] = 30;
        if (localData.gameModeData["wave"] == 0)
        {
            localData.gameModeData["intermissionTimer"] = 15;
        }
        if (localData["timer_wave"])
        {
            clearInterval(localData["timer_wave"]);
            delete localData["timer_wave"];
        }
        var timer_wave = setInterval(this.onWaveTimer.bind(this), 1000);
        localData["timer_wave"] = timer_wave;
        this.onEvent({
            eventId: GameServer.EVENT_GAME_UPDATE,
            gameModeData: {
                intermissionTimer: localData.gameModeData["intermissionTimer"]
            }
        });
    }

    getNearestFriendlyPawn(_pawn, _settings)
    {
        var pawns = this.getPawns();
        var pawn = null;
        var bLOS = false;
        var lastDist = Number.MAX_VALUE;
        var pawnTypes = null;
        var scale = undefined;
        var bPlayerOnly = false;
        var bVIP = false;
        var bInjured = false;
        if (_settings)
        {
            if (_settings["bLOS"] != undefined)
            {
                bLOS = _settings["bLOS"];
            }
            if (_settings["maxRange"] != undefined)
            {
                lastDist = _settings["maxRange"];
            }
            if (_settings["pawnTypes"] != undefined)
            {
                pawnTypes = _settings["pawnTypes"];
            }
            if (_settings["scale"] != undefined)
            {
                scale = _settings["scale"];
            }
            if (_settings["bPlayerOnly"] != undefined)
            {
                bPlayerOnly = _settings["bPlayerOnly"];
            }
            if (_settings["bVIP"] != undefined)
            {
                bVIP = _settings["bVIP"];
            }
            if (_settings["bInjured"] != undefined)
            {
                bInjured = _settings["bInjured"];
            }
        }
        for (var i = 0; i < pawns.length; i++)
        {
            var curPawn = pawns[i];
            if (curPawn.data["health"] && curPawn.data["team"] == _pawn.data["team"])
            {                
                if (curPawn.data["id"] == _pawn.data["id"])
                {
                    continue;
                }
                if (bPlayerOnly && curPawn.data["bBot"])
                {
                    continue;
                }
                if (bVIP && !curPawn.data["bVIP"])
                {
                    continue;
                }
                if (bInjured && curPawn.data["health"] >= curPawn.data["maxHealth"])
                {
                    continue;
                }
                if (pawnTypes)
                {
                    if (pawnTypes.indexOf(curPawn.data["type"]) < 0)
                    {
                        continue;
                    }
                }
                if (scale != undefined)
                {
                    if (scale > 0)
                    {
                        if (curPawn.position[0] < _pawn.position[0])
                        {
                            continue;
                        }
                    }
                    else if (scale < 0)
                    {
                        if (curPawn.position[0] > _pawn.position[0])
                        {
                            continue;
                        }
                    }
                }
                if (bLOS)
                {
                    if (!this.checkLineOfSight(_pawn.position, curPawn.position))
                    {
                        continue;
                    }
                }
                if (curPawn.data["type"] == "helicopter")
                {
                    if (curPawn.data["bDestroy"])
                    {
                        continue;
                    }
                }
                var dist = this.Dist(_pawn.position[0], _pawn.position[1], curPawn.position[0], curPawn.position[1]);
                if (dist < lastDist)
                {
                    lastDist = dist;
                    pawn = curPawn;
                }
            }
        }
        return pawn;
    }

    getPawnsInArea(_teamToIgnore, _position, _radius)
    {
        var arr = [];
        var pawns = this.getPawns();
        for (var i = 0; i < pawns.length; i++)
        {
            var curPawn = pawns[i];
            if (_teamToIgnore != undefined && curPawn.data.team == _teamToIgnore)
            {
                continue;
            }
            var dist = this.Dist(_position[0], _position[1], curPawn.position[0], curPawn.position[1]);
            if (dist < _radius)
            {
                arr.push(curPawn);
            }
        }
        return arr;
    }

    isGuidingHostage(_pawn)
    {
        if (_pawn)
        {
            var hostages = this.getHostages();
            for (var i = 0; i < hostages.length; i++)
            {
                var hostage = hostages[i];
                if (hostage.data.ai.followId == _pawn.data.id)
                {
                    return true;
                }
            }
        }
        return false;
    }

    onHostageInteract(_hostage)
    {
        if (this.localData.bOperation)
        {
            if (!this.localData.gameModeData.bHostageHeli && this.localData.difficulty >= 3)
            {
                var rescueZone = this.getRescueZone();
                var heli = this.createHelicopter([rescueZone[0], -200], 1, {
                    type: Helicopter.TYPE_MH6_ATTACK,
                    destination: rescueZone
                });
                heli.data["bControllable"] = false;
                heli.data["bBot"] = true;
                heli.data["bPlayerControlled"] = false;
                heli.data["bAirdrop"] = false;
                heli.data["bUnlimitedAmmo"] = true;
                this.localData.gameModeData.bHostageHeli = true;
            }
        }
    }

    getNearestHostage(_pawn)
    {
        var arr = [];
        var pawns = this.getPawns();
        for (var i = 0; i < pawns.length; i++)
        {
            var pawn = pawns[i];
            if (pawn.data.bHostage)
            {
                arr.push({
                    pawn: pawn,
                    dist: this.Dist(pawn.position[0], pawn.position[1], _pawn.position[0], _pawn.position[1]),
                    bFollowing: pawn.data.ai.followId != null
                });
            }
        }
        if (arr.length > 0)
        {
            arr.sort(function (a, b)
            {
                if (a.bFollowing && !b.bFollowing) return 1;
                if (!a.bFollowing && b.bFollowing) return -1;
                if (a.dist > b.dist) return 1;
                if (a.dist < b.dist) return -1;
                return 0;
            });
            return arr[0] ? arr[0].pawn : null;
        }
        return null;
    }

    getNearestEnemyPawn(_pawn, _settings)
    {
        var pawns = this.getPawns();
        var bLOS = true;
        var bPreferDistance = false;
        var bIgnoreOutOfSight = false;
        var bAllTypes = false;
        var pawnTypes = null;
        var scale = undefined;
        var bTargetColdBlooded = true;
        var maxRange = Number.MAX_VALUE;
        if (_settings)
        {
            if (_settings["bLOS"] != undefined)
            {
                bLOS = _settings["bLOS"];
            }
            if (_settings["maxRange"] != undefined)
            {
                maxRange = _settings["maxRange"];
            }
            if (_settings["pawnTypes"] != undefined)
            {
                pawnTypes = _settings["pawnTypes"];
            }
            if (_settings["scale"] != undefined)
            {
                scale = _settings["scale"];
            }
            if (_settings["bTargetColdBlooded"] != undefined)
            {
                bTargetColdBlooded = _settings["bTargetColdBlooded"];
            }
            if (_settings["bPreferDistance"] != undefined)
            {
                bPreferDistance = _settings["bPreferDistance"];
            }
            if (_settings["bIgnoreOutOfSight"] != undefined)
            {
                bIgnoreOutOfSight = _settings["bIgnoreOutOfSight"];
            }
            if (_settings["bAllTypes"] != undefined)
            {
                bAllTypes = _settings["bAllTypes"];
            }
        }
        var enemies = [];
        for (var i = 0; i < pawns.length; i++)
        {
            var curPawn = pawns[i];
            var bLOS = true;
            var fallback = 0;
            if (curPawn.data["bUntargetable"])
            {
                continue;
            }
            if (curPawn.data["bHostage"] && !_pawn.data.bZombie)
            {
                continue;
            }
            if (curPawn.data["health"] && curPawn.data["team"] != _pawn.data["team"])
            {
                if (this.localData["bBattlezone"])
                {
                    var ps = this.getPlayerStateById(curPawn.data.id);
                    if (ps && ps.bSpawnProtection)
                    {
                        continue;
                    }
                }
                var dist = this.Dist(_pawn.position[0], _pawn.position[1], curPawn.position[0], curPawn.position[1]);
                switch (_pawn.data.type)
                {
                    case "turret":
                    case "helicopter":
                        if (this.isInSmoke(curPawn))
                        {
                            continue;
                        }
                        break;

                    case "character":
                        if (!_pawn.data["bZombie"] && this.isInSmoke(curPawn) && dist > this.getSharedData("smokeSize"))
                        {
                            if (this.localData["bBattlezone"] || _pawn.data.ai.botSkill <= BotSkill.SKILL_NORMAL)
                            {
                                continue;
                            }
                        }
                        break;
                }                
                if (pawnTypes)
                {
                    if (pawnTypes.indexOf(curPawn.data["type"]) == -1)
                    {
                        if (bAllTypes)
                        {
                            fallback = 1;
                        }
                        else
                        {
                            continue;
                        }
                    }
                }
                if (scale != undefined)
                {
                    if (scale > 0)
                    {
                        if (curPawn.position[0] < _pawn.position[0])
                        {
                            continue;
                        }
                    }
                    else if (scale < 0)
                    {
                        if (curPawn.position[0] > _pawn.position[0])
                        {
                            continue;
                        }
                    }
                }
                if (curPawn.data["type"] == "helicopter")
                {
                    if (curPawn.data["bDestroy"])
                    {
                        continue;
                    }
                }
                else if (curPawn.data["type"] == "character")
                {
                    if (!bTargetColdBlooded)
                    {
                        if (this.characterHasPerk(curPawn, Perks.PERK_PLAYER_COLD_BLOODED))
                        {
                            continue;
                        }
                    }
                }
                if (bLOS)
                {
                    var bObstaclesBlock = true;
                    if (this.localData["bSurvival"])
                    {
                        if (_pawn.data["team"] == 0)
                        {
                            bObstaclesBlock = false;
                        }
                    }
                    else
                    {
                        switch (_pawn.data.type)
                        {
                            case "turret":
                                bObstaclesBlock = !this.localData["bSurvival"] && !_pawn.data["bAutomated"];
                                break;
                            case "car":
                                bObstaclesBlock = false;
                                break;
                            case "character":
                            case "infestor":
                                bObstaclesBlock = _pawn.data.ai["botSkill"] < BotSkill.SKILL_INSANE;
                                break;
                        }
                    }
                    if (dist > 100)
                    {                        
                        var bCheck = this.checkLineOfSight(this.getLOSStartPos(_pawn), curPawn.position, bObstaclesBlock);
                        if (!bCheck && !this.localData["bSurvival"])
                        {                            
                            switch (_pawn.data["type"])
                            {
                                case "character":
                                    if (this.localData.bOperation)
                                    {
                                        bCheck = this.checkLineOfSight(_pawn.position, [curPawn.position[0], curPawn.position[1] - 30], bObstaclesBlock);
                                    }
                                    break;

                                case "turret":
                                    if (this.localData.bOperation && this.localData.difficulty >= 3)
                                    {
                                        bCheck = this.checkLineOfSight([_pawn.position[0], _pawn.position[1] - 30], [curPawn.position[0], curPawn.position[1] - 30], bObstaclesBlock);
                                    }
                                    if (!bCheck) bCheck = this.checkLineOfSight(_pawn.position, curPawn.position, bObstaclesBlock);
                                    break;
                            }
                        }
                        if (!bCheck)
                        {
                            if (bIgnoreOutOfSight)
                            {
                                continue;
                            }
                            else
                            {
                                //Pawn out of sight, but add to enemies array if no other enemies
                                bLOS = false;
                            }
                        }
                    }
                }
                //var dist = this.Dist(_pawn.position[0], _pawn.position[1], curPawn.position[0], curPawn.position[1]);
                if (dist <= maxRange)
                {
                    var enemy = {
                        type: curPawn.data.type,
                        pawn: curPawn,
                        fallback: fallback,
                        dist: dist,
                        bLOS: bLOS
                    };
                    if (this.localData["bBattlezone"])
                    {
                        var ps = this.getPlayerStateById(curPawn.data.id);
                        if (ps)
                        {
                            enemy.shards = ps.shards;
                        }
                    }
                    else if (this.localData.gameModeData.id == GameMode.ASSASSINATION)
                    {
                        var ps = this.getPlayerStateById(curPawn.data.id);
                        if (ps)
                        {
                            enemy.bVIP = ps.bVIP;
                        }
                    }
                    enemies.push(enemy);
                }
            }
        }
        if (enemies.length > 0)
        {
            if (this.localData["bBattlezone"] && _pawn.data.team == Battlezone.TEAM_MERCENARIES)
            {
                enemies.sort(function (a, b)
                {
                    if (a.shards > b.shards) return -1;
                    if (a.shards < b.shards) return 1;
                    if (a.dist < b.dist) return -1;
                    if (a.dist > b.dist) return 1;
                    if (a.bLOS < b.bLOS) return 1;
                    if (a.bLOS > b.bLOS) return -1;
                    return 0;
                });
            }
            else if (this.localData.gameModeData.id == GameMode.ASSASSINATION)
            {
                enemies.sort(function (a, b)
                {
                    if (a.bVip < b.bVip) return -1;
                    if (a.bVip > b.bVip) return 1;
                    if (a.bLOS < b.bLOS) return 1;
                    if (a.bLOS > b.bLOS) return -1;
                    if (a.dist < b.dist) return -1;
                    if (a.dist > b.dist) return 1;
                    return 0;
                });
            }
            else if (bPreferDistance)
            {                
                enemies.sort(function (a, b)
                {
                    if (a.fallback < b.fallback) return -1;
                    if (a.fallback > b.fallback) return 1;
                    if (a.dist < b.dist) return -1;
                    if (a.dist > b.dist) return 1;
                    if (a.bLOS < b.bLOS) return 1;
                    if (a.bLOS > b.bLOS) return -1;
                    return 0;
                });
            }
            else
            {
                enemies.sort(function (a, b)
                {
                    if (a.bLOS < b.bLOS) return 1;
                    if (a.bLOS > b.bLOS) return -1;
                    if (a.dist < b.dist) return -1;
                    if (a.dist > b.dist) return 1;
                    return 0;
                });
            }
            return enemies[0].pawn;
        }
        return null;
    }

    getLOSStartPos(_pawn)
    {
        var data = _pawn["data"];
        switch (data["type"])
        {
            case "turret":
                return this.getMuzzlePosition(_pawn);
                break;

            case "character":
                return [_pawn.position[0], _pawn.position[1] - 30];
                break;

            case "helicopter":
                return this.getMuzzlePosition(_pawn);

            default:
                return _pawn.position;
        }
        return null;
    }

    setPlayerLatency(_playerId, _latency)
    {
        if (_latency == null)
        {
            return;
        }
        var ps = this.getPlayerStateById(_playerId);
        if (ps)
        {
            ps["latency"] = _latency;
            this.onEvent({
                eventId: GameServer.EVENT_PLAYER_UPDATE,
                playerId: ps["id"],
                data: {
                    latency: ps["latency"]
                }
            });
        }
    }

    getSharedData(_id)
    {
        var shared = this.data["shared"];
        if (shared) 
        {
            if (shared[_id])
            {
                return this.clone(shared[_id]);
            }
            else
            {
                console.warn("Invalid shared data:", _id);
            }
        }
        return null;
    }

    getSpriteData(_id)
    {
        var sprites = this.data["sprites"];
        if (sprites) 
        {
            return sprites[_id];
        }
        return null;
    }

    getWorldWeaponData(_id)
    {
        var weapons = this.data["atlas_weapons_world"];
        if (weapons)
        {
            var data = weapons.frames[_id];
            if (data)
            {
                return data.frame;
            }
            else
            {
                console.warn("Missing frame data:", _id);
                return { "x": 0, "y": 0, "w": 32, "h": 32 };
            }
        }
        return null;
    }

    getModData(_id)
    {
        var mods = this.data["mods"];
        for (var i = 0; i < mods.length; i++)
        {
            if (mods[i]["id"] == _id)
            {
                return this.clone(mods[i]);
            }
        }
        return null;
    }

    isMeleeWeapon(_weaponData)
    {
        if (_weaponData)
        {
            return _weaponData["type"] === Weapon.TYPE_MELEE || _weaponData["bMelee"];
        }
        return false;
    }

    isEquipment(_weaponData)
    {
        if (_weaponData)
        {
            return _weaponData["type"] == Weapon.TYPE_EXPLOSIVE || _weaponData["type"] == Weapon.TYPE_GRENADE || _weaponData["type"] == Weapon.TYPE_TACTICAL || _weaponData["bMelee"];
        }
        return false;
    }

    getWeaponData(_id, _options)
    {
        var weapons = this.data["weapons"];
        for (var i = 0; i < weapons.length; i++)
        {
            if (weapons[i]["id"] == _id)
            {
                var data = this.clone(weapons[i]);
                if (_options)
                {
                    var keys = Object.keys(_options);
                    for (var j = 0; j < keys.length; j++)
                    {
                        data[keys[j]] = _options[keys[j]];
                    }
                }
                delete data["name"];
                delete data["unlockLevel"];
                delete data["unlockPrestige"];
                delete data["desc"];
                switch (data.type)
                {
                    case Weapon.TYPE_RIFLE:
                    case Weapon.TYPE_SMG:
                    case Weapon.TYPE_LMG:
                        data.range += 400;
                        break;
                }
                return data;
            }
        }
        return null;
    }

    getPerkData(_id)
    {
        var perks = this.data["perks"];
        for (var i = 0; i < perks.length; i++)
        {
            if (perks[i]["id"] == _id)
            {
                var data = this.clone(perks[i]);
                return data;
            }
        }
        return null;
    }

    getRandomMods(_weaponData)
    {
        if (_weaponData["bZombie"] || this.isMeleeWeapon(_weaponData) || this.isEquipment(_weaponData))
        {
            return null;
        }
        var baseMods = [
            null,
            null,
            Mods.BASE_DAMPER,
            Mods.BASE_DEADEYE,
            Mods.BASE_RANGE,
            Mods.BASE_RAPID_FIRE,
            Mods.BASE_SPEED
        ];
        var barrelMods = [
            null,
            null,
            Mods.BARREL_LASER
        ];
        var ammoMods = [
            null,
            null
        ];
        switch (_weaponData["type"])
        {
            case Weapon.TYPE_WEAPON_TACTICAL:
                //None
                break;

            case Weapon.TYPE_LAUNCHER:
                ammoMods.push(
                    Mods.AMMO_LAUNCHER_EXPLOSIVE,
                    Mods.AMMO_LAUNCHER_RADIUS
                );
                break;

            case Weapon.TYPE_SMG:
            case Weapon.TYPE_RIFLE:
                if (!_weaponData["bSilenced"])
                {
                    barrelMods.push(Mods.BARREL_SILENCER);
                }
                barrelMods.push(Mods.BARREL_GRIP, Mods.BARREL_ACCELERATOR, Mods.BARREL_BOOSTER);
                if (_weaponData["type"] == Weapon.TYPE_RIFLE)
                {
                    switch (_weaponData["id"])
                    {
                        default:
                            barrelMods.push(Mods.BARREL_M203); 
                            break;
                    }
                    barrelMods.push(Mods.BARREL_MASTERKEY);
                }
                ammoMods.push(
                    Mods.AMMO_IMPACT,
                    Mods.AMMO_FMJ,
                    Mods.AMMO_PIERCING,
                    Mods.AMMO_EXTENDED,
                    Mods.AMMO_HOLLOW_POINT,
                    Mods.AMMO_HIGH_CALIBER
                );
                if (_weaponData["fireMode"] == Weapon.MODE_AUTO)
                {
                    baseMods.push(Mods.BASE_BURST_FIRE);
                }
                break;

            default:
                barrelMods.push(Mods.BARREL_ACCELERATOR, Mods.BARREL_BOOSTER);
                ammoMods.push(
                    Mods.AMMO_FMJ,
                    Mods.AMMO_PIERCING,
                    Mods.AMMO_EXTENDED,
                    Mods.AMMO_HOLLOW_POINT
                );
                if (_weaponData["bSingleRoundLoaded"])
                {
                    ammoMods.push(Mods.AMMO_SPEED_LOADER);
                }
                if (_weaponData["type"] == Weapon.TYPE_PISTOL)
                {
                    barrelMods.push(Mods.BARREL_COMPENSATOR);
                }
                if (_weaponData["type"] == Weapon.TYPE_SHOTGUN && _weaponData["bBoltAction"])
                {
                    ammoMods.push(Mods.AMMO_SLUG);
                }
                if (_weaponData["type"] != Weapon.TYPE_SHOTGUN)
                {
                    ammoMods.push(Mods.AMMO_IMPACT, Mods.AMMO_HIGH_CALIBER);
                }
                break;
        }
        return {
            base: baseMods[this.Random(0, baseMods.length - 1)],
            barrel: barrelMods[this.Random(0, barrelMods.length - 1)],
            ammo: ammoMods[this.Random(0, ammoMods.length - 1)]
        }
    }

    getRandomWeapon(_bIncludeEquipment = false)
    {
        var weapons = this.clone(this.data["weapons"]);
        for (var i = weapons.length - 1; i >= 0; i--)
        {
            var cur = weapons[i];
            if (cur["type"] == Weapon.TYPE_MELEE || cur["id"] == "m202" || cur["id"] == "smaw" || cur["id"] == "smoke" || cur["id"] == "sensor" || cur["id"] == "jammer")
            {
                weapons.splice(i, 1);
            }
            else if (!_bIncludeEquipment && cur["bEquipment"])
            {
                weapons.splice(i, 1);
            }
            else if (cur.id == "tac_insert" && !this.localData["bModeGame"])
            {
                weapons.splice(i, 1);
            }
            else if (cur["bHidden"])
            {
                weapons.splice(i, 1);
            }
        }
        return weapons[this.Random(0, weapons.length - 1)];
    }

    getRandomInfectedWeapon()
    {
        var weapons = this.clone(this.data["weapons"]);
        for (var i = weapons.length - 1; i >= 0; i--)
        {
            var cur = weapons[i];
            if (cur["bEquipment"] || cur["type"] == Weapon.TYPE_MELEE || cur["type"] == Weapon.TYPE_LAUNCHER || cur["type"] == Weapon.TYPE_WEAPON_TACTICAL)
            {
                weapons.splice(i, 1);
            }
            else if (cur["bHidden"])
            {
                weapons.splice(i, 1);
            }
        }
        return weapons[this.Random(0, weapons.length - 1)];
    }

    getKillstreakData(_id)
    {
        var killstreaks = this.data["killstreaks"];
        for (var i = 0; i < killstreaks.length; i++)
        {
            if (killstreaks[i]["id"] == _id)
            {
                return this.clone(killstreaks[i]);
            }
        }
        return null;
    }

    getGameModeData(_id)
    {
        var modes = this.data["modes"];
        for (var i = 0; i < modes.length; i++)
        {
            if (modes[i]["id"] == _id)
            {
                return this.clone(modes[i]);
            }
        }
        return null;
    }

    getInitEventData()
    {
        return {
            eventId: GameServer.EVENT_GAME_INIT,
            mapId: this.localData["mapId"],
            gameModeId: this.localData.gameModeData["id"],
            settings: this.localData.settings,
            shared: this.data.shared
        }
    }

    getGameStartEventData()
    {
        return {
            eventId: GameServer.EVENT_GAME_START,
            timer: this.localData["gameTimer"]
        }
    }

    getGameModeEventData()
    {
        return {
            eventId: GameServer.EVENT_GAME_UPDATE,
            gameModeData: this.localData["gameModeData"]
        };
    }

    getObjectsEventData()
    {
        var arr = [];
        var obstacles = this.getObstacles();
        for (var i = 0; i < obstacles.length; i++)
        {
            let obstacle = obstacles[i];
            arr.push({
                eventId: GameServer.EVENT_SPAWN_OBJECT,
                data: {
                    id: obstacle.data.id,
                    position: obstacle.position,
                    rotation: obstacle.angle,
                    type: "obstacle",
                    data: {
                        id: obstacle.data["id"],                        
                        position: [obstacle.position[0], obstacle.position[1]],
                        obstacleId: obstacle.data["obstacleId"],
                        scale: obstacle.data["scale"],
                        rotation: obstacle.data["rotation"]
                    }
                }
            });
        }
        var doors = this.getDoors();
        for (var i = 0; i < doors.length; i++)
        {
            let door = doors[i];
            arr.push({
                eventId: GameServer.EVENT_SPAWN_OBJECT,
                data: {
                    id: door.data.id,
                    position: door.position,
                    type: "door",
                    data: door.data
                }
            });
        }
        var characters = this.getCharacters();
        for (var i = 0; i < characters.length; i++)
        {
            let char = characters[i];            
            let ps = this.getPlayerStateById(char.data.id);
            if (ps)
            {
                arr.push({
                    eventId: GameServer.EVENT_CREATE_RANKED_CHARACTER,
                    playerId: char.data.id,
                    avatarData: ps.avatarData,
                    data: {
                        x: char.position[0] + (i * 50),
                        y: char.position[1],
                        inventory: char.data.inventory,
                        equipment: char.data.equipment,
                        perks: char.data.perks,
                        bVIP: char.data.bVIP,
                        bJuggernaut: char.data.bJuggernaut,
                        bInfected: char.data.bInfected
                    }
                });
            }
            else
            {
                arr.push({
                    eventId: GameServer.EVENT_CREATE_GENERIC_CHARACTER,
                    data: {
                        id: char.data.id,
                        x: char.position[0],
                        y: char.position[1],
                        team: char.data.team,
                        health: char.data.health,
                        inventory: char.data.inventory,
                        equipment: char.data.equipment,
                        avatarData: char.data.avatarData,
                        bZombie: char.data.bZombie,
                        bHostage: char.data.bHostage,                        
                        zombieType: char.data.zombieType,
                        perks: char.data.perks
                    }
                });
            }
        }
        var infestors = this.getInfestors();
        for (var i = 0; i < infestors.length; i++)
        {
            let infestor = infestors[i];
            arr.push({
                eventId: GameServer.EVENT_CREATE_INFESTOR,
                data: {
                    id: infestor.data.id,
                    x: infestor.position[0],
                    y: infestor.position[1],
                    team: infestor.data.team,
                    infestorType: infestor.data.infestorType,
                    health: infestor.data.health,
                    killReward: infestor.data.killReward,
                    damageMultipliers: infestor.data.damageMultipliers
                }
            });
        }
        var helis = this.getHelicopters();
        for (var i = 0; i < helis.length; i++)
        {
            let body = helis[i];
            arr.push({
                eventId: GameServer.EVENT_SPAWN_HELICOPTER,
                position: body.position,
                data: body.data
            });
        }
        var cars = this.getCars();
        for (var i = 0; i < cars.length; i++)
        {
            let body = cars[i];
            arr.push({
                eventId: GameServer.EVENT_SPAWN_OBJECT,
                position: body.position,
                data: body.data
            });
        }
        var turrets = this.getTurrets();
        for (var i = 0; i < turrets.length; i++)
        {
            let body = turrets[i];
            arr.push({
                eventId: GameServer.EVENT_SPAWN_TURRET,
                position: body.position,
                velocity: body.velocity,
                angularVelocity: body.angularVelocity,
                rotation: body.angle,
                data: body.data
            });
        }
        var flags = this.getAllFlags();
        for (var i = 0; i < flags.length; i++)
        {
            let body = flags[i];
            arr.push({
                eventId: GameServer.EVENT_SPAWN_FLAG,
                position: body.position,
                data: body.data
            });
        }
        var crates = this.getAllCrates();
        for (var i = 0; i < crates.length; i++)
        {
            let body = crates[i];
            arr.push({
                eventId: GameServer.EVENT_SPAWN_CRATE,
                position: body.position,
                data: body.data,
                mass: body.mass
            });
        }
        var grenades = this.getGrenades();
        for (var i = 0; i < grenades.length; i++)
        {
            let body = grenades[i];
            arr.push({
                eventId: GameServer.EVENT_SPAWN_GRENADE,
                position: body.position,
                velocity: body.velocity,
                angularVelocity: body.angularVelocity,
                data: body.data
            });
        }
        var equipment = this.getEquipment();
        for (var i = 0; i < equipment.length; i++)
        {
            let body = equipment[i];
            arr.push({
                eventId: GameServer.EVENT_SPAWN_EQUIPMENT,
                position: body.position,
                data: body.data
            });
        }
        var scavs = this.getScavengerPacks();
        for (var i = 0; i < scavs.length; i++)
        {
            let body = scavs[i];
            arr.push({
                eventId: GameServer.EVENT_SPAWN_OBJECT,
                position: body.position,
                data: body.data
            });
        }
        var loots = this.getLootPacks();
        for (var i = 0; i < loots.length; i++)
        {
            let body = loots[i];
            arr.push({
                eventId: GameServer.EVENT_SPAWN_OBJECT,
                position: body.position,
                data: body.data
            });
        }
        var weapons = this.getDroppedWeapons();
        for (var i = 0; i < weapons.length; i++)
        {
            let body = weapons[i];
            arr.push({
                eventId: GameServer.EVENT_SPAWN_DROPPED_WEAPON,
                position: body.position,
                rotation: body.angle,
                velocity: body.velocity,
                angularVelocity: body.angularVelocity,
                data: body.data
            });
        }
        return arr;
    }

    getNewPlayerDesiredTeam()
    {        
        var scoreLimit = this.localData.gameModeData["scoreLimit"];
        if (scoreLimit)
        {
            var scores = this.localData.gameModeData["scores"];
            if (scores)
            {
                if (scores[0] > scores[1])
                {
                    return 1;
                }
                else if (scores[0] < scores[1])
                {
                    return 0;
                }
            }
        }
        if (this.isTeamGameMode())
        {
            var team0 = this.getNumPlayersOnTeam(0);
            var team1 = this.getNumPlayersOnTeam(1);
            if (team0 > team1)
            {
                return 1;
            }
            else if (team0 < team1)
            {
                return 0;
            }
        }
        return this.Random(0, 1);
    }

    switchTeam(_playerId)
    {
        if (!this.localData.bAllowTeamSwitch)
        {
            return false;
        }
        if (this.isTeamGameMode() && !this.matchHasEnded())
        {
            console.log("Switch player team:", _playerId);
            var ps = this.getPlayerStateById(_playerId);
            if (ps)
            {
                var otherTeam = ps.team == 0 ? 1 : 0;
                if (this.getNumPlayersOnTeam(ps.team) <= this.getNumPlayersOnTeam(otherTeam))
                {
                    //if (!ps.bAdmin) return false;
                }
                if (!this.isPreGame())
                {
                    this.killPawn(ps.id);
                }
                ps.team = ps.team == 0 ? 1 : 0;
                var char = this.getObjectById(ps.id);
                if (char)
                {
                    char.data.team = ps.team;
                    if (this.isPreGame())
                    {
                        char.position = this.getBestSpawnPosition(ps.team, char);
                    }
                    this.pushObjectDataUpdate(ps.id, ["team"]);
                }
                if (this.localData.factions)
                {
                    var teamFaction = this.localData.factions[ps.team];
                    if (ps.avatars && ps.avatars[teamFaction])
                    {
                        ps["avatarData"] = ps.avatars[teamFaction];
                    }
                    else
                    {
                        ps["avatarData"].body = teamFaction;
                    }
                }
                this.onEvent({
                    eventId: GameServer.EVENT_PLAYER_UPDATE,
                    playerId: ps["id"],
                    data: {
                        team: ps["team"],
                        avatarData: ps["avatarData"]
                    }
                });
                return true;
            }
        }
        return false;
    }

    checkAutoTeamBalance()
    {        
        if (!this.isTeamGameMode() || !this.localData["bAutoBalance"])
        {
            return false;
        }
        if (this.localData["gameTimer"] < 60)
        {
            return false;
        }
        var scoreLimit = this.localData.gameModeData["scoreLimit"];
        if (scoreLimit)
        {
            var scores = this.localData.gameModeData["scores"];
            if (scores)
            {
                for (var i = 0; i < scores.length; i++)
                {
                    if (scores[i] >= scoreLimit * 0.9)
                    {
                        return false;
                    }
                }
            }
        }
        if (this.localData.gameModeData["bAutoBalancing"])
        {
            return false;
        }
        this.log("Checking auto team balance...");
        var players = this.localData.playerStates;
        if (players.length >= 4)
        {
            var threshold = Math.floor(players.length * 0.5);
            var numPlayers = [
                this.getNumPlayersOnTeam(0),
                this.getNumPlayersOnTeam(1),
            ];
            for (var i = 0; i < 2; i++)
            {
                var curTeam = numPlayers[i];
                if (curTeam < threshold)
                {
                    var boostTeam = i;
                    break;
                }
            }
            if (boostTeam != null)
            {
                this.localData.gameModeData["bAutoBalancing"] = true;
                this.requestEvent({
                    eventId: GameServer.EVENT_MESSAGE_ADD,
                    data: {
                        bInfofeed: true,
                        type: "message",
                        message: "STR_TEAMS_WILL_BE_BALANCED"
                    }
                });
                setTimeout(() =>
                {
                    if (this.matchHasEnded())
                    {
                        return;
                    }                    
                    var added = 0;
                    for (var i = players.length - 1; i >= 0; i--)
                    {
                        var ps = players[i];
                        if (ps["team"] != boostTeam && !ps["currentPartyId"])
                        {
                            if (added + 1 >= (threshold))
                            {
                                break;
                            }
                            this.killPawn(ps["id"]);
                            ps["team"] = boostTeam;

                            if (this.localData.factions)
                            {
                                var teamFaction = this.localData.factions[boostTeam];
                                if (ps.avatars && ps.avatars[teamFaction])
                                {
                                    ps["avatarData"] = ps.avatars[teamFaction];
                                }
                                else
                                {
                                    ps["avatarData"].body = teamFaction;
                                }
                            }

                            this.onEvent({
                                eventId: GameServer.EVENT_PLAYER_UPDATE,
                                playerId: ps["id"],
                                data: {
                                    team: ps["team"],
                                    avatarData: ps["avatarData"]
                                }
                            });
                            added++;                            
                        }
                    }
                    if (added > 0)
                    {
                        this.requestEvent({
                            eventId: GameServer.EVENT_MESSAGE_ADD,
                            data: {
                                message: "STR_TEAMS_HAVE_BEEN_BALANCED"
                            }
                        });
                    }
                    delete this.localData.gameModeData["bAutoBalancing"];
                }, 5000);
                return true;
            }
        }
        return false;
    }

    getNumPlayersOnTeam(_team)
    {
        var num = 0;
        var players = this.localData.playerStates;
        if (players)
        {
            for (var i = 0; i < players.length; i++)
            {
                if (players[i]["team"] == _team)
                {
                    num++;
                }
            }
        }
        return num;
    }

    canAcceptNewPlayers()
    {
        if (this.bGameEnded)
        {
            return false;
        }
        if (this.localData)
        {
            if (this.localData["bBattlezone"])
            {
                return this.localData["gameTimer"] >= 120;
            }
            if (this.localData["bSurvival"])
            {
                return true; //this.localData.gameModeData.wave <= 1;
            }
            else if (!this.localData["bModeGame"])
            {
                return false;
            }
            if (this.localData["gameTimer"] < 60 && !this.localData.gameModeData.numRounds)
            {
                return false;
            }
            var scoreLimit = this.localData.gameModeData["scoreLimit"];
            switch (this.localData.gameModeData["id"])
            {
                case GameMode.DEATHMATCH:
                    var players = this.getPlayerStates();
                    players.sort(function (a, b)
                    {
                        if (a.kills < b.kills) return 1;
                        if (a.kills > b.kills) return -1;
                        return 0;
                    });
                    if (players.length > 0)
                    {
                        if (players[0]["kills"] >= scoreLimit * 0.9)
                        {
                            return false;
                        }
                    }
                    break;

                case GameMode.INFECTED:
                    if (this.getNumInfected() >= this.localData.playerStates.length)
                    {
                        return false;
                    }
                    if (!this.localData.gameModeData["bFirstInfected"])
                    {
                        return false;
                    }
                    break;

                default:                    
                    if (scoreLimit)
                    {
                        var scores = this.localData.gameModeData["scores"];
                        if (scores)
                        {
                            for (var i = 0; i < scores.length; i++)
                            {
                                if (scores[i] >= scoreLimit * 0.9)
                                {
                                    return false;
                                }
                            }
                        }
                    }
                    break;
            }
            return true;
        }
        return false;
    }

    setGravity(_val)
    {
        this.localData.world.gravity = [0, _val];
        this.onEvent({
            eventId: GameServer.EVENT_SANDBOX,
            data: {
                gravity: this.localData.world.gravity
            }
        });
    }

    handleSandboxEvent(_data)
    {
        try
        {
            switch (_data["type"])
            {
                case "christmas":
                    // Give Players Santa Outfits
                    var players = this.getPlayerStates();
                    for (var i = 0; i < players.length; i++)
                    {
                        this.makePlayerSantaClaus(players[i].id);
                    }

                    // "MERRY CHRISTMAS!!!" message (randomly selected)
                    var christmasMessages = [
                        "HO HO HO!\nMerry Christmas!"
                    ];
                    this.requestEvent({
                        eventId: GameServer.EVENT_MESSAGE_ADD,
                        data: {
                            message: christmasMessages[Math.floor(this.Random(0, christmasMessages.length - 1))],
                            hqSound: "hq_christmas"
                        }
                    });

                    // Spawn presents (random crates) across map
                    var map = this.getCurrentMapData();
                    var numPresents = 10;
                    for (var i = 0; i < numPresents; i++)
                    {
                        // presentPositionX. Think of it as splitting the map into 5 segments (based on numPresents) and then choosing a random X position in that segment.
                        var presentPositionX = (((map.width / numPresents) * i) + this.Random(0, (map.width / (numPresents))));
                        // goofyPresentPositionDecider, lol. I'm a god at variable names.
                        // 1 in 5 chance of a present spawning off the map and shooting in. Intentional bug.
                        var goofyPresentPositionDecider = this.Random(0, 10);
                        if (goofyPresentPositionDecider == 9) presentPositionX += map.width;
                        if (goofyPresentPositionDecider == 10) presentPositionX -= map.width;
                        var random = i < 3 ? 1 : this.Random(1, 5);
                        switch (random)
                        {
                            case 1: // Shard
                                this.createShardCrate((((map.width / numPresents) * i) + this.Random(0, (map.width / (numPresents)))), 500, 1);
                                break;

                            case 2: // Care Package (modded so each killstreak has an equal chance. More interesting.)
                                var killstreaks = [
                                    Killstreaks.KILLSTREAK_SAM_TURRET_PLACE,
                                    Killstreaks.KILLSTREAK_SENTRY_GUN_PLACE,
                                    Killstreaks.KILLSTREAK_UAV,
                                    Killstreaks.KILLSTREAK_COUNTER_UAV,
                                    Killstreaks.KILLSTREAK_WEAPON_M202,
                                    Killstreaks.KILLSTREAK_WEAPON_MINIGUN,
                                    Killstreaks.KILLSTREAK_HELLFIRE,
                                    Killstreaks.KILLSTREAK_RCXD,
                                    Killstreaks.KILLSTREAK_AIRSTRIKE,
                                    Killstreaks.KILLSTREAK_BOMBARDMENT,
                                    Killstreaks.KILLSTREAK_NAPALM,
                                    Killstreaks.KILLSTREAK_REMOTE_TURRET,
                                    Killstreaks.KILLSTREAK_ADVANCED_TURRET,
                                    Killstreaks.KILLSTREAK_GRENADE_TURRET,
                                    Killstreaks.KILLSTREAK_COBRA,
                                    Killstreaks.KILLSTREAK_COBRA_CONTROLLABLE,
                                    Killstreaks.KILLSTREAK_MH6,
                                    Killstreaks.KILLSTREAK_MH6_GRENADE,
                                    Killstreaks.KILLSTREAK_PAVE_LOW,
                                    Killstreaks.KILLSTREAK_CHOPPER_GUNNER,
                                    Killstreaks.KILLSTREAK_REAPER,
                                    Killstreaks.KILLSTREAK_DRAGONFIRE,
                                    Killstreaks.KILLSTREAK_SCOUT,
                                    Killstreaks.KILLSTREAK_HELI_SNIPER,
                                    Killstreaks.KILLSTREAK_STEALTH_BOMBER,
                                    Killstreaks.KILLSTREAK_EMP,
                                    Killstreaks.KILLSTREAK_ESCORT_AIRDROP,
                                    Killstreaks.KILLSTREAK_JUGGERNAUT_USE,
                                    Killstreaks.KILLSTREAK_JUGGERNAUT_RECON_USE
                                ];
                                this.createKillstreakCrate(presentPositionX, 500, killstreaks[this.Random(0, killstreaks.length - 1)], null, Battlezone.TEAM_AIRDROPS);
                                break;

                            case 3: // Perk Crate (perks taken from the ones in Battlezone)
                                var gamePerks = [
                                    Perks.PERK_PLAYER_LIGHTWEIGHT,
                                    Perks.PERK_PLAYER_SITREP,
                                    Perks.PERK_PLAYER_JUGGERNAUT,
                                    Perks.PERK_PLAYER_ANTI_SNIPER,
                                    Perks.PERK_PLAYER_HELMET,
                                    Perks.PERK_PLAYER_COLD_BLOODED,
                                    Perks.PERK_PLAYER_SPECIALIST,
                                    Perks.PERK_PLAYER_NINJA,
                                    Perks.PERK_WEAPON_ACCURACY,
                                    Perks.PERK_WEAPON_SHRAPNEL,
                                    Perks.PERK_WEAPON_QUICKDRAW,
                                    Perks.PERK_WEAPON_AGGRESSION,
                                    Perks.PERK_WEAPON_RELOAD,
                                    Perks.PERK_WEAPON_VAMPIRE,
                                    Perks.PERK_WEAPON_STOPPING_POWER
                                ];
                                this.createPerkCrate(presentPositionX, 500, null, gamePerks[this.Random(0, gamePerks.length - 1)], Battlezone.TEAM_AIRDROPS);
                                break;

                            case 4: // Weapon Crate
                                var items = [];
                                var numItems = this.Random(1, 3);
                                for (var i = 0; i < numItems; i++)
                                {
                                    let randomWeapon = this.getRandomWeapon(true);
                                    let randomMods = this.getRandomMods(randomWeapon);
                                    this.applyWeaponMods(randomWeapon, randomMods);
                                    items.push(randomWeapon);
                                }
                                this.createItemCrate(presentPositionX, 500, null, items, Battlezone.TEAM_AIRDROPS);
                                break;

                            case 5: // Split between three other crate options, so these will be less common
                                // It's bugged, and causes the number of crates spawned to be different from numPresents. I left it, because I like the randomness of the crates now.
                                var random2 = this.Random(1, 3);
                                switch (random2)
                                {
                                    case 1: // XP Crate (10,000 - 50,000 XP)
                                        this.createXPCrate(presentPositionX, 500, this.RoundToNearest(this.Random(10000, 50000)));
                                        break;

                                    case 2: // Ammo crate
                                        this.createAmmoCrate(presentPositionX, 500, null, Battlezone.TEAM_AIRDROPS);
                                        break;

                                    case 3: // Decoy crate, so 1 in 4 chance that a present will be a decoy. >:)
                                        this.createDecoyCrate(presentPositionX, 500, null, Battlezone.TEAM_AIRDROPS);
                                        break;
                                }
                                break;
                        }
                    }

                    // Santa's sleigh (an Osprey) drops off some goodies (code adapted from the Battlezone osprey)
                    //
                    var christmasFolks = [
                        // Have not implemeted weight yet. Am lazy.
                        { unitId: SurvivalEnemyType.RUS_C4, name: "Christmas Angel", weight: 20 },
                        { unitId: SurvivalEnemyType.OPFOR_BASIC, name: "Elf", weight: 8 },
                        { unitId: SurvivalEnemyType.OPFOR_HEAVY, name: "Elf", weight: 8 },
                        { unitId: SurvivalEnemyType.RUS_MELEE, name: "Rabid Elf", weight: 6 },
                        { unitId: SurvivalEnemyType.JUGGERNAUT, name: "Chonky Elf", weight: 5 },
                        { unitId: SurvivalEnemyType.HOSTAGE, name: "Lost Child", weight: 10 },
                        { unitId: SurvivalEnemyType.ZOMBIE_SPRINTER, name: "Reindeer", weight: 10 },
                        { unitId: SurvivalEnemyType.ZOMBIE_SPRINTER_BOSS, name: "Rudolph the Red-nosed Reindeer", weight: 2 },
                        { unitId: SurvivalEnemyType.ZOMBIE_FLAMETHROWER, name: "Frosty the Snowman", weight: 3 },
                        { unitId: SurvivalEnemyType.RUS_EXPLOSIVES, name: "Ebenezer Scrooge", weight: 3 },
                        { unitId: Heroes.XWILKINX, name: "Krampus", weight: 1 },
                        { unitId: Heroes.SANTA, name: "Santa Claus", weight: 1 }
                    ];
                    // Collating which goodies the osprey should drop off
                    var items = [];
                    for (var i = 0; i < 5; i++)
                    {
                        var oneChristmasFolk = christmasFolks[Math.floor(this.Random(0, christmasFolks.length - 1))];
                        items.push({
                            type: "unit",
                            unitId: oneChristmasFolk.unitId,
                            patrolPoints: null,
                            bLOS: true,
                            pawnName: oneChristmasFolk.name
                        });
                    }
                    // Calling in the osprey
                    var ospreyDest = [this.Random(500, map.width - 500), this.Random(800, 1000)];
                    var osprey = this.createHelicopter([ospreyDest[0] > (map.width * 0.5) ? map.width : 0, 0], Battlezone.TEAM_MERCENARIES, {
                        type: Helicopter.TYPE_OSPREY,
                        playerId: null,
                        destination: ospreyDest,
                        items: items,
                        scale: 1
                    });
                    osprey.data.pawnName = "Santa's Sleigh";
                    osprey.data.dropTimerMax = 20;
                    osprey.data.defendTimer = 40;
                    break;

                case "max_wave":
                    this.localData.gameModeData.wave = 100;
                    break;

                case "c4_vest":
                    var players = this.getPlayerStates();
                    for (var i = 0; i < players.length; i++)
                    {
                        this.makePlayerSuicideVest(players[i].id);
                    }
                    this.requestEvent({
                        eventId: GameServer.EVENT_MESSAGE_ADD,
                        data: {
                            message: "Suicide Bomber Takeover",
                            hqSound: "char_hostage_rescuer_killed_1"
                        }
                    });
                    break;

                case "halloween":
                case "zombie":
                    var players = this.getPlayerStates();
                    for (var i = 0; i < players.length; i++)
                    {
                        this.makePlayerZombie(players[i].id, Zombie.TYPE_DEFAULT);
                    }
                    this.requestEvent({
                        eventId: GameServer.EVENT_MESSAGE_ADD,
                        data: {
                            message: "ZOMBIE APOCOLYPSE!\nHappy Holloween!",
                            hqSound: "hq_zombies"
                        }
                    });
                    break;

                case "gravity":
                    if (typeof _data["value"] === "number")
                    {
                        this.setGravity(_data["value"]);
                    }
                    break;

                case "friendly_fire":
                    this.localData["bFriendlyFire"] = !this.localData["bFriendlyFire"];
                    _data["bFriendlyFire"] = this.localData["bFriendlyFire"];
                    break;

                case "remove_units":
                    var pawns = this.getPawns().concat(this.getTurrets());
                    for (var i = 0; i < pawns.length; i++)
                    {
                        var pawn = pawns[i];
                        switch (pawn.data["type"])
                        {
                            case "character":
                                if (pawn.data["bBot"])
                                {
                                    this.removeNextStep(pawn);
                                }
                                break;
                            default:
                                this.removeNextStep(pawn);
                                break;
                        }
                    }
                    break;

                case "remove_objects":
                    var objs = this.getDisposableCrates().concat(this.getEquipment()).concat(this.getGrenades());
                    for (var i = 0; i < objs.length; i++)
                    {
                        this.removeNextStep(objs[i]);
                    }
                    break;

                case "remove_spawners":
                    var spawners = this.getSpawners();
                    for (var i = 0; i < spawners.length; i++)
                    {
                        this.removeNextStep(spawners[i]);
                    }
                    break;

                case "player":
                    var char = this.getObjectById(_data["playerId"]);
                    if (char)
                    {
                        if (_data["bResetPerks"])
                        {
                            this.requestEvent({
                                eventId: GameServer.EVENT_PLAYER_UPDATE_INVENTORY,
                                pawnId: _data["playerId"],
                                type: GameServer.INV_PERKS_SET,
                                perks: []
                            });
                        }
                        if (_data["bGodMode"] != undefined)
                        {
                            char.data["bGodMode"] = _data["bGodMode"];
                        }
                        if (_data["bUnlimitedAmmo"] != undefined)
                        {
                            char.data["bUnlimitedAmmo"] = _data["bUnlimitedAmmo"]; //Client only
                            char.data.weapon["bUnlimitedAmmo"] = _data["bUnlimitedAmmo"];                            
                        }
                        this.pushObjectDataUpdate(char.data.id, ["bGodMode", "bUnlimitedAmmo"]);
                        var helis = this.getHelicopters();
                        for (var i = 0; i < helis.length; i++)
                        {
                            var heli = helis[i];
                            if (heli.data.heliData.playerId == _data.playerId)
                            {
                                if (_data["bGodMode"] != undefined)
                                {
                                    heli.data["bGodMode"] = _data["bGodMode"];
                                }
                                if (_data["bUnlimitedAmmo"] != undefined)
                                {
                                    heli.data["bUnlimitedAmmo"] = _data["bUnlimitedAmmo"]; //Client only
                                }
                            }
                        }
                    }
                    break;

                case "spawn":             
                    var spawnX = _data["pos"][0];
                    var spawnY = _data["pos"][1];
                    if (_data["spawnerId"])
                    {
                        var spawners = this.getSpawners();
                        if (spawners.length >= Settings.SANDBOX_MAX_SPAWNERS)
                        {
                            this.removeNextStep(spawners[0]);
                        }
                        this.createSpawner(spawnX, spawnY, _data);
                    }
                    else if (_data["unitId"])
                    {
                        this.createSandboxUnit(_data);
                    }
                    else if (_data["equipmentId"])
                    {
                        this.createEquipment([spawnX, spawnY], _data["team"], this.RandomBoolean() ? 1 : -1, _data["team"] == 0 ? _data["playerId"] : null, this.getWeaponData(_data["equipmentId"]));
                    }
                    else if (_data["killstreakId"])
                    {
                        switch (_data["killstreakId"])
                        {
                            case Killstreaks.KILLSTREAK_RCXD:
                                this.createCar([spawnX, spawnY], _data["team"], {
                                    carType: Car.TYPE_RCXD,
                                    bBot: true
                                });
                                break;
                        }
                    }
                    else if (_data["crateId"])
                    {
                        switch (_data["crateId"])
                        {
                            case Crate.CRATE_DECOY:
                                this.createDecoyCrate(spawnX, spawnY, _data["team"] == 0 ? _data["playerId"] : null, _data["team"]);
                                break;

                            case Crate.CRATE_AMMO:
                                this.createAmmoCrate(spawnX, spawnY, _data["team"] == 0 ? _data["playerId"] : null, _data["team"]);
                                break;

                            case Crate.CRATE_KILLSTREAK:
                                this.createKillstreakCrate(spawnX, spawnY, null, _data["team"] == 0 ? _data["playerId"] : null, _data["team"]);
                                break;

                            case Crate.CRATE_PERK:
                                var perks = this.getSurvivalPerks();
                                this.createPerkCrate(spawnX, spawnY, _data["team"] == 0 ? _data["playerId"] : null, perks[this.Random(0, perks.length - 1)], _data["team"]);
                                break;

                            case Crate.CRATE_BOMB_GENERIC:
                                this.createGenericBombCrate(this.getRandomUniqueId(), spawnX, spawnY, _data["team"], null);
                                break;

                            case Crate.CRATE_XP:
                                this.createXPCrate(spawnX, spawnY, 5000);
                                break;

                            case Crate.CRATE_SHARD:
                                this.createShardCrate(spawnX, spawnY, 1);
                                break;

                            case Crate.CRATE_STORE:
                                this.createStoreCrate(spawnX, spawnY);
                                break;

                            case Crate.CRATE_WEAPON:
                                var items = [];
                                if (_data["itemId"])
                                {
                                    var newItem = this.getWeaponData(_data["itemId"]);
                                    if (newItem)
                                    {
                                        items.push(newItem);
                                    }
                                }
                                else
                                {
                                    var numItems = this.Random(1, 3);
                                    for (var i = 0; i < numItems; i++)
                                    {
                                        let randomWeapon = this.getRandomWeapon(true);
                                        let randomMods = this.getRandomMods(randomWeapon);
                                        this.applyWeaponMods(randomWeapon, randomMods);
                                        items.push(randomWeapon);
                                    }
                                }
                                this.createItemCrate(spawnX, spawnY, _data["team"] == 0 ? _data["playerId"] : null, items, _data["team"]);
                                break;
                        }
                    }
                    break;
            }
        }
        catch (e)
        {
            console.error("Error while handling sandbox event:", e);
        }
    }

    createSandboxUnit(_data)
    {
        var numPawns = this.getPawns(_data["team"]).length;
        if (this.localData.bSandbox || this.localData.bOperation)
        {
            if (numPawns > Settings.SANDBOX_MAX_PAWNS_PER_TEAM)
            {
                return;
            }
        }
        if (_data["unitId"])
        {
            var map = this.getCurrentMapData();
            var enemyId = this.getRandomUniqueId();
            var team = _data["team"];
            var spawnX = _data["pos"][0];
            var spawnY = _data["pos"][1];
            var enemyInfo = this.clone(SurvivalEnemyInfo[_data["unitId"]]);
            if (enemyInfo)
            {
                switch (enemyInfo.type)
                {
                    case "turret":
                        var turret = this.createTurret(enemyId, [spawnX, spawnY], this.RandomBoolean() ? 1 : -1, _data["team"], {
                            type: enemyInfo.turretType,
                            playerId: null
                        });
                        break;

                    case "helicopter":
                        if (this.getHelicopters().length > 10)
                        {
                            return;
                        }
                        var heli = this.createHelicopter([spawnX, enemyInfo.helicopterType == Helicopter.TYPE_DRAGONFIRE ? spawnY : 200], _data["team"], {
                            type: enemyInfo.helicopterType,
                            destination: [map.width * 0.5, map.height * 0.5],
                            killReward: enemyInfo.killReward,
                            avatarData: _data.avatarData
                        });
                        heli.data["bControllable"] = false;
                        heli.data["bBot"] = true;
                        heli.data["bPlayerControlled"] = false;
                        heli.data["bAirdrop"] = false;
                        heli.data["bMaxLookRange"] = true;
                        heli.data["bUnlimitedAmmo"] = true;
                        break;

                    case "infestor":
                        var useBotSkill = enemyInfo.botSkill;
                        this.requestEvent({
                            eventId: GameServer.EVENT_CREATE_INFESTOR,
                            data:
                            {
                                id: enemyId,
                                x: spawnX,
                                y: spawnY,
                                team: _data["team"],
                                infestorType: enemyInfo.infestorType,
                                health: enemyInfo.health * 2,
                                botSkill: useBotSkill,
                                killReward: enemyInfo.killReward,
                                damageMultipliers: enemyInfo.damageMultipliers
                            }
                        });
                        break;

                    case "character":
                    default:
                        useBotSkill = enemyInfo.botSkill;
                        var usePawnName = enemyInfo.pawnName;
                        if (_data.pawnName)
                        {
                            usePawnName = _data.pawnName;
                        }
                        var curWeapon = enemyInfo.weapons[this.Random(0, enemyInfo.weapons.length - 1)];
                        var curWeaponData = this.getWeaponData(curWeapon);
                        var charHealth = enemyInfo.health;
                        if (_data.health)
                        {
                            charHealth = _data.health;
                        }
                        if (enemyInfo.zombieType)
                        {
                            var useInventory = [{ id: curWeapon }];
                            useBotSkill = Math.min(useBotSkill + 1, BotSkill.SKILL_INSANE);
                            charHealth *= 4;
                        }
                        else
                        {
                            useInventory = [
                                {
                                    id: curWeapon,
                                    mods: enemyInfo.bHero ? enemyInfo.mods : this.getRandomMods(curWeaponData)
                                }
                            ];
                            if (!enemyInfo.bDummy)
                            {
                                charHealth *= 2;
                            }
                        }

                        if (enemyInfo.secondaryWeapons)
                        {
                            useInventory.push(
                                { id: enemyInfo.secondaryWeapons[this.Random(0, enemyInfo.secondaryWeapons.length - 1)] }
                            );
                        }
                        var enemyAI = {
                            bPreferDistance: true
                        };
                        if (this.localData["bBattlezone"])
                        {
                            useBotSkill = Math.max(useBotSkill, BotSkill.SKILL_HARD);
                            if (_data["bLOS"] !== false)
                            {
                                enemyAI.bLOS = true;
                                enemyAI.bCanInvestigate = true;
                                enemyAI.bIgnoreOutOfSight = true;
                                enemyAI.bUseActivityTimer = true;
                                if (team == Battlezone.TEAM_MERCENARIES)
                                {
                                    enemyAI.bCanInteract = true;
                                    usePawnName = "Mercenary";
                                    enemyInfo.bRegenHealth = true;
                                }
                            }
                        }
                        if (_data["patrolPoints"] != undefined)
                        {
                            enemyAI["bPatrol"] = true;
                            enemyAI["patrolPoints"] = this.clone(_data.patrolPoints);
                        }
                        if (enemyInfo.bHostage)
                        {
                            var hostageEyewear = [
                                null,
                                Character.EYEWEAR_GLASSES
                            ];
                            enemyInfo.eyewear = hostageEyewear[this.Random(0, hostageEyewear.length - 1)];
                            enemyInfo.hair = this.getRandomHair();
                            enemyInfo.beard = this.getRandomBeard();
                            console.log(enemyInfo);
                        }
                        if (_data.heroId)
                        {
                            var heroData = SurvivalEnemyInfo[_data.heroId];
                            if (heroData)
                            {
                                enemyInfo.eyewear = heroData.eyewear;
                                enemyInfo.heads = heroData.heads;
                                enemyInfo.body = heroData.body;
                                enemyInfo.facewear = heroData.facewear;
                                enemyInfo.face = heroData.face;                                
                            }
                            else
                            {
                                console.warn("Invalid hero id:", _data.heroId);
                            }
                        }                        
                        this.requestEvent({
                            eventId: GameServer.EVENT_CREATE_GENERIC_CHARACTER,
                            data:
                            {
                                id: enemyId,
                                x: spawnX,
                                y: spawnY,
                                team: team,
                                health: charHealth,
                                inventory: useInventory,
                                equipment: enemyInfo.equipment,
                                avatarData: {
                                    hairColour: enemyInfo.hairColour ? enemyInfo.hairColour : this.getRandomHairColour(),
                                    hair: enemyInfo.hair ? enemyInfo.hair : (enemyInfo.zombieType != undefined ? Character.HAIR_BALD : this.getRandomHair()),
                                    beard: enemyInfo.beard ? enemyInfo.beard : Character.BEARD_NONE,
                                    face: enemyInfo.faces ? enemyInfo.faces[this.Random(0, enemyInfo.faces.length - 1)] : undefined,
                                    head: enemyInfo.heads[this.Random(0, enemyInfo.heads.length - 1)],
                                    body: enemyInfo.body,
                                    facewear: enemyInfo.facewear,
                                    eyewear: enemyInfo.eyewear
                                },
                                botSkill: useBotSkill,
                                killReward: enemyInfo.killReward,
                                bZombie: enemyInfo.zombieType != undefined,
                                zombieType: enemyInfo.zombieType,
                                damageMultipliers: enemyInfo.damageMultipliers,
                                ai: enemyAI,
                                maxSpeed: enemyInfo.maxSpeed,
                                baseSpeedMultiplier: enemyInfo.baseSpeedMultiplier,
                                bRegenHealth: enemyInfo.bHero || enemyInfo.bRegenHealth,
                                pawnName: usePawnName,
                                bHero: enemyInfo.bHero,
                                perks: enemyInfo.perks,
                                bDummy: enemyInfo.bDummy,
                                bHostage: enemyInfo.bHostage
                            }
                        });
                        break;
                }
            }
        }
    }

    isOutOfMap(_body)
    {
        if (_body)
        {
            var map = this.getCurrentMapData();
            if (map)
            {
                if (_body.position[0] < 0 || _body.position[0] > map.width || _body.position[1] >= map.height)
                {
                    return true;
                }
            }
        }
        return false;
    }

    getCurrentMapData() 
    {
        return this.getMapData(this.localData["mapId"]);
    }

    getHeliMaxY()
    {
        var maxY = this.getSharedData("heliMaxY");
        var map = this.getCurrentMapData();
        if (map)
        {
            if (this.localData.bOperation)
            {
                if (map.heliMaxYOps)
                {
                    return Math.min(maxY, map.heliMaxYOps);
                }
            }
            if (map.heliMaxY)
            {
                return Math.max(maxY, map.heliMaxY);
            }
        }
        return maxY;
    }

    getMapData(_id)
    {
        var maps = this.data["maps"];
        for (var i = 0; i < maps.length; i++)
        {
            let map = maps[i];
            if (map && map["id"] == _id)
            {
                return map; //this.clone(maps[i]);
            }
        }
        return null;
    }

    getSurfaceNormal(_body)
    {
        if (_body)
        {
            var world = this.localData["world"];
            for (var i = 0; i < world.narrowphase.contactEquations.length; i++)
            {
                var c = world.narrowphase.contactEquations[i];
                if (c.bodyA === _body || c.bodyB === _body)
                {
                    return c.normalA;
                }
            }
        }
        return null;
    }

    getSurfaceMaterial(_body)
    {
        if (_body)
        {
            var world = this.localData["world"];
            var len = world.narrowphase.contactEquations.length;
            for (var i = 0; i < len; i++)
            {
                var c = world.narrowphase.contactEquations[i];
                if (c.bodyA === _body || c.bodyB === _body)
                {
                    var data = c.bodyA.data;
                    if (data)
                    {
                        return data.material ? data.material : "default";
                    }
                }
            }
        }
        return null;
    }

    isOnGround(_body)
    {
        if (_body)
        {
            var p2 = this.p2;
            var yAxis = p2.vec2.fromValues(0, -1);
            var bResult = false;
            var world = this.localData["world"];
            var len = world.narrowphase.contactEquations.length;
            for (var i = 0; i < len; i++)
            {
                var c = world.narrowphase.contactEquations[i];
                if (c.bodyA === _body || c.bodyB === _body)
                {
                    var d = p2.vec2.dot(c.normalA, yAxis);
                    if (c.bodyA === _body)
                    {
                        d *= -1;
                    }
                    if (d > 0.5)
                    {
                        bResult = true;
                    }
                }
            }
            return bResult;
        }
        return false;
    }

    checkExplosion(_x, _y, _radius, _damage, _instigatorId, _causerId, _weaponId, _bIgnoreLOS = false, _directHitId = null)
    {
        var instigator = this.getPlayerStateById(_instigatorId);
        var causer = this.getObjectById(_causerId);
        var damageAmount = _damage;
        var bLOS = !_bIgnoreLOS;

        var causerTeam = instigator ? instigator.team : null;
        if (!causerTeam)
        {
            causerTeam = causer ? causer.team : null;
        }
        this.emitAISound([_x, _y], causerTeam);

        var objects = this.getPawns();
        objects = objects.concat(this.getEquipment());
        objects = objects.concat(this.getGrenades());
        objects = objects.concat(this.getDestructableObjects());
        objects = objects.concat(this.getObstaclesWithHealth());
        objects = objects.concat(this.getDoors());
        for (var i = 0; i < objects.length; i++)
        {
            var cur = objects[i];
            if (cur.data.bPendingRemoval)
            {
                damageAmount = 0;
                continue;
            }
            if (cur.data["bInvisible"])
            {
                continue;
            }
            if (cur.data["type"] == "character")
            {
                var ps = this.getPlayerStateById(cur.data["id"]);
                if (ps && ps["bSpawnProtection"])
                {
                    continue;
                }
            }
            else if (cur.data["type"] == "door")
            {                
                if (!cur.data["bClosed"])
                {
                    continue;
                }
            }
            else if (cur.data["type"] == "destructableObject")
            {
                if (cur.data.destructableData["type"] == "deployable_cover")
                {
                    if (this.localData["bSurvival"] && causerTeam == cur.data["team"])
                    {
                        continue;
                    }
                }
            }    
            
            if (cur.data["health"])
            {
                var distMult = 1;
                var distFromCenter = this.Dist(_x, _y, cur.position[0], cur.position[1]);
                if (distFromCenter <= _radius)
                {
                    if (cur.data.type == "door" && cur.data.bClosed)
                    {
                        this.setDoorClosed(cur, false, causer);
                    }
                    if (bLOS)
                    {
                        if (!this.checkLineOfSight([_x, _y], cur.position))
                        {
                            continue;
                        }
                    }
                    var bAlly = false;
                    var bSelf = false;
                    if (instigator)
                    {
                        bSelf = cur.data["id"] == instigator["id"];
                        bAlly = cur.data["team"] == instigator["team"] && !bSelf;
                    }
                    else if (causer)
                    {
                        bSelf = cur.data["id"] == causer["id"];
                        bAlly = cur.data["team"] == causer["team"] && !bSelf;
                    }
                    if (!this.localData["bFriendlyFire"])
                    {
                        bAlly = bAlly || bSelf;
                    }
                    if (this.localData.bOperation)
                    {
                        bAlly = bAlly || (causerTeam == 0 && cur.data.team == 0);
                    }
                    if (_weaponId == "bomb")
                    {
                        bAlly = false; //Bomb crates kill everyone
                    }                    
                    if (cur.data["type"] == "character" && bAlly)
                    {
                        damageAmount = 0;
                    }
                    else if (cur.data["type"] == "turret" && bAlly)
                    {
                        damageAmount = 0; //TODO: Can destroy own turrets
                    }
                    else if (cur.data["type"] == "helicopter")
                    {
                        //Handle helicopter explosive damage
                        if (bAlly)
                        {
                            damageAmount = 0;
                        }
                        else if (cur.data["id"] == _directHitId)
                        {
                            damageAmount = 0; //Direct hit, so don't apply additional explosive damage
                        }
                        else
                        {
                            distMult = (1 - distFromCenter / _radius) * 0.5;
                            damageAmount = _damage * distMult;
                            if (cur.data["bDrone"])
                            {
                                if (_weaponId == "stun" || _weaponId == "m203" || _weaponId == "zombie_exploder_boss")
                                {
                                    cur.data["bStunned"] = true;
                                    var maxStunTime = Math.round(this.localData.settings.fps * 6);
                                    cur.data["stunTimer"] = Math.ceil(maxStunTime * distMult);
                                    this.onEvent({
                                        eventId: GameServer.EVENT_PAWN_ACTION,
                                        pawnId: cur.data["id"],
                                        type: GameServer.PAWN_STUN,
                                        bValue: true,
                                        time: cur.data["stunTimer"]
                                    });
                                }
                                else if (_weaponId == "flashbang" || _weaponId == "m320")
                                {
                                    cur.data["bFlashed"] = true;
                                    var maxFlashTime = Math.round(this.localData.settings.fps * 6);
                                    cur.data["flashTimer"] = Math.ceil(maxFlashTime * distMult);
                                    this.onEvent({
                                        eventId: GameServer.EVENT_PAWN_ACTION,
                                        pawnId: cur.data["id"],
                                        type: GameServer.PAWN_FLASH,
                                        bValue: true,
                                        flashIntensity: 1,
                                        time: cur.data["flashTimer"]
                                    });
                                }
                            }
                        }
                    }
                    else
                    {
                        distMult = 1 - distFromCenter / _radius;
                        damageAmount = _damage * distMult;
                        //var force = Math.min(damageAmount * 2, 500);
                        if (distFromCenter > _radius * 0.8)
                        {
                            damageAmount *= 0.2;
                        }
                        if (distFromCenter > _radius * 0.5)
                        {
                            damageAmount *= 0.5;
                        }
                        else if (distFromCenter > _radius * 0.2)
                        {
                            damageAmount *= 0.8;
                        }
                        var flashMult = 1;
                        if (_weaponId == "stun" || _weaponId == "m203" || _weaponId == "zombie_exploder_boss")
                        {
                            cur.data["bStunned"] = true;
                            if (this.characterHasPerk(cur, Perks.PERK_PLAYER_SITREP))
                            {
                                cur.data["stunTimer"] = 1;
                                var bSitrep = true;
                            }
                            else
                            {
                                var maxStunTime = Math.round(this.localData.settings.fps * 6);
                                switch (cur.data["type"])
                                {
                                    case "turret":
                                        cur.data["stunTimer"] = maxStunTime;
                                        break;

                                    default:
                                        if (this.localData["bOperation"])
                                        {
                                            if (cur.data["team"] == 1)
                                            {
                                                cur.data["stunTimer"] = maxStunTime;
                                            }
                                            else
                                            {
                                                cur.data["stunTimer"] = Math.ceil((maxStunTime * distMult) * 0.5);
                                            }
                                        }
                                        else if (cur.data["bZombie"])
                                        {
                                            cur.data["stunTimer"] = maxStunTime;
                                        }
                                        else
                                        {
                                            cur.data["stunTimer"] = Math.ceil((maxStunTime * distMult) * flashMult);
                                        }
                                        cur.data["stunTimer"] = Math.max(this.localData.settings.fps * 2, cur.data["stunTimer"]);                                        
                                        break;
                                }
                            }

                            cur.data["aimRotation"] += this.ToRad(this.Random(-30, 30));

                            //TODO: Handle stuns/flashes in EVENT_PAWN_DAMAGE
                            this.onEvent({
                                eventId: GameServer.EVENT_PAWN_ACTION,
                                pawnId: cur.data["id"],
                                type: GameServer.PAWN_STUN,
                                bValue: true,
                                time: cur.data["stunTimer"]
                            });
                        }
                        else if (_weaponId == "flashbang" || _weaponId == "m320")
                        {
                            cur.data["bFlashed"] = true;
                            cur.data["flashIntensity"] = Math.min(1, distMult * 2);
                            if (this.characterHasPerk(cur, Perks.PERK_PLAYER_SITREP))
                            {
                                cur.data["flashTimer"] = 1;
                                var bSitrep = true;
                            }
                            else
                            {
                                var maxFlashTime = Math.round(this.localData.settings.fps * 6);
                                switch (cur.data["type"])
                                {
                                    case "turret":
                                        cur.data["flashTimer"] = maxFlashTime;
                                        break;

                                    default:
                                        if (this.localData["bOperation"] && cur.data["team"] == 1)
                                        {
                                            cur.data["flashTimer"] = maxFlashTime;
                                        }
                                        else if (cur.data["bZombie"])
                                        {
                                            cur.data["flashTimer"] = maxFlashTime;
                                        }
                                        else
                                        {
                                            cur.data["flashTimer"] = Math.ceil((maxFlashTime * distMult) * flashMult);
                                        }                                        
                                        break;
                                }
                            }

                            this.onEvent({
                                eventId: GameServer.EVENT_PAWN_ACTION,
                                pawnId: cur.data["id"],
                                type: GameServer.PAWN_FLASH,
                                bValue: true,
                                flashIntensity: cur.data["flashIntensity"],
                                time: cur.data["flashTimer"]
                            });
                        }
                    }
                }
                else
                {
                    damageAmount = 0;
                }

                if (damageAmount > 0)
                {
                    switch (cur.data.type)
                    {
                        case "equipment":
                            if (cur.data["id"] != _causerId)
                            {
                                if (cur.data.weaponData["bMine"])
                                {
                                    if (instigator)
                                    {
                                        cur.data["ownerId"] = instigator["id"];
                                    }
                                    //this.detonate(cur);
                                    cur.data["bTriggered"] = true;
                                    cur.data["triggerTimer"] = 2;
                                }
                                else
                                {
                                    /*
                                    cur.data["health"] = Math.max(0, cur.data["health"] - damageAmount);
                                    if (cur.data["health"] <= 0)
                                    {
                                        this.removeNextStep(cur);                                        
                                    }
                                    */
                                    this.requestEvent({
                                        eventId: GameServer.EVENT_PAWN_DAMAGE,
                                        damageType: DamageType.DAMAGE_EXPLOSIVE,
                                        damageAmount: damageAmount,
                                        pawnId: cur.data["id"],
                                        attackerId: instigator ? instigator["id"] : _causerId,
                                        causerId: _causerId,
                                        weaponId: _weaponId,
                                        bDirectlyCausedByPlayer: true
                                    });
                                }
                            }
                            break;

                        case "grenade":
                            if (cur.data["bRemoteDetonation"])
                            {
                                cur.data.bDetonationTimerEnabled = true;
                                cur.data.detonationTimer = 2;
                            }
                            break;

                        default:
                            this.requestEvent({
                                eventId: GameServer.EVENT_PAWN_DAMAGE,
                                damageType: DamageType.DAMAGE_EXPLOSIVE,
                                damageAmount: damageAmount,
                                pawnId: cur.data["id"],
                                attackerId: instigator ? instigator["id"] : _causerId,
                                causerId: _causerId,
                                weaponId: _weaponId,
                                bSitrep: bSitrep,
                                bDirectlyCausedByPlayer: true
                            });
                            break;
                    }
                }
            }
        }

    }

    isInLOS(_startPos, _endPos, _target)
    {
        var result = this.raycast(_startPos[0], _startPos[1], _endPos[0], _endPos[1]);
        if (result)
        {
            if (result.length == 0)
            {
                return false;
            }
            else
            {
                for (var i = 0; i < result.length; i++)
                {
                    var cur = result[i]["body"];
                    if (result[i].distance < 1000)
                    {
                        switch (cur.data["type"])
                        {
                            case "ground":
                                return false;
                            case "character":
                                return cur == _target;
                        }
                    }
                }
            }
        }
        return false;
    }

    checkLineOfSight(_startPos, _endPos, _bObstaclesBlock, _targetBody)
    {
        var result = this.raycast(_startPos[0], _startPos[1], _endPos[0], _endPos[1]);
        if (result)
        {
            if (result.length == 0)
            {
                return true;
            }
            else
            {
                for (var i = 0; i < result.length; i++)
                {
                    var cur = result[i]["body"];
                    if (cur === _targetBody)
                    {
                        return true;
                    }
                    if (cur.data)
                    {
                        //if (!cur.data["health"])
                        switch (cur.data.type)
                        {
                            case "ground":
                                return false;

                            case "obstacle":
                                if (_bObstaclesBlock) return false;
                                break;

                            case "door":
                                if (_bObstaclesBlock) return false;
                                if (cur.data["bClosed"]) return false;
                                break;
                        }
                    }
                }
            }
        }
        return true;
    }

    raycast(_startX, _startY, _endX, _endY)
    {
        var p2 = this.p2;
        var arr = [];
        var ray = new p2.Ray({
            mode: p2.Ray.ALL,
            from: [_startX, _startY],
            to: [_endX, _endY],
            callback(result)
            {
                var hitPoint = p2.vec2.create();
                result.getHitPoint(hitPoint, ray);
                var bHeadshot = false;
                var bLegshot = false;
                if (result.body.data)
                {
                    switch (result.body.data["type"])
                    {
                        case "infestor":
                            bHeadshot = hitPoint[1] > (result.body.position[1]);
                            break;

                        case "character":
                            bHeadshot = hitPoint[1] < (result.body.position[1] - 22);
                            bLegshot = hitPoint[1] > (result.body.position[1] + 20);
                            break;
                    }
                }
                arr.push({
                    body: result.body,
                    point: { x: hitPoint[0], y: hitPoint[1] },
                    distance: result.getHitDistance(ray),
                    bHeadshot: bHeadshot,
                    bLegshot: bLegshot
                });
            }
        });
        var result = new p2.RaycastResult();        
        this.localData.world.raycast(result, ray);
        arr.sort(function (a, b)
        {
            if (a["distance"] < b["distance"])
            {
                return -1;
            }
            else if (a["distance"] > b["distance"])
            {
                return 1;
            }
            return 0;
        });
        return arr;
    }

    getRandomAvatarData()
    {
        var hairColours = [
            Character.HAIR_COLOUR_BROWN,
            Character.HAIR_COLOUR_BROWN_LIGHT,
            Character.HAIR_COLOUR_BLONDE,
            Character.HAIR_COLOUR_BLACK,
            Character.HAIR_COLOUR_GINGER
        ];
        var hairs = [
            Character.HAIR_SHORT,
            Character.HAIR_LONG,
            Character.HAIR_FLAT,
            Character.HAIR_PONYTAIL,
            Character.HAIR_BUZZED,
            Character.HAIR_UNDERCUT,
            Character.HAIR_STYLED,
            Character.HAIR_SPIKES
        ];
        var beards = [
            Character.BEARD_NONE,
            Character.BEARD_STUBBLE,
            Character.BEARD_FULL,
            Character.BEARD_CIRCLE,
            Character.BEARD_GOATEE
        ];
        var bodies = [
            Character.BODY_USMC_STANDARD,
            Character.BODY_GSG9_STANDARD,
            Character.BODY_GIGN_STANDARD,
            Character.BODY_MILITIA_STANDARD
        ];
        var avatar = {
            hairColour: hairColours[this.Random(0, hairColours.length - 1)],
            hair: hairs[this.Random(0, hairs.length - 1)],
            beard: beards[this.Random(0, beards.length - 1)],
            head: Character.HEAD_NONE,
            body: bodies[this.Random(0, bodies.length - 1)],
            facewear: Character.FACEWEAR_NONE,
            eyewear: Character.EYEWEAR_NONE
        };
        return avatar;
    }

    //GameUtil
    clone(_data)
    {
        return JSON.parse(JSON.stringify(_data));
    }

    arraysEqual(a, b)
    {
        if (a === b) return true;
        if (a == null || b == null) return false;
        if (a.length !== b.length) return false;
        for (var i = 0; i < a.length; ++i)
        {
            if (a[i] !== b[i]) return false;
        }
        return true;
    }

    shuffleArray(array)
    {
        var currentIndex = array.length, temporaryValue, randomIndex;
        while (0 !== currentIndex)
        {
            randomIndex = Math.floor(Math.random() * currentIndex);
            currentIndex -= 1;
            temporaryValue = array[currentIndex];
            array[currentIndex] = array[randomIndex];
            array[randomIndex] = temporaryValue;
        }
        return array;
    }

    pxmi(v)
    {
        return v; //v * -0.05;
    }

    loadPolygon(_id, _body, _width, _height, _scale, _shapeData)
    {
        var data = this.getSpriteData(_id);

        var scale = 1;

        //  We've multiple Convex shapes, they should be CCW automatically
        var cm = this.p2.vec2.create();

        for (var i = 0; i < data.length; i++)
        {
            var vertices = [];

            for (var s = 0; s < data[i].shape.length; s += 2)
            {
                vertices.push([
                    this.pxmi(data[i].shape[s] * scale),
                    this.pxmi(data[i].shape[s + 1] * scale)
                ]);
            }

            var c = new this.p2.Convex({ vertices: vertices });
            c.material = _shapeData.material;
            c.collisionGroup = _shapeData.collisionGroup;
            c.collisionMask = _shapeData.collisionMask;

            // Move all vertices so its center of mass is in the local center of the convex
            for (var j = 0; j !== c.vertices.length; j++)
            {
                var v = c.vertices[j];
                this.p2.vec2.sub(v, v, c.centerOfMass);
            }

            this.p2.vec2.scale(cm, c.centerOfMass, 1);

            cm[0] -= this.pxmi(_width / 2);
            cm[1] -= this.pxmi(_height / 2);

            c.updateTriangles();
            c.updateCenterOfMass();
            c.updateBoundingRadius();

            _body.addShape(c, cm);
        }

        _body.aabbNeedsUpdate = true;
        //this.shapeChanged();
        return true;
    }

    //BotUtil
    GetBotDesiredClassData(_botSkill = 0)
    {
        var primaries = [
            "m16a4",
            "tar21",
            "mp5",
            "ump45",
            "m3",
            "m1014",
            "ak47",
            "m40a3",
            "samr",
            "mg4",
            "m60e4"
        ];
        var secondaries = [
            "m9",
            "g17"
        ];
        var equipments = [
            null,
            null,
            null,
            "frag",
            "sensor",
            "jammer"
        ];
        if (_botSkill >= BotSkill.SKILL_NORMAL)
        {
            secondaries.push("riot_shield", "tazer", "m203", "m320", "kard", "mac11");
            equipments.push("claymore", "betty", "tac_insert");
        }
        if (_botSkill >= BotSkill.SKILL_HARD)
        {
            primaries.push("mp7", "ak74u", "arp");
            primaries.push("m4a1", "ak47", "hk416", "aug", "fal");
            primaries.push("spas12", "aa12", "m1216");
            primaries.push("r700", "rsass", "sr25", "dragunov", "steyr");
            primaries.push("m60e4", "aughbar", "m249", "bren");
            secondaries.push("usp45", "fiveseven", "m1911", "m93r", "g18", "mp9", "smaw", "javelin", "vp70", "mk22", "snub");
            equipments.push("stim", "stun", "flashbang", "trophy", "kevlar")
        }
        if (_botSkill >= BotSkill.SKILL_INSANE)
        {
            primaries.push("vector", "p90", "evo3", "pdr", "bizon");
            primaries.push("ksg", "db", "saiga12", "dp12", "jackhammer");
            primaries.push("famas", "scarh", "acr", "g36c", "an94", "lvoa", "par4", "g3");
            primaries.push("l115a3", "msr", "m82", "intervention", "sg550", "pgm");
            primaries.push("pecheneg", "hamr", "rpk", "qbb95", "m240", "ultimax", "mg42");
            secondaries.push("magnum", "deagle", "rhino", "p320", "kard", "thumper", "rpg", "xm25", "stinger", "m202", "crossbow", "matador");
            equipments.push("knife", "semtex");
        }
        var playerPerks = [
            Perks.PERK_PLAYER_LIGHTWEIGHT,
            Perks.PERK_PLAYER_JUGGERNAUT,
            Perks.PERK_PLAYER_GHOST,
            Perks.PERK_PLAYER_COLD_BLOODED,
            Perks.PERK_PLAYER_SPECIALIST,
            Perks.PERK_PLAYER_MARTYRDOM,
            Perks.PERK_PLAYER_NINJA,
            Perks.PERK_PLAYER_SITREP,
            Perks.PERK_PLAYER_HELMET,
            Perks.PERK_PLAYER_ANTI_SNIPER
        ];
        var weaponPerks = [
            Perks.PERK_WEAPON_AMMO,
            Perks.PERK_WEAPON_ACCURACY,
            Perks.PERK_WEAPON_QUICKDRAW,
            Perks.PERK_WEAPON_RELOAD,
            Perks.PERK_WEAPON_RECON,
            Perks.PERK_WEAPON_STOPPING_POWER,
            Perks.PERK_WEAPON_SHRAPNEL,
            Perks.PERK_WEAPON_AGGRESSION,
            Perks.PERK_WEAPON_VAMPIRE
        ];

        if (_botSkill == BotSkill.SKILL_GOD)
        {
            secondaries = [
                "riot_shield",
                "rpg",
                "stinger",
                "m202",
                "matador"
            ];
            playerPerks = [
                Perks.PERK_PLAYER_LIGHTWEIGHT,
                Perks.PERK_PLAYER_JUGGERNAUT,
                Perks.PERK_PLAYER_SPECIALIST,
                Perks.PERK_PLAYER_HELMET,
                Perks.PERK_PLAYER_ANTI_SNIPER
            ];
            weaponPerks = [
                Perks.PERK_WEAPON_RELOAD,
                Perks.PERK_WEAPON_STOPPING_POWER,
                Perks.PERK_WEAPON_SHRAPNEL,
                Perks.PERK_WEAPON_AGGRESSION,
                Perks.PERK_WEAPON_VAMPIRE
            ];
        }

        //Bot weapon mods
        var baseMods = [
            null,
            null,
            Mods.BASE_DAMPER,
            Mods.BASE_DEADEYE,
            Mods.BASE_RANGE,
            Mods.BASE_RAPID_FIRE,
            Mods.BASE_SPEED
        ];
        var barrelMods = [
            null,
            null,
            Mods.BARREL_LASER
        ];
        var selectedPrimary = primaries[this.Random(0, primaries.length - 1)];
        var weaponData = this.getWeaponData(selectedPrimary);
        switch (weaponData["type"])
        {
            case Weapon.TYPE_SMG:
            case Weapon.TYPE_RIFLE:
                if (!weaponData["bSilenced"])
                {
                    barrelMods.push(Mods.BARREL_SILENCER);
                }
                if (weaponData["fireMode"] == Weapon.MODE_AUTO)
                {
                    baseMods.push(Mods.BASE_BURST_FIRE);
                }
                break;

            case Weapon.TYPE_SNIPER:
                if (weaponData["id"] != "m82" && weaponData["id"] != "intervention" && weaponData["id"] != "pgm")
                {
                    barrelMods.push(Mods.BARREL_SILENCER);
                }
                break;
        }
        var ammoMods = [
            null,
            null,
            Mods.AMMO_FMJ,
            Mods.AMMO_PIERCING,
            Mods.AMMO_EXTENDED,
            Mods.AMMO_PIERCING
        ];
        if (weaponData["type"] != Weapon.TYPE_LAUNCHER && weaponData["bSingleRoundLoaded"])
        {
            ammoMods.push(Mods.AMMO_SPEED_LOADER);
        }
        if (weaponData["type"] == Weapon.TYPE_SHOTGUN && weaponData["bBoltAction"])
        {
            ammoMods.push(Mods.AMMO_SLUG);
        }
        if (_botSkill == BotSkill.SKILL_GOD)
        {
            var baseMods = [
                Mods.BASE_RANGE
            ];
        }
        var mods = {
            base: baseMods[this.Random(0, baseMods.length - 1)],
            barrel: barrelMods[this.Random(0, barrelMods.length - 1)],
            ammo: ammoMods[this.Random(0, ammoMods.length - 1)],
        };
        var classData = {
            primary: {
                id: selectedPrimary,
                mods: mods
            },
            secondary: {
                id: secondaries[this.Random(0, secondaries.length - 1)]
            },
            equipment: equipments[this.Random(0, equipments.length - 1)],
            playerPerk: playerPerks[this.Random(0, playerPerks.length - 1)],
            weaponPerk: weaponPerks[this.Random(0, weaponPerks.length - 1)],
            killstreak: this.RandomBoolean() ? Killstreaks.TYPE_ASSAULT : Killstreaks.TYPE_SUPPORT
        };
        return classData;
    }

    GetBotDesiredKillstreaks(_botSkill)
    {
        var killstreaks = {};
        var assault1 = [
            Killstreaks.KILLSTREAK_UAV,
            Killstreaks.KILLSTREAK_CARE_PACKAGE
        ];
        var assault2 = [
            Killstreaks.KILLSTREAK_RCXD,
            Killstreaks.KILLSTREAK_HELLFIRE,
            Killstreaks.KILLSTREAK_AIRSTRIKE,
            Killstreaks.KILLSTREAK_NAPALM,
            Killstreaks.KILLSTREAK_COBRA,
            Killstreaks.KILLSTREAK_SCOUT
        ];
        var assault3 = [
            Killstreaks.KILLSTREAK_SENTRY_GUN,
            Killstreaks.KILLSTREAK_CHOPPER_GUNNER,
            Killstreaks.KILLSTREAK_PAVE_LOW,
            Killstreaks.KILLSTREAK_BOMBARDMENT,
            Killstreaks.KILLSTREAK_REAPER,
            Killstreaks.KILLSTREAK_MH6_GRENADE,
            Killstreaks.KILLSTREAK_COBRA_CONTROLLABLE,
            Killstreaks.KILLSTREAK_JUGGERNAUT,
        ];
        killstreaks[Killstreaks.TYPE_ASSAULT] = [
            assault1[this.Random(0, assault1.length - 1)],
            assault2[this.Random(0, assault2.length - 1)],
            assault3[this.Random(0, assault3.length - 1)]
        ];
        var support1 = [
            Killstreaks.KILLSTREAK_AMMO,
            Killstreaks.KILLSTREAK_COUNTER_UAV,
            Killstreaks.KILLSTREAK_UAV_SUPPORT
        ];
        var support2 = [
            Killstreaks.KILLSTREAK_DECOY,
            Killstreaks.KILLSTREAK_SUPPORT_AIRDROP,
            Killstreaks.KILLSTREAK_SAM_TURRET,
            Killstreaks.KILLSTREAK_REMOTE_TURRET,
            Killstreaks.KILLSTREAK_DRAGONFIRE,
            Killstreaks.KILLSTREAK_ADVANCED_TURRET
        ];
        var support3 = [
            Killstreaks.KILLSTREAK_STEALTH_BOMBER,
            Killstreaks.KILLSTREAK_HELI_SNIPER,
            Killstreaks.KILLSTREAK_EMP,
            Killstreaks.KILLSTREAK_ESCORT_AIRDROP,
            Killstreaks.KILLSTREAK_GRENADE_TURRET,
            Killstreaks.KILLSTREAK_JUGGERNAUT_RECON,
        ];
        killstreaks[Killstreaks.TYPE_SUPPORT] = [
            support1[this.Random(0, support1.length - 1)],
            support2[this.Random(0, support2.length - 1)],
            support3[this.Random(0, support3.length - 1)]
        ];
        return killstreaks;
    }

    //MathUtil
    Random(_min, _max)
    {
        return Math.floor(Math.random() * (_max - _min + 1)) + _min;
    }

    RandomBoolean()
    {
        return Math.random() >= 0.5;
    }

    Dist(_x1, _y1, _x2, _y2)
    {
        return Math.sqrt((_x1 - _x2) * (_x1 - _x2) + (_y1 - _y2) * (_y1 - _y2));
    }

    Angle(_x1, _y1, _x2, _y2)
    {
        var distX = _x2 - _x1;
        var distY = _y2 - _y1;
        return this.RoundDecimal(Math.atan2(distY, distX));
    }

    ToRad(_degrees)
    {
        return this.RoundDecimal(_degrees * (Math.PI / 180));
    }

    ToDeg(_radians)
    {
        return _radians * (180 / Math.PI);
    }

    WrapAngle(angle, radians)
    {
        return this.RoundDecimalFine(radians ? this.Wrap(angle, -Math.PI, Math.PI) : this.Wrap(angle, -180, 180));
    }

    Wrap(value, min, max)
    {
        var range = max - min;
        if (range <= 0)
        {
            return 0;
        }
        var result = (value - min) % range;
        if (result < 0)
        {
            result += range;
        }
        return result + min;
    }

    optimizeKeys(_data)
    {
        if (_data)
        {
            var num = 0;
            var keys = Object.keys(_data);
            for (var i = keys.length - 1; i >= 0; i--)
            {
                let key = keys[i];
                if (_data[key] === undefined)
                {
                    delete _data[key];
                    num++;
                }
                else if (typeof _data[key] === "boolean")
                {
                    _data[key] = _data[key] == true ? 1 : 0;
                    num++;
                }
            }
            return num;
        }
        return 0;
    }

    RoundToNearest(_val)
    {
        return Math.ceil(_val / 5) * 5;
    }

    RoundDownToNearestEven(_val)
    {
        return Math.floor(_val / 2) * 2;
    }

    RoundDecimal(_val)
    {
        return Math.trunc(_val * 100) / 100;
    }

    RoundDecimalOne(_val)
    {
        return Math.trunc(_val * 10) / 10;
    }

    RoundDecimalFine(_val)
    {
        return Math.trunc(_val * 10000) / 10000;
    }
}

if (typeof module !== "undefined")
{
    module.exports = {
        GameInstance: GameInstance
    };
}